<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR MR 太陽系探索</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0c0c1e 0%, #1a1a2e 50%, #16213e 100%);
            overflow: hidden;
            height: 100vh;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #canvas {
            display: block;
        }

        .overlay {
            position: absolute;
            color: white;
            font-size: 14px;
            background: rgba(0, 0, 32, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 136, 0.3);
            backdrop-filter: blur(10px);
            pointer-events: none;
        }

        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            z-index: 1000;
        }

        #xr-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            background: linear-gradient(45deg, #00ff88, #0088ff);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            z-index: 100;
        }

        #xr-button:disabled {
            background: #666666;
            cursor: not-allowed;
        }

        #instructions {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 14px;
            max-width: 400px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            text-align: left;
            z-index: 100;
        }

        #info-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            display: none;
            z-index: 9999;
        }

        #warning-panel {
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(139, 0, 0, 0.8);
            text-align: center;
            display: none;
        }

        #planet-info {
            position: absolute !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
            background: rgba(0, 20, 40, 0.98) !important;
            border: 3px solid rgba(0, 255, 136, 1) !important;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.8) !important;
            max-width: 350px;
            display: none;
            z-index: 999999 !important;
            pointer-events: auto;
            color: white !important;
            font-family: 'Courier New', monospace !important;
            font-size: 14px !important;
            opacity: 0; /* XRモードでは3D表示を使用するため非表示 */
            visibility: hidden;
        }

        .info-title {
            color: #00ff88;
            font-size: 18px;
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 0 0 10px #00ff88;
        }

        .info-item {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
        }

        .info-label {
            color: #ffaa00;
        }

        .info-value {
            color: #ffffff;
        }

        .highlight {
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
        }

        .warning {
            color: #ffaa00;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">
            <div style="text-align: center;">
                <div>🌌 MR太陽系を準備中...</div>
                <div style="margin-top: 20px; font-size: 16px;">
                    WebXRセッションを初期化しています
                </div>
            </div>
        </div>

        <button id="xr-button">
            🥽 MR太陽系を開始
        </button>

        <div id="instructions">
            <h3 class="highlight" style="margin: 0 0 10px 0;">🌟 操作方法</h3>
            <div>• 移動：片手グリップ+ドラッグ</div>
            <div>• 拡大/縮小：両手グリップ</div>
            <div>• 惑星クリック：VR+情報表示</div>
            <div>• 空間クリック：MR復帰</div>
        </div>

        <div id="info-panel" class="overlay">
            <div class="highlight" style="margin-bottom: 10px;">
                🥽 MRモード：アクティブ
            </div>
            <div>スケール: <span id="scale-value">1.00</span>x</div>
            <div>両手グリップ: <span id="grip-status">OFF</span></div>
        </div>

        <div id="warning-panel" class="overlay">
            <div style="margin-bottom: 10px;">⚠️ WebXR非対応環境</div>
            <div>このデバイスではMR機能を使用できません。</div>
            <div>Meta Quest、HoloLens、Magic Leap等の対応デバイスをご利用ください。</div>
        </div>

        <div id="planet-info" class="overlay">
            <div class="info-title" id="planet-name">惑星名</div>
            <div class="info-item">
                <span class="info-label">距離:</span>
                <span class="info-value" id="planet-distance">-</span>
            </div>
            <div class="info-item">
                <span class="info-label">サイズ:</span>
                <span class="info-value" id="planet-size">-</span>
            </div>
            <div class="info-item">
                <span class="info-label">公転周期:</span>
                <span class="info-value" id="planet-period">-</span>
            </div>
            <div class="info-item">
                <span class="info-label">特徴:</span>
                <span class="info-value" id="planet-feature">-</span>
            </div>
            <div style="text-align: center; margin-top: 15px; color: #888;">
                トリガーで閉じる
            </div>
        </div>

        <!-- BGM -->
        <audio id="bgm" loop preload="auto" style="display: none;">
            <source src="Mystical Cosmos.mp3" type="audio/mpeg">
        </audio>
    </div>

    <script>
        let scene, camera, renderer, solarSystemGroup;
        let planets = [];
        let controllers = []; // 配列ベースに変更
        let gripStates = { left: false, right: false };
        let lastDistance = 0;
        let scaleFactor = 1;
        let xrSupported = false;
        let xrActive = false;
        let raycaster = new THREE.Raycaster();
        let highlightedPlanets = [null, null]; // 各コントローラーのハイライト対象
        let planetInfoVisible = false;
        let isDragging = false;
        let dragStartPosition = new THREE.Vector3();
        let userStartPosition = new THREE.Vector3();
        let userPosition = new THREE.Vector3(0, 1.6, 5); // ユーザーの仮想位置
        let planetInfoPanel = null;
        let sunScaleAnimation = { target: 1, current: 1, speed: 0.05 };
        let panelFadeAnimation = { opacity: 0, target: 0, speed: 0.05 };
        let spaceMode = false;
        let spaceStars = null;
        let originalStars = null;
        let originalBackground = null;
        let spaceRotation = 0;
        let spaceFadeAnimation = { 
            transitioning: false, 
            progress: 0, 
            target: 0, 
            speed: 0.04,
            targetMode: false 
        };
        let backgroundSphere = null;
        let pendingPlanetInfo = null; // VRモード切り替え後に表示予定の惑星情報
        let dataLoaded = false; // データ読み込み完了フラグ
        let bgMusic = null; // BGM用
        let audioContext = null; // Web Audio API用

        // 惑星データ
        const planetData = [
            { name: '太陽', size: 0.25, distance: 0, color: 0xFFA500, speed: 0, type: 'sun', emissive: 0xFFAA00, rotationSpeed: 0.001, 
              realDistance: '0', realSize: '1,392,700km', period: '-', 
              feature: '太陽系の中心に位置する恒星で、水素とヘリウムの核融合により莫大なエネルギーを放出している。表面温度は約5,778K、中心部は1,500万度に達する。太陽風と呼ばれる荷電粒子の流れを常に放出しており、これが地球のオーロラの原因となっている。',
              discovery: '古代', 
              fact: '太陽は1秒間に400万トンの質量をエネルギーに変換している。地球に届く太陽光は8分19秒前に太陽表面を出発したもの。太陽の核で作られた光子が表面に到達するまでには10万年から17万年かかる。太陽系の質量の99.86%を占めており、地球130万個分の体積を持つ。' },
            { name: '水星', size: 0.008, distance: 0.6, color: 0x8C7853, speed: 0.002, type: 'mercury', rotationSpeed: 0.0002,
              realDistance: '0.39AU', realSize: '4,879km', period: '88日', 
              feature: '太陽に最も近い惑星で、極端な温度差が特徴。大気がほとんど存在しないため、昼間は427°C、夜間は-173°Cと590°Cもの温度差が生じる。表面はクレーターだらけで月に似ているが、巨大なカロリス盆地という直径1,550kmの衝突クレーターが存在する。',
              discovery: '古代', 
              fact: '水星の1日（自転周期）は地球の59日に相当するが、1年（公転周期）は88日しかない。そのため水星では1日が1年の3分の2もの長さになる。また、水星は太陽系で最も軌道離心率が大きく、近日点と遠日点の距離差は2,400万kmもある。氷が存在する可能性のある極地のクレーターがある。' },
            { name: '金星', size: 0.012, distance: 0.85, color: 0xFFC649, speed: 0.0015, type: 'venus', rotationSpeed: -0.00005,
              realDistance: '0.72AU', realSize: '12,104km', period: '225日', 
              feature: '太陽系で最も高温の惑星で、厚い二酸化炭素の大気と硫酸の雲に覆われている。温室効果により表面温度は462°Cに達し、鉛も溶けるほど。大気圧は地球の90倍もある。興味深いことに、他の惑星とは逆方向に自転している。この逆回転により、金星では太陽が西から昇り東に沈む。',
              discovery: '古代', 
              fact: '金星の1日は地球の243日に相当し、これは金星の1年（225日）よりも長い。つまり金星では1日が1年より長い唯一の惑星。金星の雲は硫酸でできており、時速350kmという猛烈な風が吹いている。表面には約1,000個の火山があり、現在も活動している可能性がある。' },
            { name: '地球', size: 0.013, distance: 1.15, color: 0x6B93D6, speed: 0.001, type: 'earth', rotationSpeed: 0.004,
              realDistance: '1.00AU', realSize: '12,756km', period: '365日', 
              feature: '太陽系で唯一生命が存在することが確認されている惑星。表面の71%が海で覆われ、酸素と窒素からなる大気に包まれている。月という大きな衛星を持ち、これが潮汐を生み出し地軸を安定させている。プレートテクトニクスにより地表が常に変化し続けている。磁場により太陽風から保護されている。',
              discovery: '古代', 
              fact: '地球上の生命は約38億年前に誕生したとされ、最初は単細胞生物だった。地球の核は液体の鉄とニッケルでできており、その流動により磁場が生成される。1日は実際には23時間56分4秒で、これを恒星日という。地球の重力により時空が歪み、GPS衛星は相対性理論の補正が必要。' },
            { name: '火星', size: 0.009, distance: 1.45, color: 0xCD5C5C, speed: 0.0008, type: 'mars', rotationSpeed: 0.0038,
              realDistance: '1.52AU', realSize: '6,792km', period: '687日', 
              feature: '赤い惑星として知られ、酸化鉄（錆）により赤く見える。太陽系最大の火山オリンポス山（高さ21km）と最大の峡谷ヴァレス・マリネリスを持つ。極地には氷が存在し、過去には液体の水が流れていた証拠がある。薄い大気を持ち、巨大な砂嵐が惑星全体を覆うことがある。',
              discovery: '古代', 
              fact: '火星には太陽系最大の火山オリンポス山があり、これはエベレストの約3倍の高さ。火星の重力は地球の38%なので、地球で50kg の人は火星では19kgになる。火星の1日は24時間37分と地球とほぼ同じ。火星には「フォボス」と「デイモス」という2つの小さな衛星があり、どちらもジャガイモのような不規則な形をしている。' },
            { name: '木星', size: 0.11, distance: 2.0, color: 0xD2691E, speed: 0.0005, type: 'jupiter', rotationSpeed: 0.009,
              realDistance: '5.20AU', realSize: '142,984km', period: '12年', 
              feature: '太陽系最大の惑星で、地球の1,300倍以上の体積を持つガス巨星。大赤斑という地球2個分の巨大な高気圧の嵐が300年以上続いている。95個の衛星を持ち、その中には氷の下に海があるエウロパや、活火山があるイオなどがある。木星は太陽系の掃除機の役割を果たし、小惑星や彗星を引き寄せて地球を守っている。',
              discovery: '古代', 
              fact: '木星は太陽系の他のすべての惑星を合わせたよりも重い。木星の重力により、太陽系外縁部の小天体が内側に侵入するのを防いでいる。木星の衛星イオは太陽系で最も火山活動が活発で、硫黄の噴火により黄色く見える。木星は実は小さな恒星になりそこねた星で、もう少し重ければ第二の太陽になっていた。' },
            { name: '土星', size: 0.09, distance: 2.6, color: 0xB8860B, speed: 0.0004, type: 'saturn', rotationSpeed: 0.008,
              realDistance: '9.58AU', realSize: '120,536km', period: '29年', 
              feature: '美しいリングシステムで有名なガス巨星。リングは氷と岩石の破片でできており、数億個の粒子が軌道を描いている。146個の衛星を持ち、その中には濃い大気と液体メタンの湖があるタイタンや、氷の間欠泉を噴出するエンケラドスがある。密度が水より軽く、理論上は巨大なプールがあれば浮くことができる。',
              discovery: '古代', 
              fact: '土星のリングの厚さはわずか10メートルほどしかない。土星の衛星タイタンは太陽系で唯一濃い大気を持つ衛星で、メタンの雨が降り、メタンとエタンの湖がある。土星の北極には六角形の嵐があり、これは他の惑星では見られない現象。土星は太陽系で最も平たい惑星で、極径と赤道径の差が約12,000kmもある。' },
            { name: '天王星', size: 0.04, distance: 3.2, color: 0x4FD0E7, speed: 0.0003, type: 'uranus', rotationSpeed: 0.007,
              realDistance: '19.2AU', realSize: '51,118km', period: '84年', 
              feature: '自転軸が98度傾いており、横倒しに回転している氷の巨星。この特異な自転により、極地では42年間昼が続き、その後42年間夜が続く。メタン氷の雲により美しい青緑色に見える。非常に暗いリングシステムを持ち、27個の衛星がある。磁場が自転軸から59度も傾いている奇妙な惑星。',
              discovery: '1781年', 
              fact: '天王星は太陽系で最も寒い惑星で、最低温度は-224°Cに達する。木星や土星よりも遠いのに、なぜか海王星よりも寒い。天王星の発見により太陽系の大きさが一気に2倍になった。天王星の衛星はすべてシェイクスピアの作品の登場人物にちなんで名付けられている。天王星の1年は地球の84年に相当する。' },
            { name: '海王星', size: 0.04, distance: 3.8, color: 0x4169E1, speed: 0.0002, type: 'neptune', rotationSpeed: 0.006,
              realDistance: '30.1AU', realSize: '49,528km', period: '165年', 
              feature: '太陽系最も遠い惑星で、深い青色が美しい氷の巨星。太陽系で最も強い風が吹き、その速度は時速2,100kmに達する。これは音速の1.5倍という驚異的な速さ。大暗斑という巨大な嵐があったが、現在は消失している。16個の衛星を持ち、最大の衛星トリトンは逆行軌道を持つ珍しい衛星。',
              discovery: '1846年', 
              fact: '海王星は計算によって発見された唯一の惑星で、天王星の軌道の乱れから存在が予測された。海王星は2011年にようやく発見以来初めての公転を完了した。海王星の衛星トリトンは太陽系で最も寒い場所の一つで、-235°Cという極低温。海王星のコアの温度は約5,000°Cで、太陽の表面とほぼ同じ温度。' }
        ];

        // 惑星テクスチャ生成（大幅強化）
        function createPlanetTexture(type, size = 2048) { // 解像度を2倍に
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            switch(type) {
                case 'sun':
                    // 超高品質な太陽テクスチャ
                    const centerX = size / 2;
                    const centerY = size / 2;
                    const radius = size / 2;
                    
                    // ベースレイヤー：核から表面への現実的なグラデーション
                    const baseGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                    baseGradient.addColorStop(0, '#FFFFFF');    // 核心部：純白
                    baseGradient.addColorStop(0.05, '#FFFFEE'); // 内部：白
                    baseGradient.addColorStop(0.15, '#FFFFDD'); // 放射層
                    baseGradient.addColorStop(0.35, '#FFFF99'); // 対流層
                    baseGradient.addColorStop(0.55, '#FFEE66'); // 光球下層
                    baseGradient.addColorStop(0.75, '#FFDD44'); // 光球上層
                    baseGradient.addColorStop(0.90, '#FFCC22'); // 彩層
                    baseGradient.addColorStop(1, '#FFB800');    // 表面
                    ctx.fillStyle = baseGradient;
                    ctx.fillRect(0, 0, size, size);
                    
                    // 対流セル（スーパーグラニュレーション）
                    for(let i = 0; i < 80; i++) {
                        const cellX = Math.random() * size;
                        const cellY = Math.random() * size;
                        const cellRadius = 30 + Math.random() * 80;
                        const cellGradient = ctx.createRadialGradient(cellX, cellY, 0, cellX, cellY, cellRadius);
                        cellGradient.addColorStop(0, `rgba(255, ${240 + Math.random() * 15}, ${180 + Math.random() * 40}, 0.6)`);
                        cellGradient.addColorStop(0.7, `rgba(255, ${220 + Math.random() * 20}, ${160 + Math.random() * 40}, 0.3)`);
                        cellGradient.addColorStop(1, 'rgba(255, 200, 140, 0)');
                        ctx.fillStyle = cellGradient;
                        ctx.beginPath();
                        ctx.arc(cellX, cellY, cellRadius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // 太陽黒点
                    for(let i = 0; i < 8; i++) {
                        const spotX = centerX + (Math.random() - 0.5) * size * 0.6;
                        const spotY = centerY + (Math.random() - 0.5) * size * 0.6;
                        const spotSize = 8 + Math.random() * 25;
                        
                        // 黒点の影の部分
                        const umbraGradient = ctx.createRadialGradient(spotX, spotY, 0, spotX, spotY, spotSize * 0.4);
                        umbraGradient.addColorStop(0, 'rgba(20, 10, 5, 0.9)');
                        umbraGradient.addColorStop(1, 'rgba(50, 25, 15, 0.6)');
                        ctx.fillStyle = umbraGradient;
                        ctx.beginPath();
                        ctx.arc(spotX, spotY, spotSize * 0.4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // 黒点の半影
                        const penumbraGradient = ctx.createRadialGradient(spotX, spotY, spotSize * 0.4, spotX, spotY, spotSize);
                        penumbraGradient.addColorStop(0, 'rgba(80, 40, 25, 0.5)');
                        penumbraGradient.addColorStop(1, 'rgba(120, 80, 50, 0)');
                        ctx.fillStyle = penumbraGradient;
                        ctx.beginPath();
                        ctx.arc(spotX, spotY, spotSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // 高品質な粒状斑
                    for(let i = 0; i < 500; i++) {
                        const granuleX = Math.random() * size;
                        const granuleY = Math.random() * size;
                        const granuleSize = 1 + Math.random() * 4;
                        const brightness = 220 + Math.random() * 35;
                        
                        ctx.fillStyle = `rgba(255, ${brightness}, ${brightness * 0.7}, ${0.3 + Math.random() * 0.4})`;
                        ctx.beginPath();
                        ctx.arc(granuleX, granuleY, granuleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // 太陽フレア（プロミネンス）
                    for(let i = 0; i < 20; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = radius * (0.85 + Math.random() * 0.1);
                        const flareX = centerX + Math.cos(angle) * distance;
                        const flareY = centerY + Math.sin(angle) * distance;
                        const flareLength = 30 + Math.random() * 80;
                        const flareWidth = 2 + Math.random() * 6;
                        
                        // フレアの軌跡を描く
                        ctx.strokeStyle = `rgba(255, ${240 + Math.random() * 15}, ${150 + Math.random() * 50}, ${0.6 + Math.random() * 0.4})`;
                        ctx.lineWidth = flareWidth;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(flareX, flareY);
                        
                        // 曲線的なフレア
                        for(let j = 0; j < 5; j++) {
                            const t = j / 4;
                            const currentAngle = angle + (Math.random() - 0.5) * 0.3;
                            const currentDistance = distance + flareLength * t * (1 + Math.random() * 0.3);
                            const x = centerX + Math.cos(currentAngle) * currentDistance;
                            const y = centerY + Math.sin(currentAngle) * currentDistance;
                            ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                    }
                    
                    // 光球面のディテール
                    for(let i = 0; i < 100; i++) {
                        const detailX = Math.random() * size;
                        const detailY = Math.random() * size;
                        const detailSize = 3 + Math.random() * 12;
                        
                        const detailGradient = ctx.createRadialGradient(detailX, detailY, 0, detailX, detailY, detailSize);
                        detailGradient.addColorStop(0, `rgba(255, 255, ${200 + Math.random() * 55}, 0.4)`);
                        detailGradient.addColorStop(1, `rgba(255, 255, ${200 + Math.random() * 55}, 0)`);
                        ctx.fillStyle = detailGradient;
                        ctx.beginPath();
                        ctx.arc(detailX, detailY, detailSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                    
                case 'earth':
                    // 超高品質な地球テクスチャ
                    // 海洋の詳細なベース
                    const oceanGradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                    oceanGradient.addColorStop(0, '#4D79A4');    // 深海
                    oceanGradient.addColorStop(0.4, '#5B8BC7');  // 中間の海
                    oceanGradient.addColorStop(0.7, '#6BA6E8');  // 浅海
                    oceanGradient.addColorStop(0.85, '#7AB5F0'); // 近海
                    oceanGradient.addColorStop(1, '#4A7BA7');    // 海岸線
                    ctx.fillStyle = oceanGradient;
                    ctx.fillRect(0, 0, size, size);
                    
                    // 海流パターン
                    ctx.strokeStyle = 'rgba(100, 150, 200, 0.3)';
                    ctx.lineWidth = 3;
                    for(let i = 0; i < 15; i++) {
                        ctx.beginPath();
                        const startX = Math.random() * size;
                        const startY = Math.random() * size;
                        ctx.moveTo(startX, startY);
                        for(let j = 1; j <= 10; j++) {
                            const x = startX + j * 20 + Math.sin(j * 0.5) * 30;
                            const y = startY + (Math.random() - 0.5) * 10;
                            ctx.lineTo(x % size, y);
                        }
                        ctx.stroke();
                    }
                    
                    // 超詳細な大陸配置（実際の地球に近い形状）
                    const continents = [
                        // ユーラシア大陸（詳細分割）
                        {name: 'europe', x: size*0.45, y: size*0.3, w: 80, h: 60, rotation: 0},
                        {name: 'asia', x: size*0.6, y: size*0.35, w: 200, h: 120, rotation: 0.1},
                        {name: 'siberia', x: size*0.55, y: size*0.25, w: 180, h: 80, rotation: 0},
                        {name: 'india', x: size*0.6, y: size*0.48, w: 50, h: 70, rotation: -0.2},
                        {name: 'china', x: size*0.65, y: size*0.35, w: 90, h: 80, rotation: 0},
                        
                        // アフリカ大陸（詳細）
                        {name: 'africa', x: size*0.48, y: size*0.55, w: 85, h: 160, rotation: 0.05},
                        {name: 'madagascar', x: size*0.55, y: size*0.65, w: 12, h: 30, rotation: 0},
                        
                        // 北米大陸
                        {name: 'north_america', x: size*0.2, y: size*0.35, w: 130, h: 170, rotation: 0.1},
                        {name: 'greenland', x: size*0.35, y: size*0.15, w: 50, h: 80, rotation: 0.3},
                        
                        // 南米大陸
                        {name: 'south_america', x: size*0.3, y: size*0.7, w: 70, h: 140, rotation: -0.1},
                        
                        // オセアニア
                        {name: 'australia', x: size*0.78, y: size*0.7, w: 80, h: 50, rotation: 0},
                        {name: 'new_zealand', x: size*0.85, y: size*0.78, w: 15, h: 25, rotation: 0},
                        
                        // 諸島
                        {name: 'japan', x: size*0.72, y: size*0.38, w: 25, h: 35, rotation: 0.2},
                        {name: 'uk', x: size*0.42, y: size*0.28, w: 20, h: 25, rotation: 0},
                        {name: 'indonesia', x: size*0.72, y: size*0.55, w: 60, h: 20, rotation: 0}
                    ];
                    
                    continents.forEach(continent => {
                        ctx.save();
                        ctx.translate(continent.x, continent.y);
                        ctx.rotate(continent.rotation);
                        
                        // 大陸棚（浅海）
                        ctx.fillStyle = 'rgba(120, 180, 220, 0.6)';
                        ctx.beginPath();
                        ctx.ellipse(0, 0, continent.w/2 * 1.2, continent.h/2 * 1.2, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // 地形による色分け
                        let terrainColors = {
                            desert: '#D2B48C',
                            forest: '#228B22',
                            mountain: '#8B7355',
                            plain: '#9ACD32',
                            tundra: '#B0C4DE'
                        };
                        
                        // 基本地形
                        ctx.fillStyle = terrainColors.plain;
                        if(['africa', 'australia'].includes(continent.name)) ctx.fillStyle = terrainColors.desert;
                        if(['siberia', 'greenland'].includes(continent.name)) ctx.fillStyle = terrainColors.tundra;
                        if(['south_america', 'asia'].includes(continent.name)) ctx.fillStyle = terrainColors.forest;
                        
                        ctx.beginPath();
                        ctx.ellipse(0, 0, continent.w/2, continent.h/2, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // 山脈システム
                        ctx.fillStyle = terrainColors.mountain;
                        const mountainRanges = Math.floor(continent.w * continent.h / 3000) + 1;
                        for(let i = 0; i < mountainRanges; i++) {
                            const mx = (Math.random() - 0.5) * continent.w * 0.7;
                            const my = (Math.random() - 0.5) * continent.h * 0.7;
                            const mw = 10 + Math.random() * 20;
                            const mh = 5 + Math.random() * 10;
                            ctx.beginPath();
                            ctx.ellipse(mx, my, mw, mh, Math.random() * Math.PI, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // 河川システム
                        ctx.strokeStyle = 'rgba(100, 150, 255, 0.8)';
                        ctx.lineWidth = 2;
                        const riverCount = Math.floor(continent.w * continent.h / 5000) + 1;
                        for(let i = 0; i < riverCount; i++) {
                            ctx.beginPath();
                            const startX = (Math.random() - 0.5) * continent.w * 0.6;
                            const startY = (Math.random() - 0.5) * continent.h * 0.6;
                            ctx.moveTo(startX, startY);
                            
                            for(let j = 1; j <= 8; j++) {
                                const x = startX + j * 8 + (Math.random() - 0.5) * 10;
                                const y = startY + j * 5 + (Math.random() - 0.5) * 10;
                                ctx.lineTo(x, y);
                            }
                            ctx.stroke();
                        }
                        
                        // 都市の光（主要都市）
                        if(!['greenland', 'madagascar', 'antarctica'].includes(continent.name)) {
                            ctx.fillStyle = 'rgba(255, 255, 150, 0.8)';
                            const cityCount = Math.floor(continent.w * continent.h / 8000) + 1;
                            for(let i = 0; i < cityCount; i++) {
                                const cityX = (Math.random() - 0.5) * continent.w * 0.6;
                                const cityY = (Math.random() - 0.5) * continent.h * 0.6;
                                ctx.beginPath();
                                ctx.arc(cityX, cityY, 1 + Math.random() * 2, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                        
                        ctx.restore();
                    });
                    
                    // 極地の氷（より詳細）
                    // 北極
                    const northIceGradient = ctx.createRadialGradient(size/2, 30, 0, size/2, 30, 60);
                    northIceGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    northIceGradient.addColorStop(0.6, 'rgba(240, 248, 255, 0.9)');
                    northIceGradient.addColorStop(1, 'rgba(200, 220, 255, 0.3)');
                    ctx.fillStyle = northIceGradient;
                    ctx.beginPath();
                    ctx.arc(size/2, 30, 60, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 南極
                    const southIceGradient = ctx.createRadialGradient(size/2, size-30, 0, size/2, size-30, 80);
                    southIceGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    southIceGradient.addColorStop(0.5, 'rgba(240, 248, 255, 0.95)');
                    southIceGradient.addColorStop(1, 'rgba(200, 220, 255, 0.4)');
                    ctx.fillStyle = southIceGradient;
                    ctx.beginPath();
                    ctx.arc(size/2, size-30, 80, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 高品質な雲システム
                    ctx.globalAlpha = 0.7;
                    for(let i = 0; i < 60; i++) {
                        const cloudX = Math.random() * size;
                        const cloudY = Math.random() * size;
                        const cloudSize = 15 + Math.random() * 50;
                        const cloudType = Math.random();
                        
                        let cloudColor;
                        if(cloudType < 0.6) {
                            // 普通の雲
                            cloudColor = 'rgba(255, 255, 255, 0.8)';
                        } else if(cloudType < 0.8) {
                            // 薄い雲
                            cloudColor = 'rgba(250, 250, 255, 0.5)';
                        } else {
                            // 厚い雲
                            cloudColor = 'rgba(240, 240, 240, 0.9)';
                        }
                        
                        const cloudGradient = ctx.createRadialGradient(cloudX, cloudY, 0, cloudX, cloudY, cloudSize);
                        cloudGradient.addColorStop(0, cloudColor);
                        cloudGradient.addColorStop(0.7, cloudColor.replace(/[\d.]+\)$/g, '0.3)'));
                        cloudGradient.addColorStop(1, cloudColor.replace(/[\d.]+\)$/g, '0)'));
                        
                        ctx.fillStyle = cloudGradient;
                        ctx.beginPath();
                        ctx.arc(cloudX, cloudY, cloudSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                    
                    // 大気の散乱効果
                    const earthAtmosphereGradient = ctx.createRadialGradient(size/2, size/2, size/2 * 0.8, size/2, size/2, size/2);
                    earthAtmosphereGradient.addColorStop(0, 'rgba(135, 206, 250, 0)');
                    earthAtmosphereGradient.addColorStop(1, 'rgba(100, 149, 237, 0.3)');
                    ctx.fillStyle = earthAtmosphereGradient;
                    ctx.fillRect(0, 0, size, size);
                    break;
                    
                case 'mars':
                    // 超高品質な火星テクスチャ
                    // 地形による色分けベース
                    const marsBase = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                    marsBase.addColorStop(0, '#D2691E');    // 中央部
                    marsBase.addColorStop(0.3, '#CD853F');  // 中間地帯
                    marsBase.addColorStop(0.6, '#B8860B');  // 外縁部
                    marsBase.addColorStop(0.8, '#8B4513');  // 縁
                    marsBase.addColorStop(1, '#654321');    // 最外縁
                    ctx.fillStyle = marsBase;
                    ctx.fillRect(0, 0, size, size);
                    
                    // 地形の詳細レイヤー
                    // 古代の衝突クレーター（多数）
                    for(let i = 0; i < 50; i++) {
                        const craterX = Math.random() * size;
                        const craterY = Math.random() * size;
                        const craterSize = 3 + Math.random() * 25;
                        
                        // クレーターの縁（隆起）
                        ctx.fillStyle = `rgba(${160 + Math.random() * 40}, ${110 + Math.random() * 30}, ${70 + Math.random() * 20}, 0.6)`;
                        ctx.beginPath();
                        ctx.arc(craterX, craterY, craterSize, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // クレーターの底（くぼみ）
                        ctx.fillStyle = `rgba(${100 + Math.random() * 30}, ${60 + Math.random() * 25}, ${40 + Math.random() * 15}, 0.8)`;
                        ctx.beginPath();
                        ctx.arc(craterX, craterY, craterSize * 0.6, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // 巨大なオリンポス山（太陽系最大の火山）
                    const olympusX = size * 0.25;
                    const olympusY = size * 0.35;
                    const olympusSize = 35;
                    
                    // オリンポス山の影とハイライト
                    ctx.fillStyle = 'rgba(80, 50, 30, 0.7)';
                    ctx.beginPath();
                    ctx.arc(olympusX + 2, olympusY + 2, olympusSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // オリンポス山のメイン
                    const olympusGradient = ctx.createRadialGradient(olympusX, olympusY, 0, olympusX, olympusY, olympusSize);
                    olympusGradient.addColorStop(0, '#D2B48C');   // 頂上（明るい）
                    olympusGradient.addColorStop(0.3, '#CD853F'); // 中腹
                    olympusGradient.addColorStop(0.6, '#A0522D'); // 下部
                    olympusGradient.addColorStop(1, '#8B4513');   // 麓
                    ctx.fillStyle = olympusGradient;
                    ctx.beginPath();
                    ctx.arc(olympusX, olympusY, olympusSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // オリンポス山のカルデラ
                    ctx.fillStyle = 'rgba(100, 60, 40, 0.8)';
                    ctx.beginPath();
                    ctx.arc(olympusX, olympusY, olympusSize * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 他の主要火山
                    const volcanoes = [
                        {name: 'Arsia Mons', x: size*0.28, y: size*0.55, size: 18},
                        {name: 'Pavonis Mons', x: size*0.25, y: size*0.5, size: 16},
                        {name: 'Ascraeus Mons', x: size*0.23, y: size*0.45, size: 17}
                    ];
                    
                    volcanoes.forEach(volcano => {
                        const volcGradient = ctx.createRadialGradient(volcano.x, volcano.y, 0, volcano.x, volcano.y, volcano.size);
                        volcGradient.addColorStop(0, '#CD853F');
                        volcGradient.addColorStop(0.7, '#A0522D');
                        volcGradient.addColorStop(1, '#8B4513');
                        ctx.fillStyle = volcGradient;
                        ctx.beginPath();
                        ctx.arc(volcano.x, volcano.y, volcano.size, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // ヴァレス・マリネリス（巨大峡谷）
                    ctx.strokeStyle = 'rgba(120, 80, 50, 0.8)';
                    ctx.lineWidth = 8;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(size * 0.1, size * 0.5);
                    ctx.quadraticCurveTo(size * 0.4, size * 0.45, size * 0.7, size * 0.5);
                    ctx.stroke();
                    
                    // 峡谷の支流
                    ctx.lineWidth = 4;
                    for(let i = 0; i < 8; i++) {
                        const branchX = size * (0.2 + i * 0.08);
                        const branchY = size * (0.48 + (Math.random() - 0.5) * 0.1);
                        ctx.beginPath();
                        ctx.moveTo(branchX, branchY);
                        ctx.lineTo(branchX + (Math.random() - 0.5) * 40, branchY + (Math.random() - 0.5) * 30);
                        ctx.stroke();
                    }
                    
                    // 古代の水の痕跡（乾いた河床）
                    ctx.strokeStyle = 'rgba(150, 100, 70, 0.5)';
                    ctx.lineWidth = 2;
                    for(let i = 0; i < 20; i++) {
                        ctx.beginPath();
                        const startX = Math.random() * size;
                        const startY = Math.random() * size;
                        ctx.moveTo(startX, startY);
                        
                        for(let j = 1; j <= 10; j++) {
                            const x = startX + j * 8 + (Math.random() - 0.5) * 15;
                            const y = startY + j * 5 + (Math.random() - 0.5) * 10;
                            ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                    }
                    
                    // 砂嵐の痕跡
                    for(let i = 0; i < 30; i++) {
                        const dustX = Math.random() * size;
                        const dustY = Math.random() * size;
                        const dustSize = 5 + Math.random() * 20;
                        
                        const dustGradient = ctx.createRadialGradient(dustX, dustY, 0, dustX, dustY, dustSize);
                        dustGradient.addColorStop(0, `rgba(${200 + Math.random() * 35}, ${140 + Math.random() * 30}, ${90 + Math.random() * 20}, 0.3)`);
                        dustGradient.addColorStop(1, `rgba(${200 + Math.random() * 35}, ${140 + Math.random() * 30}, ${90 + Math.random() * 20}, 0)`);
                        
                        ctx.fillStyle = dustGradient;
                        ctx.beginPath();
                        ctx.arc(dustX, dustY, dustSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // 極冠（季節により変化する氷）
                    // 北極冠
                    const northCapGradient = ctx.createRadialGradient(size/2, 15, 0, size/2, 15, 50);
                    northCapGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');     // 中央（純粋な氷）
                    northCapGradient.addColorStop(0.4, 'rgba(240, 248, 255, 0.9)'); // 中間（氷と塵の混合）
                    northCapGradient.addColorStop(0.7, 'rgba(220, 230, 240, 0.7)'); // 外縁（薄い氷）
                    northCapGradient.addColorStop(1, 'rgba(200, 210, 220, 0.3)');   // 最外縁（霜）
                    ctx.fillStyle = northCapGradient;
                    ctx.beginPath();
                    ctx.arc(size/2, 15, 50, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 南極冠（より小さく、不規則）
                    const southCapGradient = ctx.createRadialGradient(size/2, size-15, 0, size/2, size-15, 40);
                    southCapGradient.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
                    southCapGradient.addColorStop(0.5, 'rgba(240, 248, 255, 0.8)');
                    southCapGradient.addColorStop(1, 'rgba(220, 230, 240, 0.4)');
                    ctx.fillStyle = southCapGradient;
                    ctx.beginPath();
                    ctx.arc(size/2, size-15, 40, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 極冠の層状構造
                    ctx.strokeStyle = 'rgba(200, 220, 240, 0.6)';
                    ctx.lineWidth = 1;
                    for(let i = 1; i <= 5; i++) {
                        ctx.beginPath();
                        ctx.arc(size/2, 15, 10 * i, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.arc(size/2, size-15, 8 * i, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    // 大気の薄いヘイズ効果
                    const marsAtmosphereGradient = ctx.createRadialGradient(size/2, size/2, size/2 * 0.7, size/2, size/2, size/2);
                    marsAtmosphereGradient.addColorStop(0, 'rgba(255, 200, 150, 0)');
                    marsAtmosphereGradient.addColorStop(1, 'rgba(200, 120, 80, 0.2)');
                    ctx.fillStyle = marsAtmosphereGradient;
                    ctx.fillRect(0, 0, size, size);
                    break;
                    
                case 'jupiter':
                    // 超高品質な木星テクスチャ
                    // 大気層の詳細なベース
                    const jupiterBase = ctx.createLinearGradient(0, 0, 0, size);
                    jupiterBase.addColorStop(0, '#FFEEDD');   // 極域（明るいクリーム）
                    jupiterBase.addColorStop(0.1, '#F4E4BC'); // 高緯度帯
                    jupiterBase.addColorStop(0.2, '#E6B87D'); // 温帯
                    jupiterBase.addColorStop(0.3, '#D2691E'); // 亜熱帯
                    jupiterBase.addColorStop(0.4, '#CD853F'); // 熱帯北
                    jupiterBase.addColorStop(0.5, '#B8860B'); // 赤道帯
                    jupiterBase.addColorStop(0.6, '#A0522D'); // 熱帯南
                    jupiterBase.addColorStop(0.7, '#8B4513'); // 亜熱帯南
                    jupiterBase.addColorStop(0.8, '#654321'); // 温帯南
                    jupiterBase.addColorStop(0.9, '#4A2C17'); // 高緯度南
                    jupiterBase.addColorStop(1, '#3A1F10');   // 南極域
                    ctx.fillStyle = jupiterBase;
                    ctx.fillRect(0, 0, size, size);
                    
                    // 超詳細な縞模様システム
                    for(let i = 0; i < 60; i++) {
                        const y = (i / 60) * size;
                        const beltHeight = 6 + Math.random() * 30;
                        const opacity = 0.15 + Math.random() * 0.6;
                        const turbulence = Math.sin(i * 0.4) * 0.3;
                        
                        // 帯の種類による色分け
                        let beltColor;
                        const beltType = i % 4;
                        if(beltType === 0) {
                            // 明るい帯（Zone）
                            beltColor = `rgba(${240 + Math.random() * 15}, ${200 + Math.random() * 30}, ${140 + Math.random() * 20}, ${opacity})`;
                        } else if(beltType === 1) {
                            // 暗い帯（Belt）
                            beltColor = `rgba(${160 + Math.random() * 30}, ${110 + Math.random() * 25}, ${70 + Math.random() * 20}, ${opacity})`;
                        } else if(beltType === 2) {
                            // 中間の帯
                            beltColor = `rgba(${190 + Math.random() * 25}, ${140 + Math.random() * 25}, ${90 + Math.random() * 20}, ${opacity})`;
                        } else {
                            // 特殊な帯（赤みがかった）
                            beltColor = `rgba(${200 + Math.random() * 30}, ${130 + Math.random() * 30}, ${80 + Math.random() * 25}, ${opacity})`;
                        }
                        
                        ctx.fillStyle = beltColor;
                        
                        // 複雑な波打つ縞模様
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        for(let x = 0; x <= size; x += 8) {
                            const primaryWave = Math.sin(x * 0.025 + i * 0.5) * (4 + turbulence * 8);
                            const secondaryWave = Math.sin(x * 0.08 + i * 0.3) * (1 + turbulence * 3);
                            const waveY = y + primaryWave + secondaryWave;
                            ctx.lineTo(x, waveY);
                        }
                        for(let x = size; x >= 0; x -= 8) {
                            const primaryWave = Math.sin(x * 0.02 + i * 0.5 + 1) * (3 + turbulence * 6);
                            const secondaryWave = Math.sin(x * 0.06 + i * 0.3 + 1) * (1.5 + turbulence * 2);
                            const waveY = y + beltHeight + primaryWave + secondaryWave;
                            ctx.lineTo(x, waveY);
                        }
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    // 大赤斑（超詳細）
                    const grsX = size * 0.72;
                    const grsY = size * 0.42;
                    const grsWidth = 80;
                    const grsHeight = 50;
                    
                    // 大赤斑の周囲の乱流
                    for(let i = 0; i < 12; i++) {
                        const angle = (i / 12) * Math.PI * 2;
                        const turbX = grsX + Math.cos(angle) * (grsWidth/2 + 20 + Math.random() * 30);
                        const turbY = grsY + Math.sin(angle) * (grsHeight/2 + 15 + Math.random() * 20);
                        const turbSize = 8 + Math.random() * 15;
                        
                        ctx.fillStyle = `rgba(${180 + Math.random() * 40}, ${100 + Math.random() * 40}, ${60 + Math.random() * 30}, 0.4)`;
                        ctx.beginPath();
                        ctx.arc(turbX, turbY, turbSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // 大赤斑の影とハイライト
                    ctx.fillStyle = 'rgba(80, 20, 10, 0.5)';
                    ctx.beginPath();
                    ctx.ellipse(grsX + 3, grsY + 3, grsWidth/2, grsHeight/2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 大赤斑のメイン（複数層）
                    const grsLayers = [
                        {color: '#DD5555', size: 1.0},
                        {color: '#CC3333', size: 0.8},
                        {color: '#BB2222', size: 0.6},
                        {color: '#AA1111', size: 0.4},
                        {color: '#990000', size: 0.2}
                    ];
                    
                    grsLayers.forEach(layer => {
                        const layerGradient = ctx.createRadialGradient(grsX, grsY, 0, grsX, grsY, (grsWidth/2) * layer.size);
                        layerGradient.addColorStop(0, layer.color);
                        layerGradient.addColorStop(0.7, layer.color + '99');
                        layerGradient.addColorStop(1, layer.color + '00');
                        ctx.fillStyle = layerGradient;
                        ctx.beginPath();
                        ctx.ellipse(grsX, grsY, (grsWidth/2) * layer.size, (grsHeight/2) * layer.size, 0, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // 大赤斑の詳細な渦巻き構造
                    ctx.strokeStyle = 'rgba(180, 80, 80, 0.7)';
                    ctx.lineWidth = 1.5;
                    for(let i = 0; i < 5; i++) {
                        ctx.beginPath();
                        const spiralRadius = 10 + i * 12;
                        for(let angle = 0; angle < Math.PI * 6; angle += 0.08) {
                            const currentRadius = spiralRadius * (1 - angle / (Math.PI * 6)) * 0.9;
                            const x = grsX + Math.cos(angle + i * 0.5) * currentRadius;
                            const y = grsY + Math.sin(angle + i * 0.5) * currentRadius * 0.6;
                            if(angle === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                    }
                    
                    // 小さな嵐システム（複数のサイズ）
                    for(let i = 0; i < 25; i++) {
                        const stormX = Math.random() * size;
                        const stormY = Math.random() * size;
                        const stormSize = 4 + Math.random() * 20;
                        const stormIntensity = Math.random();
                        
                        let stormColor;
                        if(stormIntensity > 0.8) {
                            // 強い嵐（白色）
                            stormColor = `rgba(${240 + Math.random() * 15}, ${220 + Math.random() * 20}, ${180 + Math.random() * 30}, 0.7)`;
                        } else if(stormIntensity > 0.5) {
                            // 中程度の嵐（茶色）
                            stormColor = `rgba(${160 + Math.random() * 40}, ${120 + Math.random() * 30}, ${80 + Math.random() * 25}, 0.5)`;
                        } else {
                            // 弱い嵐（暗い）
                            stormColor = `rgba(${120 + Math.random() * 30}, ${90 + Math.random() * 25}, ${60 + Math.random() * 20}, 0.3)`;
                        }
                        
                        const stormGradient = ctx.createRadialGradient(stormX, stormY, 0, stormX, stormY, stormSize);
                        stormGradient.addColorStop(0, stormColor);
                        stormGradient.addColorStop(0.6, stormColor.replace(/[\d.]+\)$/g, '0.2)'));
                        stormGradient.addColorStop(1, stormColor.replace(/[\d.]+\)$/g, '0)'));
                        
                        ctx.fillStyle = stormGradient;
                        ctx.beginPath();
                        ctx.arc(stormX, stormY, stormSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // 大気の乱流パターン
                    ctx.strokeStyle = 'rgba(200, 150, 100, 0.2)';
                    ctx.lineWidth = 1;
                    for(let i = 0; i < 40; i++) {
                        ctx.beginPath();
                        const startX = Math.random() * size;
                        const startY = Math.random() * size;
                        ctx.moveTo(startX, startY);
                        
                        for(let j = 1; j <= 15; j++) {
                            const x = startX + j * 10 + Math.sin(j * 0.3) * 15;
                            const y = startY + (Math.random() - 0.5) * 8;
                            ctx.lineTo(x % size, y);
                        }
                        ctx.stroke();
                    }
                    break;
                    
                case 'mercury':
                    // 水星：極端な温度差を持つクレーターだらけの世界
                    const mercuryBase = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                    mercuryBase.addColorStop(0, '#C0C0C0'); // 明るい中央
                    mercuryBase.addColorStop(0.5, '#8C7853'); // 茶色がかった
                    mercuryBase.addColorStop(1, '#696969'); // 暗い縁
                    ctx.fillStyle = mercuryBase;
                    ctx.fillRect(0, 0, size, size);
                    
                    // カロリス盆地（巨大衝突クレーター）
                    const calorisX = size * 0.6;
                    const calorisY = size * 0.4;
                    const calorisSize = 60;
                    
                    ctx.fillStyle = 'rgba(120, 120, 120, 0.7)';
                    ctx.beginPath();
                    ctx.arc(calorisX, calorisY, calorisSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'rgba(80, 80, 80, 0.8)';
                    ctx.beginPath();
                    ctx.arc(calorisX, calorisY, calorisSize * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 多数の小クレーター
                    for(let i = 0; i < 80; i++) {
                        const craterX = Math.random() * size;
                        const craterY = Math.random() * size;
                        const craterSize = 2 + Math.random() * 15;
                        
                        ctx.fillStyle = `rgba(${100 + Math.random() * 50}, ${100 + Math.random() * 50}, ${100 + Math.random() * 50}, 0.6)`;
                        ctx.beginPath();
                        ctx.arc(craterX, craterY, craterSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                    
                case 'venus':
                    // 金星：厚い雲に覆われた灼熱の世界
                    const venusBase = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                    venusBase.addColorStop(0, '#FFF8DC'); // 明るいクリーム
                    venusBase.addColorStop(0.4, '#F5DEB3'); // ベージュ
                    venusBase.addColorStop(0.7, '#DEB887'); // より濃いベージュ
                    venusBase.addColorStop(1, '#D2B48C'); // 茶色がかったベージュ
                    ctx.fillStyle = venusBase;
                    ctx.fillRect(0, 0, size, size);
                    
                    // 硫酸の雲層
                    for(let i = 0; i < 100; i++) {
                        const cloudX = Math.random() * size;
                        const cloudY = Math.random() * size;
                        const cloudSize = 10 + Math.random() * 40;
                        
                        const venusCloudGradient = ctx.createRadialGradient(cloudX, cloudY, 0, cloudX, cloudY, cloudSize);
                        venusCloudGradient.addColorStop(0, `rgba(${250 + Math.random() * 5}, ${240 + Math.random() * 10}, ${200 + Math.random() * 20}, 0.6)`);
                        venusCloudGradient.addColorStop(1, `rgba(${250 + Math.random() * 5}, ${240 + Math.random() * 10}, ${200 + Math.random() * 20}, 0)`);
                        
                        ctx.fillStyle = venusCloudGradient;
                        ctx.beginPath();
                        ctx.arc(cloudX, cloudY, cloudSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // 大気の渦巻きパターン
                    for(let i = 0; i < 20; i++) {
                        ctx.strokeStyle = `rgba(${230 + Math.random() * 20}, ${220 + Math.random() * 20}, ${180 + Math.random() * 30}, 0.4)`;
                        ctx.lineWidth = 2 + Math.random() * 3;
                        ctx.beginPath();
                        
                        const centerX = Math.random() * size;
                        const centerY = Math.random() * size;
                        for(let angle = 0; angle < Math.PI * 4; angle += 0.2) {
                            const radius = angle * 3;
                            const x = centerX + Math.cos(angle) * radius;
                            const y = centerY + Math.sin(angle) * radius;
                            if(angle === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                    }
                    break;
                    
                case 'saturn':
                    // 土星：美しいリングと縞模様
                    const saturnBase = ctx.createLinearGradient(0, 0, 0, size);
                    saturnBase.addColorStop(0, '#F5DEB3');   // 極域
                    saturnBase.addColorStop(0.2, '#DEB887'); // 高緯度
                    saturnBase.addColorStop(0.4, '#D2B48C'); // 中緯度
                    saturnBase.addColorStop(0.6, '#BC9A6A'); // 赤道域
                    saturnBase.addColorStop(0.8, '#A0845C'); // 中緯度南
                    saturnBase.addColorStop(1, '#8B7355');   // 極域南
                    ctx.fillStyle = saturnBase;
                    ctx.fillRect(0, 0, size, size);
                    
                    // 土星の縞模様（木星より穏やか）
                    for(let i = 0; i < 30; i++) {
                        const y = (i / 30) * size;
                        const beltHeight = 10 + Math.random() * 20;
                        const opacity = 0.1 + Math.random() * 0.3;
                        
                        ctx.fillStyle = `rgba(${180 + Math.random() * 40}, ${150 + Math.random() * 30}, ${120 + Math.random() * 25}, ${opacity})`;
                        ctx.fillRect(0, y, size, beltHeight);
                    }
                    
                    // 六角形の嵐（北極）
                    const hexCenterX = size/2;
                    const hexCenterY = size * 0.1;
                    const hexRadius = 20;
                    
                    ctx.strokeStyle = 'rgba(200, 180, 150, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    for(let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        const x = hexCenterX + Math.cos(angle) * hexRadius;
                        const y = hexCenterY + Math.sin(angle) * hexRadius;
                        if(i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    break;
                    
                case 'uranus':
                    // 天王星：横倒しの氷の巨星
                    const uranusBase = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                    uranusBase.addColorStop(0, '#87CEEB');   // 明るい青
                    uranusBase.addColorStop(0.4, '#4FD0E7'); // 青緑
                    uranusBase.addColorStop(0.7, '#00CED1'); // ターコイズ
                    uranusBase.addColorStop(1, '#008B8B');   // 濃いターコイズ
                    ctx.fillStyle = uranusBase;
                    ctx.fillRect(0, 0, size, size);
                    
                    // メタン氷の雲
                    for(let i = 0; i < 40; i++) {
                        const cloudX = Math.random() * size;
                        const cloudY = Math.random() * size;
                        const cloudSize = 8 + Math.random() * 25;
                        
                        ctx.fillStyle = `rgba(${150 + Math.random() * 30}, ${200 + Math.random() * 30}, ${220 + Math.random() * 35}, 0.4)`;
                        ctx.beginPath();
                        ctx.arc(cloudX, cloudY, cloudSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                    
                case 'neptune':
                    // 海王星：深い青の嵐の惑星
                    const neptuneBase = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                    neptuneBase.addColorStop(0, '#6495ED');  // 明るい青
                    neptuneBase.addColorStop(0.4, '#4169E1'); // ロイヤルブルー
                    neptuneBase.addColorStop(0.7, '#0000CD'); // 中程度の青
                    neptuneBase.addColorStop(1, '#000080');   // 濃紺
                    ctx.fillStyle = neptuneBase;
                    ctx.fillRect(0, 0, size, size);
                    
                    // 大暗斑（かつて存在した巨大嵐）
                    const darkSpotX = size * 0.3;
                    const darkSpotY = size * 0.4;
                    const darkSpotW = 40;
                    const darkSpotH = 25;
                    
                    ctx.fillStyle = 'rgba(0, 0, 100, 0.7)';
                    ctx.beginPath();
                    ctx.ellipse(darkSpotX, darkSpotY, darkSpotW, darkSpotH, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 高速風の痕跡
                    for(let i = 0; i < 15; i++) {
                        ctx.strokeStyle = `rgba(${100 + Math.random() * 50}, ${150 + Math.random() * 50}, ${200 + Math.random() * 55}, 0.5)`;
                        ctx.lineWidth = 2 + Math.random() * 3;
                        ctx.beginPath();
                        
                        const startX = Math.random() * size;
                        const startY = Math.random() * size;
                        ctx.moveTo(startX, startY);
                        
                        for(let j = 1; j <= 8; j++) {
                            const x = startX + j * 15;
                            const y = startY + Math.sin(j * 0.5) * 10;
                            ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                    }
                    break;
                    
                default:
                    // その他の天体（小惑星など）
                    const defaultGradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                    defaultGradient.addColorStop(0, '#AAAAAA');
                    defaultGradient.addColorStop(1, '#666666');
                    ctx.fillStyle = defaultGradient;
                    ctx.fillRect(0, 0, size, size);
            }
            
            return new THREE.CanvasTexture(canvas);
        }

        // 星空作成
        function createStarField() {
            const starGeometry = new THREE.BufferGeometry();
            const starPositions = [];
            const starSizes = [];
            
            for (let i = 0; i < 5000; i++) {
                starPositions.push(
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200
                );
                starSizes.push(Math.random() * 2 + 0.5);
            }
            
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));
            
            const starMaterial = new THREE.PointsMaterial({
                color: 0xFFFFFF,
                size: 0.05,
                transparent: true,
                opacity: 0.8
            });
            
            return new THREE.Points(starGeometry, starMaterial);
        }

        // 宇宙空間の星空作成（大幅強化）
        function createSpaceStarField() {
            const starGeometry = new THREE.BufferGeometry();
            const starPositions = [];
            const starColors = [];
            const starSizes = [];
            
            for (let i = 0; i < 12000; i++) { // 25000から12000に軽量化
                // より広範囲に星を配置（天の川銀河を模擬）
                let radius, x, y, z;
                
                if (i < 9000) { // 20000から9000に調整
                    // 天の川銀河の円盤部分
                    const diskRadius = 100 + Math.random() * 200;
                    const diskAngle = Math.random() * Math.PI * 2;
                    const diskHeight = (Math.random() - 0.5) * 20;
                    
                    x = diskRadius * Math.cos(diskAngle);
                    y = diskHeight;
                    z = diskRadius * Math.sin(diskAngle);
                } else {
                    // ハロー部分（球状分布）
                    radius = 150 + Math.random() * 100;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    x = radius * Math.sin(phi) * Math.cos(theta);
                    y = radius * Math.sin(phi) * Math.sin(theta);
                    z = radius * Math.cos(phi);
                }
                
                starPositions.push(x, y, z);
                
                // より現実的な恒星の色分布
                const colorType = Math.random();
                if (colorType < 0.1) {
                    // O型星（青色、非常に稀）
                    starColors.push(0.6, 0.8, 1);
                    starSizes.push(Math.random() * 4 + 2);
                } else if (colorType < 0.2) {
                    // B型星（青白色）
                    starColors.push(0.8, 0.9, 1);
                    starSizes.push(Math.random() * 3 + 1.5);
                } else if (colorType < 0.3) {
                    // A型星（白色）
                    starColors.push(1, 1, 1);
                    starSizes.push(Math.random() * 2.5 + 1);
                } else if (colorType < 0.4) {
                    // F型星（黄白色）
                    starColors.push(1, 1, 0.9);
                    starSizes.push(Math.random() * 2 + 0.8);
                } else if (colorType < 0.5) {
                    // G型星（黄色、太陽型）
                    starColors.push(1, 0.95, 0.8);
                    starSizes.push(Math.random() * 1.8 + 0.7);
                } else if (colorType < 0.7) {
                    // K型星（オレンジ色）
                    starColors.push(1, 0.8, 0.6);
                    starSizes.push(Math.random() * 1.5 + 0.6);
                } else {
                    // M型星（赤色矮星、最も多い）
                    starColors.push(1, 0.6, 0.4);
                    starSizes.push(Math.random() * 1 + 0.3);
                }
            }
            
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
            starGeometry.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));
            
            const starMaterial = new THREE.PointsMaterial({
                vertexColors: true,
                size: 0.06,
                transparent: true,
                opacity: 0, // 初期値を0に設定
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending
            });
            
            return new THREE.Points(starGeometry, starMaterial);
        }

        // 背景フェード用の球体を作成
        function createBackgroundSphere() {
            const geometry = new THREE.SphereGeometry(300, 32, 16);
            const material = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0,
                side: THREE.BackSide // 内側から見えるように
            });
            
            return new THREE.Mesh(geometry, material);
        }

        // 小惑星帯を作成（火星と木星の間）
        function createAsteroidBelt() {
            const asteroidGroup = new THREE.Group();
            const asteroidCount = 80; // 200から80に軽量化
            const innerRadius = 1.7;  // 火星軌道より外側
            const outerRadius = 1.9;  // 木星軌道より内側
            
            for (let i = 0; i < asteroidCount; i++) {
                // ランダムな距離（小惑星帯の範囲内）
                const distance = innerRadius + Math.random() * (outerRadius - innerRadius);
                const angle = Math.random() * Math.PI * 2;
                
                // 小惑星のサイズ（非常に小さく）
                const size = 0.001 + Math.random() * 0.003;
                
                // 不規則な形状を作成
                const geometry = new THREE.SphereGeometry(size, 6, 4);
                const vertices = geometry.attributes.position.array;
                for (let j = 0; j < vertices.length; j += 3) {
                    const factor = 0.7 + Math.random() * 0.6; // 不規則性
                    vertices[j] *= factor;
                    vertices[j + 1] *= factor;
                    vertices[j + 2] *= factor;
                }
                geometry.attributes.position.needsUpdate = true;
                
                const material = new THREE.MeshLambertMaterial({
                    color: new THREE.Color().setHSL(0.1, 0.3, 0.2 + Math.random() * 0.3)
                });
                
                const asteroid = new THREE.Mesh(geometry, material);
                asteroid.position.x = Math.cos(angle) * distance;
                asteroid.position.z = Math.sin(angle) * distance;
                asteroid.position.y = (Math.random() - 0.5) * 0.05; // 少し高さにばらつき
                
                asteroid.rotation.x = Math.random() * Math.PI * 2;
                asteroid.rotation.y = Math.random() * Math.PI * 2;
                asteroid.rotation.z = Math.random() * Math.PI * 2;
                
                asteroid.castShadow = true;
                asteroid.receiveShadow = true;
                
                // 回転速度を設定
                asteroid.userData = {
                    rotationSpeed: (Math.random() - 0.5) * 0.01,
                    orbitSpeed: 0.0001 + Math.random() * 0.0002,
                    angle: angle,
                    distance: distance
                };
                
                asteroidGroup.add(asteroid);
            }
            
            solarSystemGroup.add(asteroidGroup);
            return asteroidGroup;
        }

        // カイパーベルトを作成（海王星の外側）
        function createKuiperBelt() {
            const kuiperGroup = new THREE.Group();
            const objectCount = 60; // 150から60に軽量化
            const innerRadius = 4.2;  // 海王星軌道より外側
            const outerRadius = 6.0;  // さらに外側
            
            for (let i = 0; i < objectCount; i++) {
                const distance = innerRadius + Math.random() * (outerRadius - innerRadius);
                const angle = Math.random() * Math.PI * 2;
                
                // カイパーベルト天体のサイズ
                const size = 0.002 + Math.random() * 0.008;
                
                const geometry = new THREE.SphereGeometry(size, 8, 6);
                const material = new THREE.MeshLambertMaterial({
                    color: new THREE.Color().setHSL(0.6, 0.4, 0.15 + Math.random() * 0.2)
                });
                
                const kbo = new THREE.Mesh(geometry, material);
                kbo.position.x = Math.cos(angle) * distance;
                kbo.position.z = Math.sin(angle) * distance;
                kbo.position.y = (Math.random() - 0.5) * 0.3; // より大きな軌道傾斜
                
                kbo.castShadow = true;
                kbo.receiveShadow = true;
                
                kbo.userData = {
                    rotationSpeed: (Math.random() - 0.5) * 0.005,
                    orbitSpeed: 0.00005 + Math.random() * 0.00005,
                    angle: angle,
                    distance: distance
                };
                
                kuiperGroup.add(kbo);
            }
            
            solarSystemGroup.add(kuiperGroup);
            return kuiperGroup;
        }

        // 太陽系外の恒星を作成
        function createDistantStars() {
            const starGroup = new THREE.Group();
            const starCount = 25; // 50から25に軽量化
            
            for (let i = 0; i < starCount; i++) {
                // 遠方の恒星
                const distance = 20 + Math.random() * 80;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                // より自然な恒星の実装
                const starType = Math.random();
                let size, color, intensity;
                
                // サイズを大幅に縮小して点光源のように見せる
                if (starType < 0.4) {
                    // 赤色矮星（最も多い）
                    size = 0.02 + Math.random() * 0.03;
                    color = new THREE.Color(0xFF8866);
                    intensity = 0.2;
                } else if (starType < 0.7) {
                    // 太陽型星
                    size = 0.025 + Math.random() * 0.035;
                    color = new THREE.Color(0xFFFFDD);
                    intensity = 0.3;
                } else if (starType < 0.85) {
                    // 青色星
                    size = 0.03 + Math.random() * 0.04;
                    color = new THREE.Color(0xDDEEFF);
                    intensity = 0.4;
                } else {
                    // 巨星（稀）
                    size = 0.04 + Math.random() * 0.05;
                    color = new THREE.Color(0xFFDD88);
                    intensity = 0.35;
                }
                
                const geometry = new THREE.SphereGeometry(size, 8, 6); // ポリゴン数削減
                const material = new THREE.MeshBasicMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: intensity,
                    transparent: true,
                    opacity: 0.8 + Math.random() * 0.2 // 微妙な透明度のばらつき
                });
                
                const star = new THREE.Mesh(geometry, material);
                star.position.x = distance * Math.sin(phi) * Math.cos(theta);
                star.position.y = distance * Math.sin(phi) * Math.sin(theta);
                star.position.z = distance * Math.cos(phi);
                
                // 非常に控えめな光源を追加
                if (Math.random() < 0.3) { // 30%の確率でのみ光源を追加
                    const starLight = new THREE.PointLight(color, 0.05, distance * 0.3);
                    starLight.position.copy(star.position);
                    scene.add(starLight);
                }
                
                starGroup.add(star);
            }
            
            scene.add(starGroup);
            registerUniverseElement(starGroup);
            return starGroup;
        }

        // 遠方の銀河を作成
        function createDistantGalaxies() {
            const galaxyGroup = new THREE.Group();
            const galaxyCount = 12; // 20から12に軽量化
            
            for (let i = 0; i < galaxyCount; i++) {
                // 非常に遠方の銀河
                const distance = 150 + Math.random() * 200;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                // 銀河の形状を作成
                const galaxyGeometry = new THREE.PlaneGeometry(2 + Math.random() * 4, 1 + Math.random() * 2);
                
                // 銀河テクスチャを作成
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                
                // 銀河の渦巻き模様
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                // 背景
                ctx.fillStyle = 'rgba(0, 0, 0, 0)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 銀河コア
                const coreGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 20);
                coreGradient.addColorStop(0, 'rgba(255, 220, 150, 0.8)');
                coreGradient.addColorStop(0.5, 'rgba(200, 150, 100, 0.4)');
                coreGradient.addColorStop(1, 'rgba(100, 100, 150, 0.1)');
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 20, 0, Math.PI * 2);
                ctx.fill();
                
                // 渦巻きアーム
                for (let arm = 0; arm < 2; arm++) {
                    ctx.strokeStyle = `rgba(150, 150, 200, ${0.3 + Math.random() * 0.2})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    for (let angle = 0; angle < Math.PI * 4; angle += 0.1) {
                        const radius = 5 + angle * 3;
                        const x = centerX + Math.cos(angle + arm * Math.PI) * radius;
                        const y = centerY + Math.sin(angle + arm * Math.PI) * radius * 0.3;
                        
                        if (angle === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                
                const galaxyTexture = new THREE.CanvasTexture(canvas);
                const galaxyMaterial = new THREE.MeshBasicMaterial({
                    map: galaxyTexture,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide
                });
                
                const galaxy = new THREE.Mesh(galaxyGeometry, galaxyMaterial);
                galaxy.position.x = distance * Math.sin(phi) * Math.cos(theta);
                galaxy.position.y = distance * Math.sin(phi) * Math.sin(theta);
                galaxy.position.z = distance * Math.cos(phi);
                
                // 銀河をカメラの方向に向ける
                galaxy.lookAt(0, 0, 0);
                
                // ゆっくりとした回転
                galaxy.userData = {
                    rotationSpeed: (Math.random() - 0.5) * 0.001
                };
                
                galaxyGroup.add(galaxy);
            }
            
            scene.add(galaxyGroup);
            registerUniverseElement(galaxyGroup);
            return galaxyGroup;
        }

        // 有名な星座を作成
        function createConstellations() {
            const constellationGroup = new THREE.Group();
            
            // オリオン座を作成
            const orionStars = [
                // ベテルギウス（左肩）
                { name: 'ベテルギウス', pos: [-30, 25, -80], color: 0xFF6644, size: 0.15 },
                // リゲル（右足）
                { name: 'リゲル', pos: [25, -25, -80], color: 0xAADDFF, size: 0.12 },
                // ベラトリックス（右肩）
                { name: 'ベラトリックス', pos: [20, 15, -80], color: 0xDDEEFF, size: 0.08 },
                // オリオンベルト
                { name: 'アルニタク', pos: [-8, 0, -80], color: 0xDDEEFF, size: 0.09 },
                { name: 'アルニラム', pos: [0, 0, -80], color: 0xDDEEFF, size: 0.09 },
                { name: 'ミンタカ', pos: [8, 0, -80], color: 0xDDEEFF, size: 0.08 },
                // 剣
                { name: 'オリオン星雲', pos: [0, -15, -80], color: 0xFF99DD, size: 0.1 }
            ];
            
            orionStars.forEach(star => {
                const geometry = new THREE.SphereGeometry(star.size, 16, 12);
                const material = new THREE.MeshBasicMaterial({
                    color: star.color,
                    emissive: star.color,
                    emissiveIntensity: 0.8
                });
                
                const starMesh = new THREE.Mesh(geometry, material);
                starMesh.position.set(star.pos[0], star.pos[1], star.pos[2]);
                starMesh.name = star.name;
                
                // 星の光を追加
                const starLight = new THREE.PointLight(star.color, 0.5, 50);
                starLight.position.copy(starMesh.position);
                scene.add(starLight);
                
                constellationGroup.add(starMesh);
            });
            
            // 北斗七星を作成
            const bigDipperStars = [
                { pos: [-60, 40, -90], color: 0xFFFFAA, size: 0.1 },
                { pos: [-50, 45, -90], color: 0xFFFFAA, size: 0.09 },
                { pos: [-40, 42, -90], color: 0xFFFFAA, size: 0.08 },
                { pos: [-30, 40, -90], color: 0xFFFFAA, size: 0.09 },
                { pos: [-20, 35, -90], color: 0xFFFFAA, size: 0.08 },
                { pos: [-15, 25, -90], color: 0xFFFFAA, size: 0.09 },
                { pos: [-10, 15, -90], color: 0xFFFFAA, size: 0.08 }
            ];
            
            bigDipperStars.forEach((star, index) => {
                const geometry = new THREE.SphereGeometry(star.size, 16, 12);
                const material = new THREE.MeshBasicMaterial({
                    color: star.color,
                    emissive: star.color,
                    emissiveIntensity: 0.7
                });
                
                const starMesh = new THREE.Mesh(geometry, material);
                starMesh.position.set(star.pos[0], star.pos[1], star.pos[2]);
                starMesh.name = `北斗七星${index + 1}`;
                
                constellationGroup.add(starMesh);
            });
            
            // カシオペア座を作成（W字型）
            const cassiopeiaStars = [
                { pos: [60, 50, -85], color: 0xDDEEFF, size: 0.09 },
                { pos: [55, 55, -85], color: 0xDDEEFF, size: 0.08 },
                { pos: [50, 52, -85], color: 0xDDEEFF, size: 0.1 },
                { pos: [45, 58, -85], color: 0xDDEEFF, size: 0.08 },
                { pos: [40, 55, -85], color: 0xDDEEFF, size: 0.09 }
            ];
            
            cassiopeiaStars.forEach((star, index) => {
                const geometry = new THREE.SphereGeometry(star.size, 16, 12);
                const material = new THREE.MeshBasicMaterial({
                    color: star.color,
                    emissive: star.color,
                    emissiveIntensity: 0.7
                });
                
                const starMesh = new THREE.Mesh(geometry, material);
                starMesh.position.set(star.pos[0], star.pos[1], star.pos[2]);
                starMesh.name = `カシオペア${index + 1}`;
                
                constellationGroup.add(starMesh);
            });
            
            scene.add(constellationGroup);
            registerUniverseElement(constellationGroup);
            return constellationGroup;
        }

        // WebXRサポートチェック
        async function checkXRSupport() {
            if ('xr' in navigator) {
                try {
                    const supported = await navigator.xr.isSessionSupported('immersive-ar');
                    xrSupported = supported;
                } catch (error) {
                    try {
                        const supported = await navigator.xr.isSessionSupported('immersive-vr');
                        xrSupported = supported;
                    } catch (error) {
                        xrSupported = false;
                    }
                }
            }

            const button = document.getElementById('xr-button');
            button.disabled = true; // 初期状態では無効
            
            if (!xrSupported) {
                button.textContent = 'XR非対応デバイス';
                document.getElementById('warning-panel').style.display = 'block';
            } else {
                button.textContent = '読み込み中...';
            }
        }

        // 初期化
        function init() {
            const container = document.getElementById('container');

            // BGM初期化
            bgMusic = document.getElementById('bgm');
            bgMusic.volume = 0.3; // 音量を30%に設定
            
            // レイキャスター初期化
            raycaster = new THREE.Raycaster();

            // シーン作成
            scene = new THREE.Scene();

            // カメラ作成
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.001, 1000);
            camera.position.set(0, 1.6, 5);

            // レンダラー作成
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            // 太陽系グループ
            solarSystemGroup = new THREE.Group();
            solarSystemGroup.position.set(0, 1, -2);
            scene.add(solarSystemGroup);
            registerUniverseElement(solarSystemGroup);
            
            // 初期ユーザー位置を設定
            updateUserPosition();

            // 星空
            const stars = createStarField();
            scene.add(stars);
            originalStars = stars; // 元の星空を保存
            registerUniverseElement(stars);

            // 宇宙空間の星空を準備（最初は非表示）
            spaceStars = createSpaceStarField();
            spaceStars.visible = false;
            scene.add(spaceStars);
            registerUniverseElement(spaceStars);

            // 背景フェード用球体を作成
            backgroundSphere = createBackgroundSphere();
            scene.add(backgroundSphere);

            // メイン太陽光源（白飛び防止のためさらに調整）
            const sunLight = new THREE.PointLight(0xFFFFDD, 2.5, 100);
            sunLight.position.set(0, 0, 0);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 4096;
            sunLight.shadow.mapSize.height = 4096;
            sunLight.shadow.camera.near = 0.1;
            sunLight.shadow.camera.far = 100;
            solarSystemGroup.add(sunLight);
            
            // 追加の太陽光源（控えめに）
            const sunLight2 = new THREE.PointLight(0xFFDD88, 1.2, 80);
            sunLight2.position.set(0, 0, 0);
            solarSystemGroup.add(sunLight2);
            
            // 太陽コロナ光源（さらに控えめに）
            const coronaLight = new THREE.PointLight(0xFFFFFF, 0.6, 60);
            coronaLight.position.set(0, 0, 0);
            solarSystemGroup.add(coronaLight);

            // 環境光（テクスチャのディテールを保護）
            const ambientLight = new THREE.AmbientLight(0x404080, 0.3);
            scene.add(ambientLight);

            // 小惑星帯を作成（火星と木星の間）
            createAsteroidBelt();
            
            // カイパーベルトを作成（海王星の外側）
            createKuiperBelt();
            
            // 太陽系外の恒星を作成
            createDistantStars();
            
            // 遠方の銀河を作成
            createDistantGalaxies();
            
            // 有名な星座を作成
            createConstellations();
            
            // 惑星作成
            planetData.forEach((data, index) => {
                const geometry = new THREE.SphereGeometry(data.size, 64, 32); // より高品質なジオメトリ
                const texture = createPlanetTexture(data.type, 2048); // 高解像度テクスチャ
                
                let material;
                if (data.name === '太陽') {
                    material = new THREE.MeshBasicMaterial({ 
                        map: texture,
                        emissive: new THREE.Color(0xFFFFFF), // 純白の強力な発光
                        emissiveIntensity: 6.0, // さらに強化してリアルな輝きに
                        transparent: false,
                        side: THREE.DoubleSide
                    });
                    
                    // シンプルで自然なグロー効果のみ
                    const glowGeometry = new THREE.SphereGeometry(data.size * 1.05, 16, 12); // 非常に薄い層
                    const glowMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            time: { value: 0 },
                            glowColor: { value: new THREE.Color(0xFFFF88) }
                        },
                        vertexShader: `
                            varying vec3 vNormal;
                            void main() {
                                vNormal = normalize(normalMatrix * normal);
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform float time;
                            uniform vec3 glowColor;
                            varying vec3 vNormal;
                            void main() {
                                float intensity = pow(0.4 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 0.8);
                                intensity *= (0.6 + 0.1 * sin(time * 2.0)); // 微細な脈動
                                intensity *= 0.3; // 控えめな強度
                                gl_FragColor = vec4(glowColor, intensity);
                            }
                        `,
                        side: THREE.BackSide,
                        blending: THREE.AdditiveBlending,
                        transparent: true,
                        depthWrite: false
                    });
                    const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                    data.glowMaterial = glowMaterial;
                } else {
                    material = new THREE.MeshLambertMaterial({ 
                        map: texture,
                        bumpMap: texture,
                        bumpScale: 0.001
                    });
                }
                
                const planet = new THREE.Mesh(geometry, material);
                planet.position.x = data.distance;
                planet.castShadow = data.name !== '太陽';
                planet.receiveShadow = data.name !== '太陽';
                
                // 太陽の場合はシンプルなグローエフェクトを追加
                if (data.name === '太陽' && data.glowMaterial) {
                    const glowGeometry = new THREE.SphereGeometry(data.size * 1.05, 16, 12); // 薄い層
                    const glowMesh = new THREE.Mesh(glowGeometry, data.glowMaterial);
                    planet.add(glowMesh);
                    data.glowMesh = glowMesh; // 参照を保存
                }
                
                // 軌道表示
                if (data.distance > 0) {
                    const orbitPoints = [];
                    for (let i = 0; i <= 64; i++) {
                        const angle = (i / 64) * Math.PI * 2;
                        orbitPoints.push(new THREE.Vector3(
                            Math.cos(angle) * data.distance,
                            0,
                            Math.sin(angle) * data.distance
                        ));
                    }
                    const orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
                    const orbitMaterial = new THREE.LineBasicMaterial({ 
                        color: 0x444444, 
                        transparent: true, 
                        opacity: 0.2
                    });
                    const orbit = new THREE.Line(orbitGeometry, orbitMaterial);
                    orbit.userData = { type: 'orbit' }; // 軌道線を識別するタグ
                    solarSystemGroup.add(orbit);
                }

                // 土星のリング
                if (data.name === '土星') {
                    const ringGeometry = new THREE.RingGeometry(data.size + 0.03, data.size + 0.08, 32);
                    const ringMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xD2691E,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.8
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.PI / 2;
                    planet.add(ring);
                }

                // 地球の月
                if (data.name === '地球') {
                    const moonGeometry = new THREE.SphereGeometry(0.0035, 16, 8);
                    const moonMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                    const moon = new THREE.Mesh(moonGeometry, moonMaterial);
                    moon.position.x = 0.045;
                    moon.castShadow = true;
                    moon.userData = { speed: 0.08, distance: 0.045 };
                    planet.add(moon);
                }

                planets.push({ 
                    mesh: planet, 
                    data: data, 
                    angle: Math.random() * Math.PI * 2,
                    rotationSpeed: data.rotationSpeed
                });
                solarSystemGroup.add(planet);
            });

            setupXRControllers();
            animate();
            
            // データ読み込み完了
            dataLoaded = true;
            
            // ボタンを有効化
            const xrButton = document.getElementById('xr-button');
            if (xrSupported) {
                xrButton.disabled = false;
                xrButton.textContent = '🥽 MR太陽系を開始';
            }
            
            document.getElementById('loading').style.display = 'none';
        }

        // XRコントローラーセットアップ
        function setupXRControllers() {
            // 参考プログラムと同様の配列ベースの実装
            controllers = [
                renderer.xr.getController(0),
                renderer.xr.getController(1)
            ];
            
            controllers.forEach((controller, index) => {
                if (!controller) return;
                
                const hand = index === 0 ? 'left' : 'right';
                
                controller.addEventListener('selectstart', (event) => onSelectStart(event, hand));
                controller.addEventListener('selectend', (event) => onSelectEnd(event, hand));
                controller.addEventListener('squeezestart', () => onGripStart(hand));
                controller.addEventListener('squeezeend', () => onGripEnd(hand));
                
                // レーザーポインター追加
                createControllerRay(controller, 0x00ff88);
                
                scene.add(controller);
            });
            
            // コントローラーグリップも追加
            const leftControllerGrip = renderer.xr.getControllerGrip(0);
            const rightControllerGrip = renderer.xr.getControllerGrip(1);
            scene.add(leftControllerGrip);
            scene.add(rightControllerGrip);
            
            console.log('XR Controllers setup completed');
        }
        
        // レーザーポインター作成関数
        function createControllerRay(controller, color) {
            const geometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, -3)
            ]);
            const material = new THREE.LineBasicMaterial({ 
                color: color, 
                transparent: true, 
                opacity: 0.8 
            });

            const ray = new THREE.Line(geometry, material);
            ray.userData.isRay = true;
            controller.add(ray);
            
            // カーソル（レイの先端）
            const cursorGeometry = new THREE.SphereGeometry(0.01, 8, 8);
            const cursorMaterial = new THREE.MeshBasicMaterial({ 
                color: color,
                emissive: color,
                emissiveIntensity: 0.5
            });
            const cursor = new THREE.Mesh(cursorGeometry, cursorMaterial);
            cursor.position.set(0, 0, -3);
            cursor.userData.isCursor = true;
            ray.add(cursor);
        }

        // XRイベントハンドラー
        function onSelectStart(event, hand) {
            // 情報パネルが表示されている場合は閉じる
            if (planetInfoVisible) {
                hide3DPlanetInfo();
                return;
            }
            
            // このコントローラーのインデックスを取得
            const controllerIndex = hand === 'left' ? 0 : 1;
            const thisControllerHighlight = highlightedPlanets[controllerIndex];
            
            if (spaceMode) {
                // 宇宙空間モードの場合
                if (thisControllerHighlight) {
                    // このコントローラーでハイライトされている惑星の情報表示
                    show3DPlanetInfo(thisControllerHighlight.data);
                } else {
                    // このコントローラーで何もハイライトされていない場合はMRモードに戻る
                    toggleSpaceMode();
                }
                return;
            }
            
            // MRモードでの操作
            if (thisControllerHighlight) {
                // このコントローラーでハイライトされている惑星情報を記録してVRモードに切り替え
                pendingPlanetInfo = thisControllerHighlight.data;
                toggleSpaceMode();
            }
        }

        function onSelectEnd(event, hand) {
            // トリガー終了
        }

        function onGripStart(hand) {
            gripStates[hand] = true;
            
            // 片手グリップの場合はドラッグ開始
            if (((gripStates.left && !gripStates.right) || (!gripStates.left && gripStates.right)) && controllers.length > 0) {
                isDragging = true;
                const controller = gripStates.left ? controllers[0] : controllers[1];
                if (controller) {
                    const tempMatrix = new THREE.Matrix4();
                    tempMatrix.identity().extractRotation(controller.matrixWorld);
                    dragStartPosition.setFromMatrixPosition(controller.matrixWorld);
                    userStartPosition.copy(userPosition);
                }
            }
            
            // 両手でグリップした場合の初期距離を記録
            if (gripStates.left && gripStates.right && controllers.length >= 2 && controllers[0] && controllers[1]) {
                isDragging = false;
                const leftPos = new THREE.Vector3();
                const rightPos = new THREE.Vector3();
                leftPos.setFromMatrixPosition(controllers[0].matrixWorld);
                rightPos.setFromMatrixPosition(controllers[1].matrixWorld);
                lastDistance = leftPos.distanceTo(rightPos);
            }
            
            updateGripStatus();
        }

        function onGripEnd(hand) {
            gripStates[hand] = false;
            isDragging = false;
            updateGripStatus();
        }

        function updateGripStatus() {
            const gripStatus = document.getElementById('grip-status');
            const isGripping = gripStates.left && gripStates.right;
            gripStatus.textContent = isGripping ? 'ON' : 'OFF';
            gripStatus.style.color = isGripping ? '#00ff88' : '#ffffff';
        }

        // 3D惑星情報パネル作成
        function create3DInfoPanel(planetData) {
            const canvas = document.createElement('canvas');
            canvas.width = 600; // サイズを大きく
            canvas.height = 700;
            const ctx = canvas.getContext('2d');
            
            // 背景
            ctx.fillStyle = 'rgba(0, 20, 40, 0.95)';
            ctx.fillRect(0, 0, 600, 700);
            
            // 枠線
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 4;
            ctx.strokeRect(0, 0, 600, 700);
            
            // 内側の装飾枠
            ctx.strokeStyle = 'rgba(0, 255, 136, 0.3)';
            ctx.lineWidth = 2;
            ctx.strokeRect(10, 10, 580, 680);
            
            // 惑星名
            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 42px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(planetData.name, 300, 60);
            
            // アンダーライン
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(100, 75);
            ctx.lineTo(500, 75);
            ctx.stroke();
            
            // 基本情報項目のレイアウト（簡略化）
            ctx.textAlign = 'left';
            let yPos = 120;
            const lineHeight = 40;
            
            const infoItems = [
                { label: '距離', value: planetData.realDistance, icon: '🌍' },
                { label: 'サイズ', value: planetData.realSize, icon: '📏' },
                { label: '公転周期', value: planetData.period, icon: '🔄' },
                { label: '発見', value: planetData.discovery, icon: '🔭' }
            ];
            
            infoItems.forEach(item => {
                // アイコン
                ctx.font = '22px Arial';
                ctx.fillStyle = '#ffffff';
                ctx.fillText(item.icon, 30, yPos);
                
                // ラベル
                ctx.fillStyle = '#ffaa00';
                ctx.font = 'bold 22px Arial';
                ctx.fillText(item.label + ':', 70, yPos);
                
                // 値
                ctx.fillStyle = '#ffffff';
                ctx.font = '20px Arial';
                const labelWidth = ctx.measureText(item.label + ': ').width;
                ctx.fillText(item.value, 70 + labelWidth, yPos);
                
                yPos += lineHeight;
            });
            
            // 特徴セクション（より大きく）
            yPos += 30;
            ctx.fillStyle = '#ffaa00';
            ctx.font = 'bold 28px Arial';
            ctx.fillText('✨ 特徴:', 30, yPos);
            
            yPos += 40;
            ctx.fillStyle = '#ffffff';
            ctx.font = '18px Arial';
            
            // 特徴テキストを複数行に分割（より詳細に）
            const features = planetData.feature;
            const maxWidth = 520;
            const words = features.split('');
            let line = '';
            
            for (let i = 0; i < words.length; i++) {
                const testLine = line + words[i];
                const metrics = ctx.measureText(testLine);
                
                if (metrics.width > maxWidth && i > 0) {
                    ctx.fillText(line, 50, yPos);
                    line = words[i];
                    yPos += 24;
                } else {
                    line = testLine;
                }
            }
            ctx.fillText(line, 50, yPos);
            
            // 豆知識セクション（より大きく）
            yPos += 50;
            ctx.fillStyle = '#00ddff';
            ctx.font = 'bold 28px Arial';
            ctx.fillText('💡 豆知識:', 30, yPos);
            
            yPos += 40;
            ctx.fillStyle = '#ddffdd';
            ctx.font = '18px Arial';
            
            // 豆知識テキストを複数行に分割（より詳細に）
            const facts = planetData.fact;
            const factWords = facts.split('');
            let factLine = '';
            
            for (let i = 0; i < factWords.length; i++) {
                const testLine = factLine + factWords[i];
                const metrics = ctx.measureText(testLine);
                
                if (metrics.width > maxWidth && i > 0) {
                    ctx.fillText(factLine, 50, yPos);
                    factLine = factWords[i];
                    yPos += 24;
                } else {
                    factLine = testLine;
                }
            }
            ctx.fillText(factLine, 50, yPos);
            
            // 操作説明
            ctx.fillStyle = '#888888';
            ctx.font = '18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('トリガーで閉じる', 300, 660);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            return texture;
        }

        function show3DPlanetInfo(planetData) {
            // 既存のパネルを即座に完全削除
            if (planetInfoPanel) {
                removePlanetInfoPanel();
            }
            
            // 効果音を再生
            playInfoPanelSound();
            
            const texture = create3DInfoPanel(planetData);
            const geometry = new THREE.PlaneGeometry(0.35, 0.4); // サイズを調整
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                side: THREE.DoubleSide,
                opacity: 0 // 初期値を0に設定
            });
            
            planetInfoPanel = new THREE.Mesh(geometry, material);
            planetInfoPanel.name = 'planet-info-panel';
            
            // 左手コントローラーの位置に配置
            if (controllers.length > 0 && controllers[0]) {
                controllers[0].add(planetInfoPanel);
                // コントローラーから少し前方に配置
                planetInfoPanel.position.set(0, 0.1, -0.2);
                planetInfoPanel.rotation.x = -Math.PI / 6; // 少し下向きに
            } else {
                // コントローラーがない場合はシーンに直接追加
                scene.add(planetInfoPanel);
                planetInfoPanel.position.set(-0.5, 1.8, -1);
            }
            
            planetInfoVisible = true;
            
            // フェードインアニメーション開始
            panelFadeAnimation.target = 1;
            panelFadeAnimation.opacity = 0;
        }

        function hide3DPlanetInfo() {
            if (planetInfoPanel) {
                removePlanetInfoPanel();
            }
            
            planetInfoVisible = false;
        }

        // パネルを完全に削除する関数
        function removePlanetInfoPanel() {
            if (planetInfoPanel) {
                if (planetInfoPanel.parent) {
                    planetInfoPanel.parent.remove(planetInfoPanel);
                }
                
                scene.remove(planetInfoPanel);
                
                if (planetInfoPanel.material) {
                    if (planetInfoPanel.material.map) {
                        planetInfoPanel.material.map.dispose();
                    }
                    planetInfoPanel.material.dispose();
                }
                
                if (planetInfoPanel.geometry) {
                    planetInfoPanel.geometry.dispose();
                }
                
                planetInfoPanel = null;
                planetInfoVisible = false;
                
                panelFadeAnimation.opacity = 0;
                panelFadeAnimation.target = 0;
            }
        }

        // ハイライト効果
        function highlightPlanet(planet, controllerIndex) {
            if (highlightedPlanets[controllerIndex] && highlightedPlanets[controllerIndex] !== planet) {
                // 前のハイライトを削除
                removeHighlight(highlightedPlanets[controllerIndex], controllerIndex);
            }
            
            highlightedPlanets[controllerIndex] = planet;
            
            try {
                const material = planet.mesh.material;
                
                // 太陽の場合は特別処理（スムーズなスケールアニメーション）
                if (planet.data.name === '太陽') {
                    // 太陽の場合はスケールアニメーションを開始
                    if (!planet.originalScale) {
                        planet.originalScale = planet.mesh.scale.clone();
                        sunScaleAnimation.current = 1;
                    }
                    sunScaleAnimation.target = 1.1;
                } else {
                    // 他の惑星は発光効果
                    if (!planet.originalEmissive) {
                        if (material.emissive) {
                            planet.originalEmissive = material.emissive.clone();
                        } else {
                            planet.originalEmissive = new THREE.Color(0x000000);
                        }
                        
                        if (material.emissiveIntensity !== undefined) {
                            planet.originalEmissiveIntensity = material.emissiveIntensity;
                        } else {
                            planet.originalEmissiveIntensity = 0;
                        }
                    }
                    
                    // 発光効果を設定
                    if (!material.emissive) {
                        material.emissive = new THREE.Color();
                    }
                    material.emissive.setHex(0x00ff88);
                    
                    if (material.emissiveIntensity !== undefined) {
                        material.emissiveIntensity = 0.3;
                    }
                }
            } catch (error) {
                console.error(`Error highlighting planet ${planet.data.name}:`, error);
            }
        }

        function removeHighlight(planet, controllerIndex) {
            try {
                if (planet && planet.mesh) {
                    // このコントローラー以外でもハイライトされているかチェック
                    const otherControllerIndex = controllerIndex === 0 ? 1 : 0;
                    const stillHighlighted = highlightedPlanets[otherControllerIndex] === planet;
                    
                    if (!stillHighlighted) {
                        // 他のコントローラーでハイライトされていない場合のみハイライトを削除
                        if (planet.data.name === '太陽') {
                            // 太陽の場合はスケールアニメーションを元に戻す
                            sunScaleAnimation.target = 1;
                        } else {
                            // 他の惑星は発光を元に戻す
                            if (planet.mesh.material && planet.originalEmissive) {
                                const material = planet.mesh.material;
                                
                                if (material.emissive && planet.originalEmissive) {
                                    material.emissive.copy(planet.originalEmissive);
                                }
                                
                                if (material.emissiveIntensity !== undefined && planet.originalEmissiveIntensity !== undefined) {
                                    material.emissiveIntensity = planet.originalEmissiveIntensity;
                                }
                                
                                planet.originalEmissive = null;
                                planet.originalEmissiveIntensity = null;
                            }
                        }
                    }
                }
            } catch (error) {
                console.error(`Error removing highlight from planet:`, error);
            }
        }

        function clearHighlight(controllerIndex) {
            if (highlightedPlanets[controllerIndex]) {
                removeHighlight(highlightedPlanets[controllerIndex], controllerIndex);
                highlightedPlanets[controllerIndex] = null;
            }
        }
        
        function clearAllHighlights() {
            clearHighlight(0);
            clearHighlight(1);
        }

        // XRセッション開始
        async function startXRSession() {
            if (!xrSupported || !dataLoaded) return;

            try {
                // BGM再生開始
                if (bgMusic) {
                    try {
                        await bgMusic.play();
                    } catch (error) {
                        console.log('BGM autoplay prevented:', error);
                        // ユーザーの操作後に再生を試みる
                    }
                }

                let sessionInit = { 
                    requiredFeatures: ['local-floor'],
                    optionalFeatures: ['hand-tracking', 'anchors', 'plane-detection']
                };
                
                let session;
                try {
                    session = await navigator.xr.requestSession('immersive-ar', sessionInit);
                } catch (arError) {
                    session = await navigator.xr.requestSession('immersive-vr', sessionInit);
                }

                await renderer.xr.setSession(session);
                xrActive = true;
                
                // XRセッション開始後にコントローラーをセットアップ
                setupXRControllers();

                // UI更新
                document.getElementById('xr-button').style.display = 'none';
                document.getElementById('instructions').style.display = 'none';
                document.getElementById('info-panel').style.display = 'block';

                session.addEventListener('end', () => {
                    xrActive = false;
                    
                    // BGM停止
                    if (bgMusic) {
                        bgMusic.pause();
                        bgMusic.currentTime = 0;
                    }
                    
                    // 3D情報パネルをクリーンアップ
                    hide3DPlanetInfo();
                    
                    // ハイライトをクリア
                    clearAllHighlights();
                    
                    // 保留中の惑星情報もクリア
                    pendingPlanetInfo = null;
                    
                    document.getElementById('xr-button').style.display = 'block';
                    document.getElementById('instructions').style.display = 'block';
                    document.getElementById('info-panel').style.display = 'none';
                });

            } catch (error) {
                alert('XRセッションの開始に失敗しました: ' + error.message);
            }
        }

        // アニメーションループ
        let time = 0;
        function animate() {
            renderer.setAnimationLoop(animate);
            time += 0.01;

            // 太陽のスケールアニメーション
            if (Math.abs(sunScaleAnimation.current - sunScaleAnimation.target) > 0.001) {
                sunScaleAnimation.current += (sunScaleAnimation.target - sunScaleAnimation.current) * sunScaleAnimation.speed;
                
                // 太陽を見つけてスケールを適用
                const sunPlanet = planets.find(p => p.data.name === '太陽');
                if (sunPlanet && sunPlanet.originalScale) {
                    sunPlanet.mesh.scale.copy(sunPlanet.originalScale);
                    sunPlanet.mesh.scale.multiplyScalar(sunScaleAnimation.current);
                }
            }

            // 情報パネルのフェードアニメーション
            if (planetInfoPanel && Math.abs(panelFadeAnimation.opacity - panelFadeAnimation.target) > 0.001) {
                panelFadeAnimation.opacity += (panelFadeAnimation.target - panelFadeAnimation.opacity) * panelFadeAnimation.speed;
                
                // 透明度を適用（0以下にならないように）
                const actualOpacity = Math.max(0, Math.min(1, panelFadeAnimation.opacity));
                planetInfoPanel.material.opacity = actualOpacity;
                
                // フェードアウト完了時にパネルを削除（より確実な判定）
                if (panelFadeAnimation.target === 0 && (panelFadeAnimation.opacity <= 0.05 || actualOpacity <= 0.01)) {
                    removePlanetInfoPanel();
                }
            }

            // スペースモードのフェードアニメーション
            if (spaceFadeAnimation.transitioning) {
                const oldProgress = spaceFadeAnimation.progress;
                spaceFadeAnimation.progress += (spaceFadeAnimation.target - spaceFadeAnimation.progress) * spaceFadeAnimation.speed;
                
                applySpaceModeChange(spaceFadeAnimation.progress);
            }

            // 宇宙空間モードでの星の動き
            if (spaceMode && spaceStars) {
                spaceRotation += 0.0001; // さらにゆっくりとした回転
                spaceStars.rotation.y = spaceRotation;
                spaceStars.rotation.x = spaceRotation * 0.3;
                spaceStars.rotation.z = spaceRotation * 0.1;
            }

            // 惑星の軌道運動と自転（常に動作）
            planets.forEach((planet) => {
                if (planet.data.distance > 0) {
                    planet.angle += planet.data.speed;
                    planet.mesh.position.x = Math.cos(planet.angle) * planet.data.distance;
                    planet.mesh.position.z = Math.sin(planet.angle) * planet.data.distance;
                }
                
                planet.mesh.rotation.y += planet.rotationSpeed;
                
                // 太陽のグローエフェクト更新
                if (planet.data.name === '太陽' && planet.data.glowMaterial) {
                    planet.data.glowMaterial.uniforms.time.value = time;
                }
                
                // 衛星の公転
                planet.mesh.children.forEach(moon => {
                    if (moon.userData && moon.userData.speed) {
                        const moonAngle = time * moon.userData.speed;
                        moon.position.x = Math.cos(moonAngle) * moon.userData.distance;
                        moon.position.z = Math.sin(moonAngle) * moon.userData.distance;
                    }
                });
            });

            // 小惑星とカイパーベルト天体のアニメーション
            solarSystemGroup.children.forEach(child => {
                if (child.isGroup) {
                    child.children.forEach(object => {
                        if (object.userData && object.userData.rotationSpeed) {
                            // 自転
                            object.rotation.x += object.userData.rotationSpeed;
                            object.rotation.y += object.userData.rotationSpeed * 0.7;
                            object.rotation.z += object.userData.rotationSpeed * 0.3;
                            
                            // 公転（小惑星とカイパーベルト天体）
                            if (object.userData.orbitSpeed) {
                                object.userData.angle += object.userData.orbitSpeed;
                                object.position.x = Math.cos(object.userData.angle) * object.userData.distance;
                                object.position.z = Math.sin(object.userData.angle) * object.userData.distance;
                            }
                        }
                    });
                }
            });

            // 遠方の銀河の回転
            scene.children.forEach(child => {
                if (child.isGroup && child.children.length > 0) {
                    child.children.forEach(galaxy => {
                        if (galaxy.userData && galaxy.userData.rotationSpeed) {
                            galaxy.rotation.z += galaxy.userData.rotationSpeed;
                        }
                    });
                }
            });

            // レイキャスト（両方のコントローラーから惑星への当たり判定）
            if (xrActive && !planetInfoVisible && controllers.length > 0) {
                // 各コントローラーで独立してレイキャスト処理
                controllers.forEach((controller, index) => {
                    if (controller && controller.visible) {
                        try {
                            // コントローラーの位置と方向を取得
                            const tempMatrix = new THREE.Matrix4();
                            tempMatrix.identity().extractRotation(controller.matrixWorld);
                            
                            const controllerPosition = new THREE.Vector3();
                            controllerPosition.setFromMatrixPosition(controller.matrixWorld);
                            
                            const controllerDirection = new THREE.Vector3(0, 0, -1);
                            controllerDirection.applyMatrix4(tempMatrix);
                            controllerDirection.normalize();
                            
                            raycaster.set(controllerPosition, controllerDirection);
                            
                            // 惑星のメッシュのみをチェック
                            const planetMeshes = planets.map(p => p.mesh).filter(mesh => mesh && mesh.visible);
                            const intersects = raycaster.intersectObjects(planetMeshes);
                            
                            if (intersects.length > 0) {
                                const intersectedPlanet = planets.find(p => p.mesh === intersects[0].object);
                                if (intersectedPlanet && intersectedPlanet !== highlightedPlanets[index]) {
                                    highlightPlanet(intersectedPlanet, index);
                                }
                            } else {
                                clearHighlight(index);
                            }
                        } catch (error) {
                            // エラーが発生した場合はこのコントローラーのハイライトをクリア
                            clearHighlight(index);
                        }
                    } else {
                        // コントローラーが非表示の場合はハイライトをクリア
                        clearHighlight(index);
                    }
                });
            }

            // 片手グリップでのドラッグ移動（ユーザー位置を移動）
            if (isDragging && controllers.length > 0) {
                const activeController = gripStates.left ? controllers[0] : controllers[1];
                if (activeController) {
                    const currentPosition = new THREE.Vector3();
                    currentPosition.setFromMatrixPosition(activeController.matrixWorld);
                    
                    const deltaPosition = new THREE.Vector3().subVectors(currentPosition, dragStartPosition);
                    // 移動方向を反転させてユーザーが移動している感覚にする
                    deltaPosition.multiplyScalar(-5);
                    userPosition.copy(userStartPosition).add(deltaPosition);
                    
                    // カメラとシーン全体の位置を更新
                    updateUserPosition();
                }
            }

            // 両手グリップでのスケール調整（常に動作）
            if (gripStates.left && gripStates.right && controllers.length >= 2 && controllers[0] && controllers[1] && !isDragging) {
                const leftPos = new THREE.Vector3();
                const rightPos = new THREE.Vector3();
                leftPos.setFromMatrixPosition(controllers[0].matrixWorld);
                rightPos.setFromMatrixPosition(controllers[1].matrixWorld);
                const currentDistance = leftPos.distanceTo(rightPos);
                
                if (lastDistance > 0 && currentDistance > 0) {
                    const scaleChange = currentDistance / lastDistance;
                    scaleFactor *= scaleChange;
                    
                    // スケール制限
                    scaleFactor = Math.max(0.1, Math.min(10, scaleFactor));
                    
                    solarSystemGroup.scale.setScalar(scaleFactor);
                    
                    // UI更新
                    document.getElementById('scale-value').textContent = scaleFactor.toFixed(2);
                }
                
                lastDistance = currentDistance;
            }

            renderer.render(scene, camera);
        }

        // リサイズハンドラー
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // イベントリスナー
        window.addEventListener('resize', onWindowResize);
        document.getElementById('xr-button').addEventListener('click', startXRSession);

        // 初期化開始
        checkXRSupport().then(() => {
            init();
        });

        // 宇宙空間モード切り替え
        function toggleSpaceMode() {
            if (spaceFadeAnimation.transitioning) {
                return; // 既にトランジション中の場合は無視
            }
            
            spaceFadeAnimation.transitioning = true;
            spaceFadeAnimation.targetMode = !spaceMode;
            
            if (spaceFadeAnimation.targetMode) {
                // 宇宙空間モードへ
                spaceFadeAnimation.target = 1;
                spaceFadeAnimation.progress = 0;
            } else {
                // MRモードへ
                spaceFadeAnimation.target = 1;
                spaceFadeAnimation.progress = 0;
            }
        }

        // フェード効果付きの実際のモード切り替え
        function applySpaceModeChange(progress) {
            const targetMode = spaceFadeAnimation.targetMode;
            
            if (targetMode) {
                // 宇宙空間モードへの切り替え
                if (originalStars && originalStars.material) {
                    originalStars.material.opacity = Math.max(0, 1 - progress);
                }
                if (spaceStars && spaceStars.material) {
                    spaceStars.material.opacity = Math.min(1, progress);
                }
                
                // 背景球体のフェードイン（完全に不透明に）
                if (backgroundSphere && backgroundSphere.material) {
                    backgroundSphere.material.opacity = Math.min(1.0, progress);
                }
                
                // 星の表示状態を管理
                if (progress > 0.1) {
                    spaceStars.visible = true;
                    backgroundSphere.visible = true;
                }
                if (progress > 0.9) {
                    originalStars.visible = false;
                }
                
                // カメラ位置の補間
                const startPos = new THREE.Vector3(0, 1.6, 5);
                const endPos = new THREE.Vector3(0, 0, 0);
                camera.position.lerpVectors(startPos, endPos, progress);
                
            } else {
                // MRモードへの復帰
                if (spaceStars && spaceStars.material) {
                    spaceStars.material.opacity = Math.max(0, 1 - progress);
                }
                if (originalStars && originalStars.material) {
                    originalStars.material.opacity = Math.min(1, progress);
                }
                
                // 背景球体のフェードアウト
                if (backgroundSphere && backgroundSphere.material) {
                    backgroundSphere.material.opacity = Math.max(0, 1.0 * (1 - progress));
                }
                
                // 星の表示状態を管理
                if (progress > 0.1) {
                    originalStars.visible = true;
                }
                if (progress > 0.9) {
                    spaceStars.visible = false;
                    backgroundSphere.visible = false;
                }
                
                // カメラ位置の補間
                const startPos = new THREE.Vector3(0, 0, 0);
                const endPos = new THREE.Vector3(0, 1.6, 5);
                camera.position.lerpVectors(startPos, endPos, progress);
            }
            
            // 完了処理
            if (Math.abs(progress - spaceFadeAnimation.target) < 0.05) {
                spaceMode = targetMode;
                spaceFadeAnimation.transitioning = false;
                
                if (spaceMode) {
                    // 宇宙空間モード完了
                    originalStars.visible = false;
                    spaceStars.visible = true;
                    backgroundSphere.visible = true;
                    originalStars.material.opacity = 0;
                    spaceStars.material.opacity = 1;
                    backgroundSphere.material.opacity = 1.0;
                    camera.position.set(0, 0, 0);
                    
                    // VRモードでは軌道線を非表示
                    toggleOrbitVisibility(false);
                    
                    // 記録された惑星情報があれば自動表示
                    if (pendingPlanetInfo) {
                        setTimeout(() => {
                            show3DPlanetInfo(pendingPlanetInfo);
                            pendingPlanetInfo = null;
                        }, 500);
                    }
                } else {
                    // MRモード完了
                    spaceStars.visible = false;
                    originalStars.visible = true;
                    backgroundSphere.visible = false;
                    spaceStars.material.opacity = 0;
                    originalStars.material.opacity = 1;
                    backgroundSphere.material.opacity = 0;
                    camera.position.set(0, 1.6, 5);
                    
                    // MRモードでは軌道線を表示
                    toggleOrbitVisibility(true);
                    
                    // MRモード復帰時は保留中の惑星情報をクリア
                    pendingPlanetInfo = null;
                }
            }
        }

        // 控えめな効果音を生成・再生する関数
        function playInfoPanelSound() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (error) {
                    return;
                }
            }

            try {
                // 複数の音を重ねて美しい効果音を作成
                const now = audioContext.currentTime;
                
                // メインベル音（基音）
                const oscillator1 = audioContext.createOscillator();
                const gainNode1 = audioContext.createGain();
                oscillator1.connect(gainNode1);
                gainNode1.connect(audioContext.destination);
                
                oscillator1.frequency.setValueAtTime(880, now); // A5音
                oscillator1.frequency.exponentialRampToValueAtTime(660, now + 0.5); // E5音へ下降
                oscillator1.type = 'sine';
                
                gainNode1.gain.setValueAtTime(0, now);
                gainNode1.gain.linearRampToValueAtTime(0.15, now + 0.02);
                gainNode1.gain.exponentialRampToValueAtTime(0.001, now + 1.2);
                
                // ハーモニー音（第5度）
                const oscillator2 = audioContext.createOscillator();
                const gainNode2 = audioContext.createGain();
                oscillator2.connect(gainNode2);
                gainNode2.connect(audioContext.destination);
                
                oscillator2.frequency.setValueAtTime(1320, now); // E6音
                oscillator2.frequency.exponentialRampToValueAtTime(990, now + 0.5); // B5音へ下降
                oscillator2.type = 'sine';
                
                gainNode2.gain.setValueAtTime(0, now);
                gainNode2.gain.linearRampToValueAtTime(0.08, now + 0.02);
                gainNode2.gain.exponentialRampToValueAtTime(0.001, now + 1.0);
                
                // 微細な響き（オクターブ上）
                const oscillator3 = audioContext.createOscillator();
                const gainNode3 = audioContext.createGain();
                oscillator3.connect(gainNode3);
                gainNode3.connect(audioContext.destination);
                
                oscillator3.frequency.setValueAtTime(1760, now); // A6音
                oscillator3.type = 'triangle';
                
                gainNode3.gain.setValueAtTime(0, now);
                gainNode3.gain.linearRampToValueAtTime(0.04, now + 0.01);
                gainNode3.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
                
                // 再生開始
                oscillator1.start(now);
                oscillator1.stop(now + 1.2);
                
                oscillator2.start(now);
                oscillator2.stop(now + 1.0);
                
                oscillator3.start(now);
                oscillator3.stop(now + 0.8);
                
            } catch (error) {
                // エラーは無視
            }
        }

        // 軌道線の表示制御
        function toggleOrbitVisibility(visible) {
            solarSystemGroup.children.forEach(child => {
                if (child.userData && child.userData.type === 'orbit') {
                    child.visible = visible;
                }
            });
        }

        // 移動対象となる宇宙要素のリスト
        let universeElements = [];

        // ユーザー位置の更新
        function updateUserPosition() {
            if (!xrActive) {
                // 非XRモードでのカメラ位置更新
                camera.position.copy(userPosition);
            } else {
                // XRモードでは全ての宇宙要素を相対的に移動
                const offset = new THREE.Vector3().subVectors(new THREE.Vector3(0, 1.6, 5), userPosition);
                
                // すべての登録された宇宙要素を移動
                universeElements.forEach(element => {
                    if (element && element.position) {
                        element.position.copy(element.originalPosition).add(offset);
                    }
                });
            }
        }

        // 宇宙要素を登録する関数
        function registerUniverseElement(element) {
            if (element && element.position) {
                // 元の位置を保存
                element.originalPosition = element.position.clone();
                universeElements.push(element);
            }
        }
    </script>
</body>
</html>