<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR MR å¤ªé™½ç³»æ¢ç´¢</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0c0c1e 0%, #1a1a2e 50%, #16213e 100%);
            overflow: hidden;
            height: 100vh;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #canvas {
            display: block;
        }

        .overlay {
            position: absolute;
            color: white;
            font-size: 14px;
            background: rgba(0, 0, 32, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 136, 0.3);
            backdrop-filter: blur(10px);
            pointer-events: none;
        }

        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            z-index: 1000;
        }

        #xr-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            background: linear-gradient(45deg, #00ff88, #0088ff);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            z-index: 100;
        }

        #xr-button:disabled {
            background: #666666;
            cursor: not-allowed;
        }

        #instructions {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 14px;
            max-width: 400px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            text-align: left;
            z-index: 100;
        }

        #troubleshooting {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 12px;
            max-width: 300px;
            background: rgba(40, 20, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            border: 2px solid rgba(255, 170, 0, 0.6);
            text-align: center;
            z-index: 100;
            box-shadow: 0 4px 15px rgba(255, 170, 0, 0.2);
        }

        #info-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            display: none;
            z-index: 9999;
        }

        #warning-panel {
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(139, 0, 0, 0.8);
            text-align: center;
            display: none;
        }

        #planet-info {
            position: absolute !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
            background: rgba(0, 20, 40, 0.98) !important;
            border: 3px solid rgba(0, 255, 136, 1) !important;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.8) !important;
            max-width: 350px;
            display: none;
            z-index: 999999 !important;
            pointer-events: auto;
            color: white !important;
            font-family: 'Courier New', monospace !important;
            font-size: 14px !important;
            opacity: 0; /* XRãƒ¢ãƒ¼ãƒ‰ã§ã¯3Dè¡¨ç¤ºã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚éè¡¨ç¤º */
            visibility: hidden;
        }

        .info-title {
            color: #00ff88;
            font-size: 18px;
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 0 0 10px #00ff88;
        }

        .info-item {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
        }

        .info-label {
            color: #ffaa00;
        }

        .info-value {
            color: #ffffff;
        }

        .highlight {
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
        }

        .warning {
            color: #ffaa00;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">
            <div style="text-align: center;">
                <div>ğŸŒŒ MRå¤ªé™½ç³»ã‚’æº–å‚™ä¸­...</div>
                <div style="margin-top: 20px; font-size: 16px;">
                    WebXRã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’åˆæœŸåŒ–ã—ã¦ã„ã¾ã™
                </div>
            </div>
        </div>

        <button id="xr-button">
            ğŸ¥½ MRå¤ªé™½ç³»ã‚’é–‹å§‹
        </button>

        <div id="instructions">
            <h3 class="highlight" style="margin: 0 0 10px 0;">ğŸŒŸ æ“ä½œæ–¹æ³•</h3>
            <div>â€¢ ç§»å‹•ï¼šç‰‡æ‰‹ã‚°ãƒªãƒƒãƒ—+ãƒ‰ãƒ©ãƒƒã‚°</div>
            <div>â€¢ æ‹¡å¤§/ç¸®å°ï¼šä¸¡æ‰‹ã‚°ãƒªãƒƒãƒ—</div>
            <div>â€¢ æƒ‘æ˜Ÿã‚¯ãƒªãƒƒã‚¯ï¼šVR+æƒ…å ±è¡¨ç¤º</div>
            <div>â€¢ ç©ºé–“ã‚¯ãƒªãƒƒã‚¯ï¼šMRå¾©å¸°</div>
        </div>

        <div id="troubleshooting">
            <div style="color: #ffaa00;">
                âš ï¸ ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãŒåŠ¹ã‹ãªã„å ´åˆï¼šãƒ›ãƒ¼ãƒ ãƒœã‚¿ãƒ³ã§çµ‚äº†
            </div>
        </div>

        <div id="info-panel" class="overlay">
            <div class="highlight" style="margin-bottom: 10px;">
                ğŸ¥½ MRãƒ¢ãƒ¼ãƒ‰ï¼šã‚¢ã‚¯ãƒ†ã‚£ãƒ–
            </div>
            <div>ã‚¹ã‚±ãƒ¼ãƒ«: <span id="scale-value">1.00</span>x</div>
            <div>ä¸¡æ‰‹ã‚°ãƒªãƒƒãƒ—: <span id="grip-status">OFF</span></div>
        </div>

        <div id="warning-panel" class="overlay">
            <div style="margin-bottom: 10px;">âš ï¸ WebXRéå¯¾å¿œç’°å¢ƒ</div>
            <div>ã“ã®ãƒ‡ãƒã‚¤ã‚¹ã§ã¯MRæ©Ÿèƒ½ã‚’ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚</div>
            <div>Meta Questã€HoloLensã€Magic Leapç­‰ã®å¯¾å¿œãƒ‡ãƒã‚¤ã‚¹ã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚</div>
        </div>

        <div id="planet-info" class="overlay">
            <div class="info-title" id="planet-name">æƒ‘æ˜Ÿå</div>
            <div class="info-item">
                <span class="info-label">è·é›¢:</span>
                <span class="info-value" id="planet-distance">-</span>
            </div>
            <div class="info-item">
                <span class="info-label">ã‚µã‚¤ã‚º:</span>
                <span class="info-value" id="planet-size">-</span>
            </div>
            <div class="info-item">
                <span class="info-label">å…¬è»¢å‘¨æœŸ:</span>
                <span class="info-value" id="planet-period">-</span>
            </div>
            <div class="info-item">
                <span class="info-label">ç‰¹å¾´:</span>
                <span class="info-value" id="planet-feature">-</span>
            </div>
            <div style="text-align: center; margin-top: 15px; color: #888;">
                ãƒˆãƒªã‚¬ãƒ¼ã§é–‰ã˜ã‚‹
            </div>
        </div>

        <!-- BGM -->
        <audio id="bgm" loop preload="auto" style="display: none;">
            <source src="Mystical Cosmos.mp3" type="audio/mpeg">
        </audio>
    </div>

    <script>
        let scene, camera, renderer, solarSystemGroup;
        let planets = [];
        let controllers = []; // é…åˆ—ãƒ™ãƒ¼ã‚¹ã«å¤‰æ›´
        let gripStates = { left: false, right: false };
        let lastDistance = 0;
        let scaleFactor = 1;
        let xrSupported = false;
        let xrActive = false;
        let raycaster = new THREE.Raycaster();
        let highlightedPlanets = [null, null]; // å„ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆå¯¾è±¡
        let planetInfoVisible = false;
        let isDragging = false;
        let dragStartPosition = new THREE.Vector3();
        let userStartPosition = new THREE.Vector3();
        let userPosition = new THREE.Vector3(0, 1.6, 5); // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ä»®æƒ³ä½ç½®
        let planetInfoPanel = null;
        let sunScaleAnimation = { target: 1, current: 1, speed: 0.05 };
        let panelFadeAnimation = { opacity: 0, target: 0, speed: 0.05 };
        let spaceMode = false;
        let spaceStars = null;
        let originalStars = null;
        let originalBackground = null;
        let spaceRotation = 0;
        let spaceFadeAnimation = { 
            transitioning: false, 
            progress: 0, 
            target: 0, 
            speed: 0.04,
            targetMode: false 
        };
        let backgroundSphere = null;
        let pendingPlanetInfo = null; // VRãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆå¾Œã«è¡¨ç¤ºäºˆå®šã®æƒ‘æ˜Ÿæƒ…å ±
        let dataLoaded = false; // ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å®Œäº†ãƒ•ãƒ©ã‚°
        let bgMusic = null; // BGMç”¨
        let audioContext = null; // Web Audio APIç”¨
        let panelClosing = false; // æƒ…å ±ãƒ‘ãƒãƒ«ãŒã‚¯ãƒ­ãƒ¼ã‚ºå‡¦ç†ä¸­ã‹ã©ã†ã‹

        // æƒ‘æ˜Ÿãƒ‡ãƒ¼ã‚¿
        const planetData = [
            { name: 'å¤ªé™½', size: 0.25, distance: 0, color: 0xFFA500, speed: 0, type: 'sun', emissive: 0xFFAA00, rotationSpeed: 0.001, 
              realDistance: '0', realSize: '1,392,700km', period: '-', 
              feature: 'å¤ªé™½ç³»ã®ä¸­å¿ƒã«ä½ç½®ã™ã‚‹æ’æ˜Ÿã§ã€æ°´ç´ ã¨ãƒ˜ãƒªã‚¦ãƒ ã®æ ¸èåˆã«ã‚ˆã‚Šè«å¤§ãªã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’æ”¾å‡ºã—ã¦ã„ã‚‹ã€‚è¡¨é¢æ¸©åº¦ã¯ç´„5,778Kã€ä¸­å¿ƒéƒ¨ã¯1,500ä¸‡åº¦ã«é”ã™ã‚‹ã€‚å¤ªé™½é¢¨ã¨å‘¼ã°ã‚Œã‚‹è·é›»ç²’å­ã®æµã‚Œã‚’å¸¸ã«æ”¾å‡ºã—ã¦ãŠã‚Šã€ã“ã‚ŒãŒåœ°çƒã®ã‚ªãƒ¼ãƒ­ãƒ©ã®åŸå› ã¨ãªã£ã¦ã„ã‚‹ã€‚',
              discovery: 'å¤ä»£', 
              fact: 'å¤ªé™½ã¯1ç§’é–“ã«400ä¸‡ãƒˆãƒ³ã®è³ªé‡ã‚’ã‚¨ãƒãƒ«ã‚®ãƒ¼ã«å¤‰æ›ã—ã¦ã„ã‚‹ã€‚åœ°çƒã«å±Šãå¤ªé™½å…‰ã¯8åˆ†19ç§’å‰ã«å¤ªé™½è¡¨é¢ã‚’å‡ºç™ºã—ãŸã‚‚ã®ã€‚å¤ªé™½ã®æ ¸ã§ä½œã‚‰ã‚ŒãŸå…‰å­ãŒè¡¨é¢ã«åˆ°é”ã™ã‚‹ã¾ã§ã«ã¯10ä¸‡å¹´ã‹ã‚‰17ä¸‡å¹´ã‹ã‹ã‚‹ã€‚å¤ªé™½ç³»ã®è³ªé‡ã®99.86%ã‚’å ã‚ã¦ãŠã‚Šã€åœ°çƒ130ä¸‡å€‹åˆ†ã®ä½“ç©ã‚’æŒã¤ã€‚' },
            { name: 'æ°´æ˜Ÿ', size: 0.008, distance: 0.6, color: 0x8C7853, speed: 0.002, type: 'mercury', rotationSpeed: 0.0002,
              realDistance: '0.39AU', realSize: '4,879km', period: '88æ—¥', 
              feature: 'å¤ªé™½ã«æœ€ã‚‚è¿‘ã„æƒ‘æ˜Ÿã§ã€æ¥µç«¯ãªæ¸©åº¦å·®ãŒç‰¹å¾´ã€‚å¤§æ°—ãŒã»ã¨ã‚“ã©å­˜åœ¨ã—ãªã„ãŸã‚ã€æ˜¼é–“ã¯427Â°Cã€å¤œé–“ã¯-173Â°Cã¨590Â°Cã‚‚ã®æ¸©åº¦å·®ãŒç”Ÿã˜ã‚‹ã€‚è¡¨é¢ã¯ã‚¯ãƒ¬ãƒ¼ã‚¿ãƒ¼ã ã‚‰ã‘ã§æœˆã«ä¼¼ã¦ã„ã‚‹ãŒã€å·¨å¤§ãªã‚«ãƒ­ãƒªã‚¹ç›†åœ°ã¨ã„ã†ç›´å¾„1,550kmã®è¡çªã‚¯ãƒ¬ãƒ¼ã‚¿ãƒ¼ãŒå­˜åœ¨ã™ã‚‹ã€‚',
              discovery: 'å¤ä»£', 
              fact: 'æ°´æ˜Ÿã®1æ—¥ï¼ˆè‡ªè»¢å‘¨æœŸï¼‰ã¯åœ°çƒã®59æ—¥ã«ç›¸å½“ã™ã‚‹ãŒã€1å¹´ï¼ˆå…¬è»¢å‘¨æœŸï¼‰ã¯88æ—¥ã—ã‹ãªã„ã€‚ãã®ãŸã‚æ°´æ˜Ÿã§ã¯1æ—¥ãŒ1å¹´ã®3åˆ†ã®2ã‚‚ã®é•·ã•ã«ãªã‚‹ã€‚ã¾ãŸã€æ°´æ˜Ÿã¯å¤ªé™½ç³»ã§æœ€ã‚‚è»Œé“é›¢å¿ƒç‡ãŒå¤§ããã€è¿‘æ—¥ç‚¹ã¨é æ—¥ç‚¹ã®è·é›¢å·®ã¯2,400ä¸‡kmã‚‚ã‚ã‚‹ã€‚æ°·ãŒå­˜åœ¨ã™ã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹æ¥µåœ°ã®ã‚¯ãƒ¬ãƒ¼ã‚¿ãƒ¼ãŒã‚ã‚‹ã€‚' },
            { name: 'é‡‘æ˜Ÿ', size: 0.012, distance: 0.85, color: 0xFFC649, speed: 0.0015, type: 'venus', rotationSpeed: -0.00005,
              realDistance: '0.72AU', realSize: '12,104km', period: '225æ—¥', 
              feature: 'å¤ªé™½ç³»ã§æœ€ã‚‚é«˜æ¸©ã®æƒ‘æ˜Ÿã§ã€åšã„äºŒé…¸åŒ–ç‚­ç´ ã®å¤§æ°—ã¨ç¡«é…¸ã®é›²ã«è¦†ã‚ã‚Œã¦ã„ã‚‹ã€‚æ¸©å®¤åŠ¹æœã«ã‚ˆã‚Šè¡¨é¢æ¸©åº¦ã¯462Â°Cã«é”ã—ã€é‰›ã‚‚æº¶ã‘ã‚‹ã»ã©ã€‚å¤§æ°—åœ§ã¯åœ°çƒã®90å€ã‚‚ã‚ã‚‹ã€‚èˆˆå‘³æ·±ã„ã“ã¨ã«ã€ä»–ã®æƒ‘æ˜Ÿã¨ã¯é€†æ–¹å‘ã«è‡ªè»¢ã—ã¦ã„ã‚‹ã€‚ã“ã®é€†å›è»¢ã«ã‚ˆã‚Šã€é‡‘æ˜Ÿã§ã¯å¤ªé™½ãŒè¥¿ã‹ã‚‰æ˜‡ã‚Šæ±ã«æ²ˆã‚€ã€‚',
              discovery: 'å¤ä»£', 
              fact: 'é‡‘æ˜Ÿã®1æ—¥ã¯åœ°çƒã®243æ—¥ã«ç›¸å½“ã—ã€ã“ã‚Œã¯é‡‘æ˜Ÿã®1å¹´ï¼ˆ225æ—¥ï¼‰ã‚ˆã‚Šã‚‚é•·ã„ã€‚ã¤ã¾ã‚Šé‡‘æ˜Ÿã§ã¯1æ—¥ãŒ1å¹´ã‚ˆã‚Šé•·ã„å”¯ä¸€ã®æƒ‘æ˜Ÿã€‚é‡‘æ˜Ÿã®é›²ã¯ç¡«é…¸ã§ã§ãã¦ãŠã‚Šã€æ™‚é€Ÿ350kmã¨ã„ã†çŒ›çƒˆãªé¢¨ãŒå¹ã„ã¦ã„ã‚‹ã€‚è¡¨é¢ã«ã¯ç´„1,000å€‹ã®ç«å±±ãŒã‚ã‚Šã€ç¾åœ¨ã‚‚æ´»å‹•ã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã€‚' },
            { name: 'åœ°çƒ', size: 0.013, distance: 1.15, color: 0x6B93D6, speed: 0.001, type: 'earth', rotationSpeed: 0.004,
              realDistance: '1.00AU', realSize: '12,756km', period: '365æ—¥', 
              feature: 'å¤ªé™½ç³»ã§å”¯ä¸€ç”Ÿå‘½ãŒå­˜åœ¨ã™ã‚‹ã“ã¨ãŒç¢ºèªã•ã‚Œã¦ã„ã‚‹æƒ‘æ˜Ÿã€‚è¡¨é¢ã®71%ãŒæµ·ã§è¦†ã‚ã‚Œã€é…¸ç´ ã¨çª’ç´ ã‹ã‚‰ãªã‚‹å¤§æ°—ã«åŒ…ã¾ã‚Œã¦ã„ã‚‹ã€‚æœˆã¨ã„ã†å¤§ããªè¡›æ˜Ÿã‚’æŒã¡ã€ã“ã‚ŒãŒæ½®æ±ã‚’ç”Ÿã¿å‡ºã—åœ°è»¸ã‚’å®‰å®šã•ã›ã¦ã„ã‚‹ã€‚ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ†ã‚¯ãƒˆãƒ‹ã‚¯ã‚¹ã«ã‚ˆã‚Šåœ°è¡¨ãŒå¸¸ã«å¤‰åŒ–ã—ç¶šã‘ã¦ã„ã‚‹ã€‚ç£å ´ã«ã‚ˆã‚Šå¤ªé™½é¢¨ã‹ã‚‰ä¿è­·ã•ã‚Œã¦ã„ã‚‹ã€‚',
              discovery: 'å¤ä»£', 
              fact: 'åœ°çƒä¸Šã®ç”Ÿå‘½ã¯ç´„38å„„å¹´å‰ã«èª•ç”Ÿã—ãŸã¨ã•ã‚Œã€æœ€åˆã¯å˜ç´°èƒç”Ÿç‰©ã ã£ãŸã€‚åœ°çƒã®æ ¸ã¯æ¶²ä½“ã®é‰„ã¨ãƒ‹ãƒƒã‚±ãƒ«ã§ã§ãã¦ãŠã‚Šã€ãã®æµå‹•ã«ã‚ˆã‚Šç£å ´ãŒç”Ÿæˆã•ã‚Œã‚‹ã€‚1æ—¥ã¯å®Ÿéš›ã«ã¯23æ™‚é–“56åˆ†4ç§’ã§ã€ã“ã‚Œã‚’æ’æ˜Ÿæ—¥ã¨ã„ã†ã€‚åœ°çƒã®é‡åŠ›ã«ã‚ˆã‚Šæ™‚ç©ºãŒæ­ªã¿ã€GPSè¡›æ˜Ÿã¯ç›¸å¯¾æ€§ç†è«–ã®è£œæ­£ãŒå¿…è¦ã€‚' },
            { name: 'ç«æ˜Ÿ', size: 0.009, distance: 1.45, color: 0xCD5C5C, speed: 0.0008, type: 'mars', rotationSpeed: 0.0038,
              realDistance: '1.52AU', realSize: '6,792km', period: '687æ—¥', 
              feature: 'èµ¤ã„æƒ‘æ˜Ÿã¨ã—ã¦çŸ¥ã‚‰ã‚Œã€é…¸åŒ–é‰„ï¼ˆéŒ†ï¼‰ã«ã‚ˆã‚Šèµ¤ãè¦‹ãˆã‚‹ã€‚å¤ªé™½ç³»æœ€å¤§ã®ç«å±±ã‚ªãƒªãƒ³ãƒã‚¹å±±ï¼ˆé«˜ã•21kmï¼‰ã¨æœ€å¤§ã®å³¡è°·ãƒ´ã‚¡ãƒ¬ã‚¹ãƒ»ãƒãƒªãƒãƒªã‚¹ã‚’æŒã¤ã€‚æ¥µåœ°ã«ã¯æ°·ãŒå­˜åœ¨ã—ã€éå»ã«ã¯æ¶²ä½“ã®æ°´ãŒæµã‚Œã¦ã„ãŸè¨¼æ‹ ãŒã‚ã‚‹ã€‚è–„ã„å¤§æ°—ã‚’æŒã¡ã€å·¨å¤§ãªç ‚åµãŒæƒ‘æ˜Ÿå…¨ä½“ã‚’è¦†ã†ã“ã¨ãŒã‚ã‚‹ã€‚',
              discovery: 'å¤ä»£', 
              fact: 'ç«æ˜Ÿã«ã¯å¤ªé™½ç³»æœ€å¤§ã®ç«å±±ã‚ªãƒªãƒ³ãƒã‚¹å±±ãŒã‚ã‚Šã€ã“ã‚Œã¯ã‚¨ãƒ™ãƒ¬ã‚¹ãƒˆã®ç´„3å€ã®é«˜ã•ã€‚ç«æ˜Ÿã®é‡åŠ›ã¯åœ°çƒã®38%ãªã®ã§ã€åœ°çƒã§50kg ã®äººã¯ç«æ˜Ÿã§ã¯19kgã«ãªã‚‹ã€‚ç«æ˜Ÿã®1æ—¥ã¯24æ™‚é–“37åˆ†ã¨åœ°çƒã¨ã»ã¼åŒã˜ã€‚ç«æ˜Ÿã«ã¯ã€Œãƒ•ã‚©ãƒœã‚¹ã€ã¨ã€Œãƒ‡ã‚¤ãƒ¢ã‚¹ã€ã¨ã„ã†2ã¤ã®å°ã•ãªè¡›æ˜ŸãŒã‚ã‚Šã€ã©ã¡ã‚‰ã‚‚ã‚¸ãƒ£ã‚¬ã‚¤ãƒ¢ã®ã‚ˆã†ãªä¸è¦å‰‡ãªå½¢ã‚’ã—ã¦ã„ã‚‹ã€‚' },
            { name: 'æœ¨æ˜Ÿ', size: 0.11, distance: 2.0, color: 0xD2691E, speed: 0.0005, type: 'jupiter', rotationSpeed: 0.009,
              realDistance: '5.20AU', realSize: '142,984km', period: '12å¹´', 
              feature: 'å¤ªé™½ç³»æœ€å¤§ã®æƒ‘æ˜Ÿã§ã€åœ°çƒã®1,300å€ä»¥ä¸Šã®ä½“ç©ã‚’æŒã¤ã‚¬ã‚¹å·¨æ˜Ÿã€‚å¤§èµ¤æ–‘ã¨ã„ã†åœ°çƒ2å€‹åˆ†ã®å·¨å¤§ãªé«˜æ°—åœ§ã®åµãŒ300å¹´ä»¥ä¸Šç¶šã„ã¦ã„ã‚‹ã€‚95å€‹ã®è¡›æ˜Ÿã‚’æŒã¡ã€ãã®ä¸­ã«ã¯æ°·ã®ä¸‹ã«æµ·ãŒã‚ã‚‹ã‚¨ã‚¦ãƒ­ãƒ‘ã‚„ã€æ´»ç«å±±ãŒã‚ã‚‹ã‚¤ã‚ªãªã©ãŒã‚ã‚‹ã€‚æœ¨æ˜Ÿã¯å¤ªé™½ç³»ã®æƒé™¤æ©Ÿã®å½¹å‰²ã‚’æœãŸã—ã€å°æƒ‘æ˜Ÿã‚„å½—æ˜Ÿã‚’å¼•ãå¯„ã›ã¦åœ°çƒã‚’å®ˆã£ã¦ã„ã‚‹ã€‚',
              discovery: 'å¤ä»£', 
              fact: 'æœ¨æ˜Ÿã¯å¤ªé™½ç³»ã®ä»–ã®ã™ã¹ã¦ã®æƒ‘æ˜Ÿã‚’åˆã‚ã›ãŸã‚ˆã‚Šã‚‚é‡ã„ã€‚æœ¨æ˜Ÿã®é‡åŠ›ã«ã‚ˆã‚Šã€å¤ªé™½ç³»å¤–ç¸éƒ¨ã®å°å¤©ä½“ãŒå†…å´ã«ä¾µå…¥ã™ã‚‹ã®ã‚’é˜²ã„ã§ã„ã‚‹ã€‚æœ¨æ˜Ÿã®è¡›æ˜Ÿã‚¤ã‚ªã¯å¤ªé™½ç³»ã§æœ€ã‚‚ç«å±±æ´»å‹•ãŒæ´»ç™ºã§ã€ç¡«é»„ã®å™´ç«ã«ã‚ˆã‚Šé»„è‰²ãè¦‹ãˆã‚‹ã€‚æœ¨æ˜Ÿã¯å®Ÿã¯å°ã•ãªæ’æ˜Ÿã«ãªã‚Šãã“ã­ãŸæ˜Ÿã§ã€ã‚‚ã†å°‘ã—é‡ã‘ã‚Œã°ç¬¬äºŒã®å¤ªé™½ã«ãªã£ã¦ã„ãŸã€‚' },
            { name: 'åœŸæ˜Ÿ', size: 0.09, distance: 2.6, color: 0xB8860B, speed: 0.0004, type: 'saturn', rotationSpeed: 0.008,
              realDistance: '9.58AU', realSize: '120,536km', period: '29å¹´', 
              feature: 'ç¾ã—ã„ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã§æœ‰åãªã‚¬ã‚¹å·¨æ˜Ÿã€‚ãƒªãƒ³ã‚°ã¯æ°·ã¨å²©çŸ³ã®ç ´ç‰‡ã§ã§ãã¦ãŠã‚Šã€æ•°å„„å€‹ã®ç²’å­ãŒè»Œé“ã‚’æã„ã¦ã„ã‚‹ã€‚146å€‹ã®è¡›æ˜Ÿã‚’æŒã¡ã€ãã®ä¸­ã«ã¯æ¿ƒã„å¤§æ°—ã¨æ¶²ä½“ãƒ¡ã‚¿ãƒ³ã®æ¹–ãŒã‚ã‚‹ã‚¿ã‚¤ã‚¿ãƒ³ã‚„ã€æ°·ã®é–“æ¬ æ³‰ã‚’å™´å‡ºã™ã‚‹ã‚¨ãƒ³ã‚±ãƒ©ãƒ‰ã‚¹ãŒã‚ã‚‹ã€‚å¯†åº¦ãŒæ°´ã‚ˆã‚Šè»½ãã€ç†è«–ä¸Šã¯å·¨å¤§ãªãƒ—ãƒ¼ãƒ«ãŒã‚ã‚Œã°æµ®ãã“ã¨ãŒã§ãã‚‹ã€‚',
              discovery: 'å¤ä»£', 
              fact: 'åœŸæ˜Ÿã®ãƒªãƒ³ã‚°ã®åšã•ã¯ã‚ãšã‹10ãƒ¡ãƒ¼ãƒˆãƒ«ã»ã©ã—ã‹ãªã„ã€‚åœŸæ˜Ÿã®è¡›æ˜Ÿã‚¿ã‚¤ã‚¿ãƒ³ã¯å¤ªé™½ç³»ã§å”¯ä¸€æ¿ƒã„å¤§æ°—ã‚’æŒã¤è¡›æ˜Ÿã§ã€ãƒ¡ã‚¿ãƒ³ã®é›¨ãŒé™ã‚Šã€ãƒ¡ã‚¿ãƒ³ã¨ã‚¨ã‚¿ãƒ³ã®æ¹–ãŒã‚ã‚‹ã€‚åœŸæ˜Ÿã®åŒ—æ¥µã«ã¯å…­è§’å½¢ã®åµãŒã‚ã‚Šã€ã“ã‚Œã¯ä»–ã®æƒ‘æ˜Ÿã§ã¯è¦‹ã‚‰ã‚Œãªã„ç¾è±¡ã€‚åœŸæ˜Ÿã¯å¤ªé™½ç³»ã§æœ€ã‚‚å¹³ãŸã„æƒ‘æ˜Ÿã§ã€æ¥µå¾„ã¨èµ¤é“å¾„ã®å·®ãŒç´„12,000kmã‚‚ã‚ã‚‹ã€‚' },
            { name: 'å¤©ç‹æ˜Ÿ', size: 0.04, distance: 3.2, color: 0x4FD0E7, speed: 0.0003, type: 'uranus', rotationSpeed: 0.007,
              realDistance: '19.2AU', realSize: '51,118km', period: '84å¹´', 
              feature: 'è‡ªè»¢è»¸ãŒ98åº¦å‚¾ã„ã¦ãŠã‚Šã€æ¨ªå€’ã—ã«å›è»¢ã—ã¦ã„ã‚‹æ°·ã®å·¨æ˜Ÿã€‚ã“ã®ç‰¹ç•°ãªè‡ªè»¢ã«ã‚ˆã‚Šã€æ¥µåœ°ã§ã¯42å¹´é–“æ˜¼ãŒç¶šãã€ãã®å¾Œ42å¹´é–“å¤œãŒç¶šãã€‚ãƒ¡ã‚¿ãƒ³æ°·ã®é›²ã«ã‚ˆã‚Šç¾ã—ã„é’ç·‘è‰²ã«è¦‹ãˆã‚‹ã€‚éå¸¸ã«æš—ã„ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã‚’æŒã¡ã€27å€‹ã®è¡›æ˜ŸãŒã‚ã‚‹ã€‚ç£å ´ãŒè‡ªè»¢è»¸ã‹ã‚‰59åº¦ã‚‚å‚¾ã„ã¦ã„ã‚‹å¥‡å¦™ãªæƒ‘æ˜Ÿã€‚',
              discovery: '1781å¹´', 
              fact: 'å¤©ç‹æ˜Ÿã¯å¤ªé™½ç³»ã§æœ€ã‚‚å¯’ã„æƒ‘æ˜Ÿã§ã€æœ€ä½æ¸©åº¦ã¯-224Â°Cã«é”ã™ã‚‹ã€‚æœ¨æ˜Ÿã‚„åœŸæ˜Ÿã‚ˆã‚Šã‚‚é ã„ã®ã«ã€ãªãœã‹æµ·ç‹æ˜Ÿã‚ˆã‚Šã‚‚å¯’ã„ã€‚å¤©ç‹æ˜Ÿã®ç™ºè¦‹ã«ã‚ˆã‚Šå¤ªé™½ç³»ã®å¤§ãã•ãŒä¸€æ°—ã«2å€ã«ãªã£ãŸã€‚å¤©ç‹æ˜Ÿã®è¡›æ˜Ÿã¯ã™ã¹ã¦ã‚·ã‚§ã‚¤ã‚¯ã‚¹ãƒ”ã‚¢ã®ä½œå“ã®ç™»å ´äººç‰©ã«ã¡ãªã‚“ã§åä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹ã€‚å¤©ç‹æ˜Ÿã®1å¹´ã¯åœ°çƒã®84å¹´ã«ç›¸å½“ã™ã‚‹ã€‚' },
            { name: 'æµ·ç‹æ˜Ÿ', size: 0.04, distance: 3.8, color: 0x4169E1, speed: 0.0002, type: 'neptune', rotationSpeed: 0.006,
              realDistance: '30.1AU', realSize: '49,528km', period: '165å¹´', 
              feature: 'å¤ªé™½ç³»æœ€ã‚‚é ã„æƒ‘æ˜Ÿã§ã€æ·±ã„é’è‰²ãŒç¾ã—ã„æ°·ã®å·¨æ˜Ÿã€‚å¤ªé™½ç³»ã§æœ€ã‚‚å¼·ã„é¢¨ãŒå¹ãã€ãã®é€Ÿåº¦ã¯æ™‚é€Ÿ2,100kmã«é”ã™ã‚‹ã€‚ã“ã‚Œã¯éŸ³é€Ÿã®1.5å€ã¨ã„ã†é©šç•°çš„ãªé€Ÿã•ã€‚å¤§æš—æ–‘ã¨ã„ã†å·¨å¤§ãªåµãŒã‚ã£ãŸãŒã€ç¾åœ¨ã¯æ¶ˆå¤±ã—ã¦ã„ã‚‹ã€‚16å€‹ã®è¡›æ˜Ÿã‚’æŒã¡ã€æœ€å¤§ã®è¡›æ˜Ÿãƒˆãƒªãƒˆãƒ³ã¯é€†è¡Œè»Œé“ã‚’æŒã¤çã—ã„è¡›æ˜Ÿã€‚',
              discovery: '1846å¹´', 
              fact: 'æµ·ç‹æ˜Ÿã¯è¨ˆç®—ã«ã‚ˆã£ã¦ç™ºè¦‹ã•ã‚ŒãŸå”¯ä¸€ã®æƒ‘æ˜Ÿã§ã€å¤©ç‹æ˜Ÿã®è»Œé“ã®ä¹±ã‚Œã‹ã‚‰å­˜åœ¨ãŒäºˆæ¸¬ã•ã‚ŒãŸã€‚æµ·ç‹æ˜Ÿã¯2011å¹´ã«ã‚ˆã†ã‚„ãç™ºè¦‹ä»¥æ¥åˆã‚ã¦ã®å…¬è»¢ã‚’å®Œäº†ã—ãŸã€‚æµ·ç‹æ˜Ÿã®è¡›æ˜Ÿãƒˆãƒªãƒˆãƒ³ã¯å¤ªé™½ç³»ã§æœ€ã‚‚å¯’ã„å ´æ‰€ã®ä¸€ã¤ã§ã€-235Â°Cã¨ã„ã†æ¥µä½æ¸©ã€‚æµ·ç‹æ˜Ÿã®ã‚³ã‚¢ã®æ¸©åº¦ã¯ç´„5,000Â°Cã§ã€å¤ªé™½ã®è¡¨é¢ã¨ã»ã¼åŒã˜æ¸©åº¦ã€‚' }
        ];

        // æƒ‘æ˜Ÿãƒ†ã‚¯ã‚¹ãƒãƒ£ç”Ÿæˆï¼ˆå¤§å¹…å¼·åŒ–ï¼‰
        function createPlanetTexture(type, size = 2048) { // è§£åƒåº¦ã‚’2å€ã«
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            switch(type) {
                case 'sun':
                    // è¶…é«˜å“è³ªãªå¤ªé™½ãƒ†ã‚¯ã‚¹ãƒãƒ£
                    const centerX = size / 2;
                    const centerY = size / 2;
                    const radius = size / 2;
                    
                    // ãƒ™ãƒ¼ã‚¹ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼šæ ¸ã‹ã‚‰è¡¨é¢ã¸ã®ç¾å®Ÿçš„ãªã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                    const baseGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                    baseGradient.addColorStop(0, '#FFFFFF');    // æ ¸å¿ƒéƒ¨ï¼šç´”ç™½
                    baseGradient.addColorStop(0.05, '#FFFFEE'); // å†…éƒ¨ï¼šç™½
                    baseGradient.addColorStop(0.15, '#FFFFDD'); // æ”¾å°„å±¤
                    baseGradient.addColorStop(0.35, '#FFFF99'); // å¯¾æµå±¤
                    baseGradient.addColorStop(0.55, '#FFEE66'); // å…‰çƒä¸‹å±¤
                    baseGradient.addColorStop(0.75, '#FFDD44'); // å…‰çƒä¸Šå±¤
                    baseGradient.addColorStop(0.90, '#FFCC22'); // å½©å±¤
                    baseGradient.addColorStop(1, '#FFB800');    // è¡¨é¢
                    ctx.fillStyle = baseGradient;
                    ctx.fillRect(0, 0, size, size);
                    
                    // å¯¾æµã‚»ãƒ«ï¼ˆã‚¹ãƒ¼ãƒ‘ãƒ¼ã‚°ãƒ©ãƒ‹ãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
                    for(let i = 0; i < 80; i++) {
                        const cellX = Math.random() * size;
                        const cellY = Math.random() * size;
                        const cellRadius = 30 + Math.random() * 80;
                        const cellGradient = ctx.createRadialGradient(cellX, cellY, 0, cellX, cellY, cellRadius);
                        cellGradient.addColorStop(0, `rgba(255, ${240 + Math.random() * 15}, ${180 + Math.random() * 40}, 0.6)`);
                        cellGradient.addColorStop(0.7, `rgba(255, ${220 + Math.random() * 20}, ${160 + Math.random() * 40}, 0.3)`);
                        cellGradient.addColorStop(1, 'rgba(255, 200, 140, 0)');
                        ctx.fillStyle = cellGradient;
                        ctx.beginPath();
                        ctx.arc(cellX, cellY, cellRadius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // å¤ªé™½é»’ç‚¹
                    for(let i = 0; i < 8; i++) {
                        const spotX = centerX + (Math.random() - 0.5) * size * 0.6;
                        const spotY = centerY + (Math.random() - 0.5) * size * 0.6;
                        const spotSize = 8 + Math.random() * 25;
                        
                        // é»’ç‚¹ã®å½±ã®éƒ¨åˆ†
                        const umbraGradient = ctx.createRadialGradient(spotX, spotY, 0, spotX, spotY, spotSize * 0.4);
                        umbraGradient.addColorStop(0, 'rgba(20, 10, 5, 0.9)');
                        umbraGradient.addColorStop(1, 'rgba(50, 25, 15, 0.6)');
                        ctx.fillStyle = umbraGradient;
                        ctx.beginPath();
                        ctx.arc(spotX, spotY, spotSize * 0.4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // é»’ç‚¹ã®åŠå½±
                        const penumbraGradient = ctx.createRadialGradient(spotX, spotY, spotSize * 0.4, spotX, spotY, spotSize);
                        penumbraGradient.addColorStop(0, 'rgba(80, 40, 25, 0.5)');
                        penumbraGradient.addColorStop(1, 'rgba(120, 80, 50, 0)');
                        ctx.fillStyle = penumbraGradient;
                        ctx.beginPath();
                        ctx.arc(spotX, spotY, spotSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // é«˜å“è³ªãªç²’çŠ¶æ–‘
                    for(let i = 0; i < 500; i++) {
                        const granuleX = Math.random() * size;
                        const granuleY = Math.random() * size;
                        const granuleSize = 1 + Math.random() * 4;
                        const brightness = 220 + Math.random() * 35;
                        
                        ctx.fillStyle = `rgba(255, ${brightness}, ${brightness * 0.7}, ${0.3 + Math.random() * 0.4})`;
                        ctx.beginPath();
                        ctx.arc(granuleX, granuleY, granuleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // å¤ªé™½ãƒ•ãƒ¬ã‚¢ï¼ˆãƒ—ãƒ­ãƒŸãƒãƒ³ã‚¹ï¼‰
                    for(let i = 0; i < 20; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = radius * (0.85 + Math.random() * 0.1);
                        const flareX = centerX + Math.cos(angle) * distance;
                        const flareY = centerY + Math.sin(angle) * distance;
                        const flareLength = 30 + Math.random() * 80;
                        const flareWidth = 2 + Math.random() * 6;
                        
                        // ãƒ•ãƒ¬ã‚¢ã®è»Œè·¡ã‚’æã
                        ctx.strokeStyle = `rgba(255, ${240 + Math.random() * 15}, ${150 + Math.random() * 50}, ${0.6 + Math.random() * 0.4})`;
                        ctx.lineWidth = flareWidth;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(flareX, flareY);
                        
                        // æ›²ç·šçš„ãªãƒ•ãƒ¬ã‚¢
                        for(let j = 0; j < 5; j++) {
                            const t = j / 4;
                            const currentAngle = angle + (Math.random() - 0.5) * 0.3;
                            const currentDistance = distance + flareLength * t * (1 + Math.random() * 0.3);
                            const x = centerX + Math.cos(currentAngle) * currentDistance;
                            const y = centerY + Math.sin(currentAngle) * currentDistance;
                            ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                    }
                    
                    // å…‰çƒé¢ã®ãƒ‡ã‚£ãƒ†ãƒ¼ãƒ«
                    for(let i = 0; i < 100; i++) {
                        const detailX = Math.random() * size;
                        const detailY = Math.random() * size;
                        const detailSize = 3 + Math.random() * 12;
                        
                        const detailGradient = ctx.createRadialGradient(detailX, detailY, 0, detailX, detailY, detailSize);
                        detailGradient.addColorStop(0, `rgba(255, 255, ${200 + Math.random() * 55}, 0.4)`);
                        detailGradient.addColorStop(1, `rgba(255, 255, ${200 + Math.random() * 55}, 0)`);
                        ctx.fillStyle = detailGradient;
                        ctx.beginPath();
                        ctx.arc(detailX, detailY, detailSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                    
                case 'earth':
                    // è¶…é«˜å“è³ªãªåœ°çƒãƒ†ã‚¯ã‚¹ãƒãƒ£
                    // æµ·æ´‹ã®è©³ç´°ãªãƒ™ãƒ¼ã‚¹
                    const oceanGradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                    oceanGradient.addColorStop(0, '#4D79A4');    // æ·±æµ·
                    oceanGradient.addColorStop(0.4, '#5B8BC7');  // ä¸­é–“ã®æµ·
                    oceanGradient.addColorStop(0.7, '#6BA6E8');  // æµ…æµ·
                    oceanGradient.addColorStop(0.85, '#7AB5F0'); // è¿‘æµ·
                    oceanGradient.addColorStop(1, '#4A7BA7');    // æµ·å²¸ç·š
                    ctx.fillStyle = oceanGradient;
                    ctx.fillRect(0, 0, size, size);
                    
                    // æµ·æµãƒ‘ã‚¿ãƒ¼ãƒ³
                    ctx.strokeStyle = 'rgba(100, 150, 200, 0.3)';
                    ctx.lineWidth = 3;
                    for(let i = 0; i < 15; i++) {
                        ctx.beginPath();
                        const startX = Math.random() * size;
                        const startY = Math.random() * size;
                        ctx.moveTo(startX, startY);
                        for(let j = 1; j <= 10; j++) {
                            const x = startX + j * 20 + Math.sin(j * 0.5) * 30;
                            const y = startY + (Math.random() - 0.5) * 10;
                            ctx.lineTo(x % size, y);
                        }
                        ctx.stroke();
                    }
                    
                    // è¶…è©³ç´°ãªå¤§é™¸é…ç½®ï¼ˆå®Ÿéš›ã®åœ°çƒã«è¿‘ã„å½¢çŠ¶ï¼‰
                    const continents = [
                        // ãƒ¦ãƒ¼ãƒ©ã‚·ã‚¢å¤§é™¸ï¼ˆè©³ç´°åˆ†å‰²ï¼‰
                        {name: 'europe', x: size*0.45, y: size*0.3, w: 80, h: 60, rotation: 0},
                        {name: 'asia', x: size*0.6, y: size*0.35, w: 200, h: 120, rotation: 0.1},
                        {name: 'siberia', x: size*0.55, y: size*0.25, w: 180, h: 80, rotation: 0},
                        {name: 'india', x: size*0.6, y: size*0.48, w: 50, h: 70, rotation: -0.2},
                        {name: 'china', x: size*0.65, y: size*0.35, w: 90, h: 80, rotation: 0},
                        
                        // ã‚¢ãƒ•ãƒªã‚«å¤§é™¸ï¼ˆè©³ç´°ï¼‰
                        {name: 'africa', x: size*0.48, y: size*0.55, w: 85, h: 160, rotation: 0.05},
                        {name: 'madagascar', x: size*0.55, y: size*0.65, w: 12, h: 30, rotation: 0},
                        
                        // åŒ—ç±³å¤§é™¸
                        {name: 'north_america', x: size*0.2, y: size*0.35, w: 130, h: 170, rotation: 0.1},
                        {name: 'greenland', x: size*0.35, y: size*0.15, w: 50, h: 80, rotation: 0.3},
                        
                        // å—ç±³å¤§é™¸
                        {name: 'south_america', x: size*0.3, y: size*0.7, w: 70, h: 140, rotation: -0.1},
                        
                        // ã‚ªã‚»ã‚¢ãƒ‹ã‚¢
                        {name: 'australia', x: size*0.78, y: size*0.7, w: 80, h: 50, rotation: 0},
                        {name: 'new_zealand', x: size*0.85, y: size*0.78, w: 15, h: 25, rotation: 0},
                        
                        // è«¸å³¶
                        {name: 'japan', x: size*0.72, y: size*0.38, w: 25, h: 35, rotation: 0.2},
                        {name: 'uk', x: size*0.42, y: size*0.28, w: 20, h: 25, rotation: 0},
                        {name: 'indonesia', x: size*0.72, y: size*0.55, w: 60, h: 20, rotation: 0}
                    ];
                    
                    continents.forEach(continent => {
                        ctx.save();
                        ctx.translate(continent.x, continent.y);
                        ctx.rotate(continent.rotation);
                        
                        // å¤§é™¸æ£šï¼ˆæµ…æµ·ï¼‰
                        ctx.fillStyle = 'rgba(120, 180, 220, 0.6)';
                        ctx.beginPath();
                        ctx.ellipse(0, 0, continent.w/2 * 1.2, continent.h/2 * 1.2, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // åœ°å½¢ã«ã‚ˆã‚‹è‰²åˆ†ã‘
                        let terrainColors = {
                            desert: '#D2B48C',
                            forest: '#228B22',
                            mountain: '#8B7355',
                            plain: '#9ACD32',
                            tundra: '#B0C4DE'
                        };
                        
                        // åŸºæœ¬åœ°å½¢
                        ctx.fillStyle = terrainColors.plain;
                        if(['africa', 'australia'].includes(continent.name)) ctx.fillStyle = terrainColors.desert;
                        if(['siberia', 'greenland'].includes(continent.name)) ctx.fillStyle = terrainColors.tundra;
                        if(['south_america', 'asia'].includes(continent.name)) ctx.fillStyle = terrainColors.forest;
                        
                        ctx.beginPath();
                        ctx.ellipse(0, 0, continent.w/2, continent.h/2, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // å±±è„ˆã‚·ã‚¹ãƒ†ãƒ 
                        ctx.fillStyle = terrainColors.mountain;
                        const mountainRanges = Math.floor(continent.w * continent.h / 3000) + 1;
                        for(let i = 0; i < mountainRanges; i++) {
                            const mx = (Math.random() - 0.5) * continent.w * 0.7;
                            const my = (Math.random() - 0.5) * continent.h * 0.7;
                            const mw = 10 + Math.random() * 20;
                            const mh = 5 + Math.random() * 10;
                            ctx.beginPath();
                            ctx.ellipse(mx, my, mw, mh, Math.random() * Math.PI, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // æ²³å·ã‚·ã‚¹ãƒ†ãƒ 
                        ctx.strokeStyle = 'rgba(100, 150, 255, 0.8)';
                        ctx.lineWidth = 2;
                        const riverCount = Math.floor(continent.w * continent.h / 5000) + 1;
                        for(let i = 0; i < riverCount; i++) {
                            ctx.beginPath();
                            const startX = (Math.random() - 0.5) * continent.w * 0.6;
                            const startY = (Math.random() - 0.5) * continent.h * 0.6;
                            ctx.moveTo(startX, startY);
                            
                            for(let j = 1; j <= 8; j++) {
                                const x = startX + j * 8 + (Math.random() - 0.5) * 10;
                                const y = startY + j * 5 + (Math.random() - 0.5) * 10;
                                ctx.lineTo(x, y);
                            }
                            ctx.stroke();
                        }
                        
                        // éƒ½å¸‚ã®å…‰ï¼ˆä¸»è¦éƒ½å¸‚ï¼‰
                        if(!['greenland', 'madagascar', 'antarctica'].includes(continent.name)) {
                            ctx.fillStyle = 'rgba(255, 255, 150, 0.8)';
                            const cityCount = Math.floor(continent.w * continent.h / 8000) + 1;
                            for(let i = 0; i < cityCount; i++) {
                                const cityX = (Math.random() - 0.5) * continent.w * 0.6;
                                const cityY = (Math.random() - 0.5) * continent.h * 0.6;
                                ctx.beginPath();
                                ctx.arc(cityX, cityY, 1 + Math.random() * 2, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                        
                        ctx.restore();
                    });
                    
                    // æ¥µåœ°ã®æ°·ï¼ˆã‚ˆã‚Šè©³ç´°ï¼‰
                    // åŒ—æ¥µ
                    const northIceGradient = ctx.createRadialGradient(size/2, 30, 0, size/2, 30, 60);
                    northIceGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    northIceGradient.addColorStop(0.6, 'rgba(240, 248, 255, 0.9)');
                    northIceGradient.addColorStop(1, 'rgba(200, 220, 255, 0.3)');
                    ctx.fillStyle = northIceGradient;
                    ctx.beginPath();
                    ctx.arc(size/2, 30, 60, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // å—æ¥µ
                    const southIceGradient = ctx.createRadialGradient(size/2, size-30, 0, size/2, size-30, 80);
                    southIceGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    southIceGradient.addColorStop(0.5, 'rgba(240, 248, 255, 0.95)');
                    southIceGradient.addColorStop(1, 'rgba(200, 220, 255, 0.4)');
                    ctx.fillStyle = southIceGradient;
                    ctx.beginPath();
                    ctx.arc(size/2, size-30, 80, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // é«˜å“è³ªãªé›²ã‚·ã‚¹ãƒ†ãƒ 
                    ctx.globalAlpha = 0.7;
                    for(let i = 0; i < 60; i++) {
                        const cloudX = Math.random() * size;
                        const cloudY = Math.random() * size;
                        const cloudSize = 15 + Math.random() * 50;
                        const cloudType = Math.random();
                        
                        let cloudColor;
                        if(cloudType < 0.6) {
                            // æ™®é€šã®é›²
                            cloudColor = 'rgba(255, 255, 255, 0.8)';
                        } else if(cloudType < 0.8) {
                            // è–„ã„é›²
                            cloudColor = 'rgba(250, 250, 255, 0.5)';
                        } else {
                            // åšã„é›²
                            cloudColor = 'rgba(240, 240, 240, 0.9)';
                        }
                        
                        const cloudGradient = ctx.createRadialGradient(cloudX, cloudY, 0, cloudX, cloudY, cloudSize);
                        cloudGradient.addColorStop(0, cloudColor);
                        cloudGradient.addColorStop(0.7, cloudColor.replace(/[\d.]+\)$/g, '0.3)'));
                        cloudGradient.addColorStop(1, cloudColor.replace(/[\d.]+\)$/g, '0)'));
                        
                        ctx.fillStyle = cloudGradient;
                        ctx.beginPath();
                        ctx.arc(cloudX, cloudY, cloudSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                    
                    // å¤§æ°—ã®æ•£ä¹±åŠ¹æœ
                    const earthAtmosphereGradient = ctx.createRadialGradient(size/2, size/2, size/2 * 0.8, size/2, size/2, size/2);
                    earthAtmosphereGradient.addColorStop(0, 'rgba(135, 206, 250, 0)');
                    earthAtmosphereGradient.addColorStop(1, 'rgba(100, 149, 237, 0.3)');
                    ctx.fillStyle = earthAtmosphereGradient;
                    ctx.fillRect(0, 0, size, size);
                    break;
                    
                case 'mars':
                    // è¶…é«˜å“è³ªãªç«æ˜Ÿãƒ†ã‚¯ã‚¹ãƒãƒ£
                    // åœ°å½¢ã«ã‚ˆã‚‹è‰²åˆ†ã‘ãƒ™ãƒ¼ã‚¹
                    const marsBase = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                    marsBase.addColorStop(0, '#D2691E');    // ä¸­å¤®éƒ¨
                    marsBase.addColorStop(0.3, '#CD853F');  // ä¸­é–“åœ°å¸¯
                    marsBase.addColorStop(0.6, '#B8860B');  // å¤–ç¸éƒ¨
                    marsBase.addColorStop(0.8, '#8B4513');  // ç¸
                    marsBase.addColorStop(1, '#654321');    // æœ€å¤–ç¸
                    ctx.fillStyle = marsBase;
                    ctx.fillRect(0, 0, size, size);
                    
                    // åœ°å½¢ã®è©³ç´°ãƒ¬ã‚¤ãƒ¤ãƒ¼
                    // å¤ä»£ã®è¡çªã‚¯ãƒ¬ãƒ¼ã‚¿ãƒ¼ï¼ˆå¤šæ•°ï¼‰
                    for(let i = 0; i < 50; i++) {
                        const craterX = Math.random() * size;
                        const craterY = Math.random() * size;
                        const craterSize = 3 + Math.random() * 25;
                        
                        // ã‚¯ãƒ¬ãƒ¼ã‚¿ãƒ¼ã®ç¸ï¼ˆéš†èµ·ï¼‰
                        ctx.fillStyle = `rgba(${160 + Math.random() * 40}, ${110 + Math.random() * 30}, ${70 + Math.random() * 20}, 0.6)`;
                        ctx.beginPath();
                        ctx.arc(craterX, craterY, craterSize, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ã‚¯ãƒ¬ãƒ¼ã‚¿ãƒ¼ã®åº•ï¼ˆãã¼ã¿ï¼‰
                        ctx.fillStyle = `rgba(${100 + Math.random() * 30}, ${60 + Math.random() * 25}, ${40 + Math.random() * 15}, 0.8)`;
                        ctx.beginPath();
                        ctx.arc(craterX, craterY, craterSize * 0.6, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // å·¨å¤§ãªã‚ªãƒªãƒ³ãƒã‚¹å±±ï¼ˆå¤ªé™½ç³»æœ€å¤§ã®ç«å±±ï¼‰
                    const olympusX = size * 0.25;
                    const olympusY = size * 0.35;
                    const olympusSize = 35;
                    
                    // ã‚ªãƒªãƒ³ãƒã‚¹å±±ã®å½±ã¨ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                    ctx.fillStyle = 'rgba(80, 50, 30, 0.7)';
                    ctx.beginPath();
                    ctx.arc(olympusX + 2, olympusY + 2, olympusSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ã‚ªãƒªãƒ³ãƒã‚¹å±±ã®ãƒ¡ã‚¤ãƒ³
                    const olympusGradient = ctx.createRadialGradient(olympusX, olympusY, 0, olympusX, olympusY, olympusSize);
                    olympusGradient.addColorStop(0, '#D2B48C');   // é ‚ä¸Šï¼ˆæ˜ã‚‹ã„ï¼‰
                    olympusGradient.addColorStop(0.3, '#CD853F'); // ä¸­è…¹
                    olympusGradient.addColorStop(0.6, '#A0522D'); // ä¸‹éƒ¨
                    olympusGradient.addColorStop(1, '#8B4513');   // éº“
                    ctx.fillStyle = olympusGradient;
                    ctx.beginPath();
                    ctx.arc(olympusX, olympusY, olympusSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ã‚ªãƒªãƒ³ãƒã‚¹å±±ã®ã‚«ãƒ«ãƒ‡ãƒ©
                    ctx.fillStyle = 'rgba(100, 60, 40, 0.8)';
                    ctx.beginPath();
                    ctx.arc(olympusX, olympusY, olympusSize * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ä»–ã®ä¸»è¦ç«å±±
                    const volcanoes = [
                        {name: 'Arsia Mons', x: size*0.28, y: size*0.55, size: 18},
                        {name: 'Pavonis Mons', x: size*0.25, y: size*0.5, size: 16},
                        {name: 'Ascraeus Mons', x: size*0.23, y: size*0.45, size: 17}
                    ];
                    
                    volcanoes.forEach(volcano => {
                        const volcGradient = ctx.createRadialGradient(volcano.x, volcano.y, 0, volcano.x, volcano.y, volcano.size);
                        volcGradient.addColorStop(0, '#CD853F');
                        volcGradient.addColorStop(0.7, '#A0522D');
                        volcGradient.addColorStop(1, '#8B4513');
                        ctx.fillStyle = volcGradient;
                        ctx.beginPath();
                        ctx.arc(volcano.x, volcano.y, volcano.size, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // ãƒ´ã‚¡ãƒ¬ã‚¹ãƒ»ãƒãƒªãƒãƒªã‚¹ï¼ˆå·¨å¤§å³¡è°·ï¼‰
                    ctx.strokeStyle = 'rgba(120, 80, 50, 0.8)';
                    ctx.lineWidth = 8;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(size * 0.1, size * 0.5);
                    ctx.quadraticCurveTo(size * 0.4, size * 0.45, size * 0.7, size * 0.5);
                    ctx.stroke();
                    
                    // å³¡è°·ã®æ”¯æµ
                    ctx.lineWidth = 4;
                    for(let i = 0; i < 8; i++) {
                        const branchX = size * (0.2 + i * 0.08);
                        const branchY = size * (0.48 + (Math.random() - 0.5) * 0.1);
                        ctx.beginPath();
                        ctx.moveTo(branchX, branchY);
                        ctx.lineTo(branchX + (Math.random() - 0.5) * 40, branchY + (Math.random() - 0.5) * 30);
                        ctx.stroke();
                    }
                    
                    // å¤ä»£ã®æ°´ã®ç—•è·¡ï¼ˆä¹¾ã„ãŸæ²³åºŠï¼‰
                    ctx.strokeStyle = 'rgba(150, 100, 70, 0.5)';
                    ctx.lineWidth = 2;
                    for(let i = 0; i < 20; i++) {
                        ctx.beginPath();
                        const startX = Math.random() * size;
                        const startY = Math.random() * size;
                        ctx.moveTo(startX, startY);
                        
                        for(let j = 1; j <= 10; j++) {
                            const x = startX + j * 8 + (Math.random() - 0.5) * 15;
                            const y = startY + j * 5 + (Math.random() - 0.5) * 10;
                            ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                    }
                    
                    // ç ‚åµã®ç—•è·¡
                    for(let i = 0; i < 30; i++) {
                        const dustX = Math.random() * size;
                        const dustY = Math.random() * size;
                        const dustSize = 5 + Math.random() * 20;
                        
                        const dustGradient = ctx.createRadialGradient(dustX, dustY, 0, dustX, dustY, dustSize);
                        dustGradient.addColorStop(0, `rgba(${200 + Math.random() * 35}, ${140 + Math.random() * 30}, ${90 + Math.random() * 20}, 0.3)`);
                        dustGradient.addColorStop(1, `rgba(${200 + Math.random() * 35}, ${140 + Math.random() * 30}, ${90 + Math.random() * 20}, 0)`);
                        
                        ctx.fillStyle = dustGradient;
                        ctx.beginPath();
                        ctx.arc(dustX, dustY, dustSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // æ¥µå† ï¼ˆå­£ç¯€ã«ã‚ˆã‚Šå¤‰åŒ–ã™ã‚‹æ°·ï¼‰
                    // åŒ—æ¥µå† 
                    const northCapGradient = ctx.createRadialGradient(size/2, 15, 0, size/2, 15, 50);
                    northCapGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');     // ä¸­å¤®ï¼ˆç´”ç²‹ãªæ°·ï¼‰
                    northCapGradient.addColorStop(0.4, 'rgba(240, 248, 255, 0.9)'); // ä¸­é–“ï¼ˆæ°·ã¨å¡µã®æ··åˆï¼‰
                    northCapGradient.addColorStop(0.7, 'rgba(220, 230, 240, 0.7)'); // å¤–ç¸ï¼ˆè–„ã„æ°·ï¼‰
                    northCapGradient.addColorStop(1, 'rgba(200, 210, 220, 0.3)');   // æœ€å¤–ç¸ï¼ˆéœœï¼‰
                    ctx.fillStyle = northCapGradient;
                    ctx.beginPath();
                    ctx.arc(size/2, 15, 50, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // å—æ¥µå† ï¼ˆã‚ˆã‚Šå°ã•ãã€ä¸è¦å‰‡ï¼‰
                    const southCapGradient = ctx.createRadialGradient(size/2, size-15, 0, size/2, size-15, 40);
                    southCapGradient.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
                    southCapGradient.addColorStop(0.5, 'rgba(240, 248, 255, 0.8)');
                    southCapGradient.addColorStop(1, 'rgba(220, 230, 240, 0.4)');
                    ctx.fillStyle = southCapGradient;
                    ctx.beginPath();
                    ctx.arc(size/2, size-15, 40, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // æ¥µå† ã®å±¤çŠ¶æ§‹é€ 
                    ctx.strokeStyle = 'rgba(200, 220, 240, 0.6)';
                    ctx.lineWidth = 1;
                    for(let i = 1; i <= 5; i++) {
                        ctx.beginPath();
                        ctx.arc(size/2, 15, 10 * i, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.arc(size/2, size-15, 8 * i, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    // å¤§æ°—ã®è–„ã„ãƒ˜ã‚¤ã‚ºåŠ¹æœ
                    const marsAtmosphereGradient = ctx.createRadialGradient(size/2, size/2, size/2 * 0.7, size/2, size/2, size/2);
                    marsAtmosphereGradient.addColorStop(0, 'rgba(255, 200, 150, 0)');
                    marsAtmosphereGradient.addColorStop(1, 'rgba(200, 120, 80, 0.2)');
                    ctx.fillStyle = marsAtmosphereGradient;
                    ctx.fillRect(0, 0, size, size);
                    break;
                    
                case 'jupiter':
                    // è¶…é«˜å“è³ªãªæœ¨æ˜Ÿãƒ†ã‚¯ã‚¹ãƒãƒ£
                    // å¤§æ°—å±¤ã®è©³ç´°ãªãƒ™ãƒ¼ã‚¹
                    const jupiterBase = ctx.createLinearGradient(0, 0, 0, size);
                    jupiterBase.addColorStop(0, '#FFEEDD');   // æ¥µåŸŸï¼ˆæ˜ã‚‹ã„ã‚¯ãƒªãƒ¼ãƒ ï¼‰
                    jupiterBase.addColorStop(0.1, '#F4E4BC'); // é«˜ç·¯åº¦å¸¯
                    jupiterBase.addColorStop(0.2, '#E6B87D'); // æ¸©å¸¯
                    jupiterBase.addColorStop(0.3, '#D2691E'); // äºœç†±å¸¯
                    jupiterBase.addColorStop(0.4, '#CD853F'); // ç†±å¸¯åŒ—
                    jupiterBase.addColorStop(0.5, '#B8860B'); // èµ¤é“å¸¯
                    jupiterBase.addColorStop(0.6, '#A0522D'); // ç†±å¸¯å—
                    jupiterBase.addColorStop(0.7, '#8B4513'); // äºœç†±å¸¯å—
                    jupiterBase.addColorStop(0.8, '#654321'); // æ¸©å¸¯å—
                    jupiterBase.addColorStop(0.9, '#4A2C17'); // é«˜ç·¯åº¦å—
                    jupiterBase.addColorStop(1, '#3A1F10');   // å—æ¥µåŸŸ
                    ctx.fillStyle = jupiterBase;
                    ctx.fillRect(0, 0, size, size);
                    
                    // è¶…è©³ç´°ãªç¸æ¨¡æ§˜ã‚·ã‚¹ãƒ†ãƒ 
                    for(let i = 0; i < 60; i++) {
                        const y = (i / 60) * size;
                        const beltHeight = 6 + Math.random() * 30;
                        const opacity = 0.15 + Math.random() * 0.6;
                        const turbulence = Math.sin(i * 0.4) * 0.3;
                        
                        // å¸¯ã®ç¨®é¡ã«ã‚ˆã‚‹è‰²åˆ†ã‘
                        let beltColor;
                        const beltType = i % 4;
                        if(beltType === 0) {
                            // æ˜ã‚‹ã„å¸¯ï¼ˆZoneï¼‰
                            beltColor = `rgba(${240 + Math.random() * 15}, ${200 + Math.random() * 30}, ${140 + Math.random() * 20}, ${opacity})`;
                        } else if(beltType === 1) {
                            // æš—ã„å¸¯ï¼ˆBeltï¼‰
                            beltColor = `rgba(${160 + Math.random() * 30}, ${110 + Math.random() * 25}, ${70 + Math.random() * 20}, ${opacity})`;
                        } else if(beltType === 2) {
                            // ä¸­é–“ã®å¸¯
                            beltColor = `rgba(${190 + Math.random() * 25}, ${140 + Math.random() * 25}, ${90 + Math.random() * 20}, ${opacity})`;
                        } else {
                            // ç‰¹æ®Šãªå¸¯ï¼ˆèµ¤ã¿ãŒã‹ã£ãŸï¼‰
                            beltColor = `rgba(${200 + Math.random() * 30}, ${130 + Math.random() * 30}, ${80 + Math.random() * 25}, ${opacity})`;
                        }
                        
                        ctx.fillStyle = beltColor;
                        
                        // è¤‡é›‘ãªæ³¢æ‰“ã¤ç¸æ¨¡æ§˜
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        for(let x = 0; x <= size; x += 8) {
                            const primaryWave = Math.sin(x * 0.025 + i * 0.5) * (4 + turbulence * 8);
                            const secondaryWave = Math.sin(x * 0.08 + i * 0.3) * (1 + turbulence * 3);
                            const waveY = y + primaryWave + secondaryWave;
                            ctx.lineTo(x, waveY);
                        }
                        for(let x = size; x >= 0; x -= 8) {
                            const primaryWave = Math.sin(x * 0.02 + i * 0.5 + 1) * (3 + turbulence * 6);
                            const secondaryWave = Math.sin(x * 0.06 + i * 0.3 + 1) * (1.5 + turbulence * 2);
                            const waveY = y + beltHeight + primaryWave + secondaryWave;
                            ctx.lineTo(x, waveY);
                        }
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    // å¤§èµ¤æ–‘ï¼ˆè¶…è©³ç´°ï¼‰
                    const grsX = size * 0.72;
                    const grsY = size * 0.42;
                    const grsWidth = 80;
                    const grsHeight = 50;
                    
                    // å¤§èµ¤æ–‘ã®å‘¨å›²ã®ä¹±æµ
                    for(let i = 0; i < 12; i++) {
                        const angle = (i / 12) * Math.PI * 2;
                        const turbX = grsX + Math.cos(angle) * (grsWidth/2 + 20 + Math.random() * 30);
                        const turbY = grsY + Math.sin(angle) * (grsHeight/2 + 15 + Math.random() * 20);
                        const turbSize = 8 + Math.random() * 15;
                        
                        ctx.fillStyle = `rgba(${180 + Math.random() * 40}, ${100 + Math.random() * 40}, ${60 + Math.random() * 30}, 0.4)`;
                        ctx.beginPath();
                        ctx.arc(turbX, turbY, turbSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // å¤§èµ¤æ–‘ã®å½±ã¨ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                    ctx.fillStyle = 'rgba(80, 20, 10, 0.5)';
                    ctx.beginPath();
                    ctx.ellipse(grsX + 3, grsY + 3, grsWidth/2, grsHeight/2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // å¤§èµ¤æ–‘ã®ãƒ¡ã‚¤ãƒ³ï¼ˆè¤‡æ•°å±¤ï¼‰
                    const grsLayers = [
                        {color: '#DD5555', size: 1.0},
                        {color: '#CC3333', size: 0.8},
                        {color: '#BB2222', size: 0.6},
                        {color: '#AA1111', size: 0.4},
                        {color: '#990000', size: 0.2}
                    ];
                    
                    grsLayers.forEach(layer => {
                        const layerGradient = ctx.createRadialGradient(grsX, grsY, 0, grsX, grsY, (grsWidth/2) * layer.size);
                        layerGradient.addColorStop(0, layer.color);
                        layerGradient.addColorStop(0.7, layer.color + '99');
                        layerGradient.addColorStop(1, layer.color + '00');
                        ctx.fillStyle = layerGradient;
                        ctx.beginPath();
                        ctx.ellipse(grsX, grsY, (grsWidth/2) * layer.size, (grsHeight/2) * layer.size, 0, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // å¤§èµ¤æ–‘ã®è©³ç´°ãªæ¸¦å·»ãæ§‹é€ 
                    ctx.strokeStyle = 'rgba(180, 80, 80, 0.7)';
                    ctx.lineWidth = 1.5;
                    for(let i = 0; i < 5; i++) {
                        ctx.beginPath();
                        const spiralRadius = 10 + i * 12;
                        for(let angle = 0; angle < Math.PI * 6; angle += 0.08) {
                            const currentRadius = spiralRadius * (1 - angle / (Math.PI * 6)) * 0.9;
                            const x = grsX + Math.cos(angle + i * 0.5) * currentRadius;
                            const y = grsY + Math.sin(angle + i * 0.5) * currentRadius * 0.6;
                            if(angle === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                    }
                    
                    // å°ã•ãªåµã‚·ã‚¹ãƒ†ãƒ ï¼ˆè¤‡æ•°ã®ã‚µã‚¤ã‚ºï¼‰
                    for(let i = 0; i < 25; i++) {
                        const stormX = Math.random() * size;
                        const stormY = Math.random() * size;
                        const stormSize = 4 + Math.random() * 20;
                        const stormIntensity = Math.random();
                        
                        let stormColor;
                        if(stormIntensity > 0.8) {
                            // å¼·ã„åµï¼ˆç™½è‰²ï¼‰
                            stormColor = `rgba(${240 + Math.random() * 15}, ${220 + Math.random() * 20}, ${180 + Math.random() * 30}, 0.7)`;
                        } else if(stormIntensity > 0.5) {
                            // ä¸­ç¨‹åº¦ã®åµï¼ˆèŒ¶è‰²ï¼‰
                            stormColor = `rgba(${160 + Math.random() * 40}, ${120 + Math.random() * 30}, ${80 + Math.random() * 25}, 0.5)`;
                        } else {
                            // å¼±ã„åµï¼ˆæš—ã„ï¼‰
                            stormColor = `rgba(${120 + Math.random() * 30}, ${90 + Math.random() * 25}, ${60 + Math.random() * 20}, 0.3)`;
                        }
                        
                        const stormGradient = ctx.createRadialGradient(stormX, stormY, 0, stormX, stormY, stormSize);
                        stormGradient.addColorStop(0, stormColor);
                        stormGradient.addColorStop(0.6, stormColor.replace(/[\d.]+\)$/g, '0.2)'));
                        stormGradient.addColorStop(1, stormColor.replace(/[\d.]+\)$/g, '0)'));
                        
                        ctx.fillStyle = stormGradient;
                        ctx.beginPath();
                        ctx.arc(stormX, stormY, stormSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // å¤§æ°—ã®ä¹±æµãƒ‘ã‚¿ãƒ¼ãƒ³
                    ctx.strokeStyle = 'rgba(200, 150, 100, 0.2)';
                    ctx.lineWidth = 1;
                    for(let i = 0; i < 40; i++) {
                        ctx.beginPath();
                        const startX = Math.random() * size;
                        const startY = Math.random() * size;
                        ctx.moveTo(startX, startY);
                        
                        for(let j = 1; j <= 15; j++) {
                            const x = startX + j * 10 + Math.sin(j * 0.3) * 15;
                            const y = startY + (Math.random() - 0.5) * 8;
                            ctx.lineTo(x % size, y);
                        }
                        ctx.stroke();
                    }
                    break;
                    
                case 'mercury':
                    // æ°´æ˜Ÿï¼šæ¥µç«¯ãªæ¸©åº¦å·®ã‚’æŒã¤ã‚¯ãƒ¬ãƒ¼ã‚¿ãƒ¼ã ã‚‰ã‘ã®ä¸–ç•Œ
                    const mercuryBase = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                    mercuryBase.addColorStop(0, '#C0C0C0'); // æ˜ã‚‹ã„ä¸­å¤®
                    mercuryBase.addColorStop(0.5, '#8C7853'); // èŒ¶è‰²ãŒã‹ã£ãŸ
                    mercuryBase.addColorStop(1, '#696969'); // æš—ã„ç¸
                    ctx.fillStyle = mercuryBase;
                    ctx.fillRect(0, 0, size, size);
                    
                    // ã‚«ãƒ­ãƒªã‚¹ç›†åœ°ï¼ˆå·¨å¤§è¡çªã‚¯ãƒ¬ãƒ¼ã‚¿ãƒ¼ï¼‰
                    const calorisX = size * 0.6;
                    const calorisY = size * 0.4;
                    const calorisSize = 60;
                    
                    ctx.fillStyle = 'rgba(120, 120, 120, 0.7)';
                    ctx.beginPath();
                    ctx.arc(calorisX, calorisY, calorisSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'rgba(80, 80, 80, 0.8)';
                    ctx.beginPath();
                    ctx.arc(calorisX, calorisY, calorisSize * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // å¤šæ•°ã®å°ã‚¯ãƒ¬ãƒ¼ã‚¿ãƒ¼
                    for(let i = 0; i < 80; i++) {
                        const craterX = Math.random() * size;
                        const craterY = Math.random() * size;
                        const craterSize = 2 + Math.random() * 15;
                        
                        ctx.fillStyle = `rgba(${100 + Math.random() * 50}, ${100 + Math.random() * 50}, ${100 + Math.random() * 50}, 0.6)`;
                        ctx.beginPath();
                        ctx.arc(craterX, craterY, craterSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                    
                case 'venus':
                    // é‡‘æ˜Ÿï¼šåšã„é›²ã«è¦†ã‚ã‚ŒãŸç¼ç†±ã®ä¸–ç•Œ
                    const venusBase = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                    venusBase.addColorStop(0, '#FFF8DC'); // æ˜ã‚‹ã„ã‚¯ãƒªãƒ¼ãƒ 
                    venusBase.addColorStop(0.4, '#F5DEB3'); // ãƒ™ãƒ¼ã‚¸ãƒ¥
                    venusBase.addColorStop(0.7, '#DEB887'); // ã‚ˆã‚Šæ¿ƒã„ãƒ™ãƒ¼ã‚¸ãƒ¥
                    venusBase.addColorStop(1, '#D2B48C'); // èŒ¶è‰²ãŒã‹ã£ãŸãƒ™ãƒ¼ã‚¸ãƒ¥
                    ctx.fillStyle = venusBase;
                    ctx.fillRect(0, 0, size, size);
                    
                    // ç¡«é…¸ã®é›²å±¤
                    for(let i = 0; i < 100; i++) {
                        const cloudX = Math.random() * size;
                        const cloudY = Math.random() * size;
                        const cloudSize = 10 + Math.random() * 40;
                        
                        const venusCloudGradient = ctx.createRadialGradient(cloudX, cloudY, 0, cloudX, cloudY, cloudSize);
                        venusCloudGradient.addColorStop(0, `rgba(${250 + Math.random() * 5}, ${240 + Math.random() * 10}, ${200 + Math.random() * 20}, 0.6)`);
                        venusCloudGradient.addColorStop(1, `rgba(${250 + Math.random() * 5}, ${240 + Math.random() * 10}, ${200 + Math.random() * 20}, 0)`);
                        
                        ctx.fillStyle = venusCloudGradient;
                        ctx.beginPath();
                        ctx.arc(cloudX, cloudY, cloudSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // å¤§æ°—ã®æ¸¦å·»ããƒ‘ã‚¿ãƒ¼ãƒ³
                    for(let i = 0; i < 20; i++) {
                        ctx.strokeStyle = `rgba(${230 + Math.random() * 20}, ${220 + Math.random() * 20}, ${180 + Math.random() * 30}, 0.4)`;
                        ctx.lineWidth = 2 + Math.random() * 3;
                        ctx.beginPath();
                        
                        const centerX = Math.random() * size;
                        const centerY = Math.random() * size;
                        for(let angle = 0; angle < Math.PI * 4; angle += 0.2) {
                            const radius = angle * 3;
                            const x = centerX + Math.cos(angle) * radius;
                            const y = centerY + Math.sin(angle) * radius;
                            if(angle === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                    }
                    break;
                    
                case 'saturn':
                    // åœŸæ˜Ÿï¼šç¾ã—ã„ãƒªãƒ³ã‚°ã¨ç¸æ¨¡æ§˜
                    const saturnBase = ctx.createLinearGradient(0, 0, 0, size);
                    saturnBase.addColorStop(0, '#F5DEB3');   // æ¥µåŸŸ
                    saturnBase.addColorStop(0.2, '#DEB887'); // é«˜ç·¯åº¦
                    saturnBase.addColorStop(0.4, '#D2B48C'); // ä¸­ç·¯åº¦
                    saturnBase.addColorStop(0.6, '#BC9A6A'); // èµ¤é“åŸŸ
                    saturnBase.addColorStop(0.8, '#A0845C'); // ä¸­ç·¯åº¦å—
                    saturnBase.addColorStop(1, '#8B7355');   // æ¥µåŸŸå—
                    ctx.fillStyle = saturnBase;
                    ctx.fillRect(0, 0, size, size);
                    
                    // åœŸæ˜Ÿã®ç¸æ¨¡æ§˜ï¼ˆæœ¨æ˜Ÿã‚ˆã‚Šç©ã‚„ã‹ï¼‰
                    for(let i = 0; i < 30; i++) {
                        const y = (i / 30) * size;
                        const beltHeight = 10 + Math.random() * 20;
                        const opacity = 0.1 + Math.random() * 0.3;
                        
                        ctx.fillStyle = `rgba(${180 + Math.random() * 40}, ${150 + Math.random() * 30}, ${120 + Math.random() * 25}, ${opacity})`;
                        ctx.fillRect(0, y, size, beltHeight);
                    }
                    
                    // å…­è§’å½¢ã®åµï¼ˆåŒ—æ¥µï¼‰
                    const hexCenterX = size/2;
                    const hexCenterY = size * 0.1;
                    const hexRadius = 20;
                    
                    ctx.strokeStyle = 'rgba(200, 180, 150, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    for(let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        const x = hexCenterX + Math.cos(angle) * hexRadius;
                        const y = hexCenterY + Math.sin(angle) * hexRadius;
                        if(i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    break;
                    
                case 'uranus':
                    // å¤©ç‹æ˜Ÿï¼šæ¨ªå€’ã—ã®æ°·ã®å·¨æ˜Ÿ
                    const uranusBase = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                    uranusBase.addColorStop(0, '#87CEEB');   // æ˜ã‚‹ã„é’
                    uranusBase.addColorStop(0.4, '#4FD0E7'); // é’ç·‘
                    uranusBase.addColorStop(0.7, '#00CED1'); // ã‚¿ãƒ¼ã‚³ã‚¤ã‚º
                    uranusBase.addColorStop(1, '#008B8B');   // æ¿ƒã„ã‚¿ãƒ¼ã‚³ã‚¤ã‚º
                    ctx.fillStyle = uranusBase;
                    ctx.fillRect(0, 0, size, size);
                    
                    // ãƒ¡ã‚¿ãƒ³æ°·ã®é›²
                    for(let i = 0; i < 40; i++) {
                        const cloudX = Math.random() * size;
                        const cloudY = Math.random() * size;
                        const cloudSize = 8 + Math.random() * 25;
                        
                        ctx.fillStyle = `rgba(${150 + Math.random() * 30}, ${200 + Math.random() * 30}, ${220 + Math.random() * 35}, 0.4)`;
                        ctx.beginPath();
                        ctx.arc(cloudX, cloudY, cloudSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                    
                case 'neptune':
                    // æµ·ç‹æ˜Ÿï¼šæ·±ã„é’ã®åµã®æƒ‘æ˜Ÿ
                    const neptuneBase = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                    neptuneBase.addColorStop(0, '#6495ED');  // æ˜ã‚‹ã„é’
                    neptuneBase.addColorStop(0.4, '#4169E1'); // ãƒ­ã‚¤ãƒ¤ãƒ«ãƒ–ãƒ«ãƒ¼
                    neptuneBase.addColorStop(0.7, '#0000CD'); // ä¸­ç¨‹åº¦ã®é’
                    neptuneBase.addColorStop(1, '#000080');   // æ¿ƒç´º
                    ctx.fillStyle = neptuneBase;
                    ctx.fillRect(0, 0, size, size);
                    
                    // å¤§æš—æ–‘ï¼ˆã‹ã¤ã¦å­˜åœ¨ã—ãŸå·¨å¤§åµï¼‰
                    const darkSpotX = size * 0.3;
                    const darkSpotY = size * 0.4;
                    const darkSpotW = 40;
                    const darkSpotH = 25;
                    
                    ctx.fillStyle = 'rgba(0, 0, 100, 0.7)';
                    ctx.beginPath();
                    ctx.ellipse(darkSpotX, darkSpotY, darkSpotW, darkSpotH, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // é«˜é€Ÿé¢¨ã®ç—•è·¡
                    for(let i = 0; i < 15; i++) {
                        ctx.strokeStyle = `rgba(${100 + Math.random() * 50}, ${150 + Math.random() * 50}, ${200 + Math.random() * 55}, 0.5)`;
                        ctx.lineWidth = 2 + Math.random() * 3;
                        ctx.beginPath();
                        
                        const startX = Math.random() * size;
                        const startY = Math.random() * size;
                        ctx.moveTo(startX, startY);
                        
                        for(let j = 1; j <= 8; j++) {
                            const x = startX + j * 15;
                            const y = startY + Math.sin(j * 0.5) * 10;
                            ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                    }
                    break;
                    
                default:
                    // ãã®ä»–ã®å¤©ä½“ï¼ˆå°æƒ‘æ˜Ÿãªã©ï¼‰
                    const defaultGradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                    defaultGradient.addColorStop(0, '#AAAAAA');
                    defaultGradient.addColorStop(1, '#666666');
                    ctx.fillStyle = defaultGradient;
                    ctx.fillRect(0, 0, size, size);
            }
            
            return new THREE.CanvasTexture(canvas);
        }

        // MRãƒ¢ãƒ¼ãƒ‰ç”¨æ˜Ÿç©ºä½œæˆï¼ˆé©åº¦ã«å¢—åŠ ï¼‰
        function createStarField() {
            const starGeometry = new THREE.BufferGeometry();
            const starPositions = [];
            const starSizes = [];
            const starColors = [];
            
            for (let i = 0; i < 8000; i++) { // 5000ã‹ã‚‰8000ã«å¢—åŠ 
                starPositions.push(
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200
                );
                
                // MRãƒ¢ãƒ¼ãƒ‰ã§ã‚‚ç¾å®Ÿçš„ãªæ˜Ÿã®è‰²ã‚’é©ç”¨
                const starType = Math.random();
                if (starType < 0.1) {
                    // é’ç™½ã„æ˜Ÿ
                    starColors.push(0.9, 0.95, 1);
                    starSizes.push(Math.random() * 2.5 + 1);
                } else if (starType < 0.3) {
                    // ç™½ã„æ˜Ÿ
                    starColors.push(1, 1, 0.95);
                    starSizes.push(Math.random() * 2 + 0.8);
                } else if (starType < 0.5) {
                    // é»„è‰²ã„æ˜Ÿ
                    starColors.push(1, 0.95, 0.8);
                    starSizes.push(Math.random() * 1.8 + 0.7);
                } else if (starType < 0.7) {
                    // ã‚ªãƒ¬ãƒ³ã‚¸ã®æ˜Ÿ
                    starColors.push(1, 0.8, 0.6);
                    starSizes.push(Math.random() * 1.5 + 0.6);
                } else {
                    // èµ¤ã„æ˜Ÿ
                    starColors.push(1, 0.7, 0.5);
                    starSizes.push(Math.random() * 1.2 + 0.5);
                }
            }
            
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
            starGeometry.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));
            
            const starMaterial = new THREE.PointsMaterial({
                vertexColors: true, // è‰²æƒ…å ±ã‚’ä½¿ç”¨
                size: 0.06, // å°‘ã—å¤§ãã
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending
            });
            
            return new THREE.Points(starGeometry, starMaterial);
        }

        // å¤©ã®å·éŠ€æ²³ã®æ˜Ÿç©ºä½œæˆï¼ˆå¤§å¹…å¼·åŒ– - 50,000å€‹ã®æ˜Ÿï¼‰
        function createSpaceStarField() {
            const starGeometry = new THREE.BufferGeometry();
            const starPositions = [];
            const starColors = [];
            const starSizes = [];
            
            for (let i = 0; i < 50000; i++) { // 12,000ã‹ã‚‰50,000ã«å¤§å¹…å¢—åŠ 
                // ã‚ˆã‚Šç¾å®Ÿçš„ãªå¤©ã®å·éŠ€æ²³ã®æ§‹é€ ã‚’æ¨¡æ“¬
                let radius, x, y, z;
                
                if (i < 40000) { // 80%ãŒéŠ€æ²³å††ç›¤éƒ¨åˆ†
                    // å¤©ã®å·éŠ€æ²³ã®æ¸¦å·»ãæ§‹é€ ã‚’æ¨¡æ“¬
                    const armNum = Math.floor(Math.random() * 4); // 4æœ¬ã®æ¸¦å·»ãè…•
                    const armAngle = (armNum * Math.PI / 2) + (Math.random() - 0.5) * Math.PI / 3;
                    const spiralTightness = 0.3;
                    
                    const diskRadius = 50 + Math.random() * 250; // ã‚ˆã‚Šåºƒç¯„å›²
                    const spiralAngle = armAngle + diskRadius * spiralTightness;
                    
                    // éŠ€æ²³ä¸­å¿ƒã«å‘ã‹ã†ã»ã©æ˜Ÿå¯†åº¦ãŒé«˜ã„
                    const densityFactor = Math.exp(-diskRadius / 100);
                    if (Math.random() > densityFactor * 0.7) {
                        // æ˜Ÿå¯†åº¦ã®ä½ã„é ˜åŸŸã§ã¯ä¸€éƒ¨ã‚’ã‚¹ã‚­ãƒƒãƒ—
                        const fallbackRadius = 30 + Math.random() * 100;
                        const fallbackAngle = Math.random() * Math.PI * 2;
                        x = fallbackRadius * Math.cos(fallbackAngle);
                        z = fallbackRadius * Math.sin(fallbackAngle);
                    } else {
                        x = diskRadius * Math.cos(spiralAngle);
                        z = diskRadius * Math.sin(spiralAngle);
                    }
                    
                    // éŠ€æ²³å††ç›¤ã®åšã¿ï¼ˆç¾å®Ÿçš„ã«è–„ãï¼‰
                    const diskHeight = (Math.random() - 0.5) * Math.min(15, diskRadius * 0.05);
                    y = diskHeight;
                    
                } else if (i < 45000) { // 10%ãŒãƒãƒ­ãƒ¼éƒ¨åˆ†
                    // éŠ€æ²³ãƒãƒ­ãƒ¼ï¼ˆçƒçŠ¶åˆ†å¸ƒï¼‰
                    radius = 200 + Math.random() * 150;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    x = radius * Math.sin(phi) * Math.cos(theta);
                    y = radius * Math.sin(phi) * Math.sin(theta);
                    z = radius * Math.cos(phi);
                    
                } else { // 10%ãŒéŠ€æ²³ä¸­å¿ƒãƒãƒ«ã‚¸
                    // éŠ€æ²³ä¸­å¿ƒã®ãƒãƒ«ã‚¸ï¼ˆæ¥•å††ä½“åˆ†å¸ƒï¼‰
                    const bulgeRadius = 20 + Math.random() * 40;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    x = bulgeRadius * Math.sin(phi) * Math.cos(theta) * 1.5; // xæ–¹å‘ã«ä¼¸é•·
                    y = bulgeRadius * Math.sin(phi) * Math.sin(theta) * 0.8; // yæ–¹å‘ã«åœ§ç¸®
                    z = bulgeRadius * Math.cos(phi) * 1.2; // zæ–¹å‘ã«ä¸­ç¨‹åº¦
                }
                
                starPositions.push(x, y, z);
                
                // éŠ€æ²³å†…ã®ä½ç½®ã«åŸºã¥ãæ˜Ÿã®ç‰¹å¾´ï¼ˆè‹¥ã„æ˜Ÿã¯æ¸¦å·»ãè…•ã«å¤šã„ï¼‰
                const distanceFromCenter = Math.sqrt(x*x + z*z);
                const inSpiralArm = i < 40000;
                const inBulge = i >= 45000;
                
                // ã‚ˆã‚Šè©³ç´°ã§ç¾å®Ÿçš„ãªæ’æ˜Ÿã®åˆ†é¡ã¨è‰²åˆ†å¸ƒ
                let colorType = Math.random();
                
                // éŠ€æ²³ä¸­å¿ƒãƒãƒ«ã‚¸ã§ã¯å¤ã„èµ¤ã„æ˜ŸãŒå¤šã„
                if (inBulge) {
                    colorType = Math.random() * 0.4 + 0.6; // Kå‹ãƒ»Må‹ã«åé‡
                }
                
                // æ¸¦å·»ãè…•ã§ã¯è‹¥ã„é’ã„æ˜ŸãŒå¤šã„
                if (inSpiralArm && Math.random() < 0.3) {
                    colorType = Math.random() * 0.3; // Oå‹ãƒ»Bå‹ãƒ»Aå‹ã«åé‡
                }
                
                if (colorType < 0.00003) {
                    // Oå‹æ˜Ÿï¼ˆé’è‰²å·¨æ˜Ÿã€æ¥µç¨€ï¼‰
                    starColors.push(0.5, 0.7, 1);
                    starSizes.push(Math.random() * 6 + 4);
                } else if (colorType < 0.0013) {
                    // Bå‹æ˜Ÿï¼ˆé’ç™½è‰²ã€ç¨€ï¼‰
                    starColors.push(0.7, 0.85, 1);
                    starSizes.push(Math.random() * 4 + 2);
                } else if (colorType < 0.0073) {
                    // Aå‹æ˜Ÿï¼ˆç™½è‰²ï¼‰
                    starColors.push(0.95, 0.98, 1);
                    starSizes.push(Math.random() * 3 + 1.5);
                } else if (colorType < 0.0373) {
                    // Få‹æ˜Ÿï¼ˆé»„ç™½è‰²ï¼‰
                    starColors.push(1, 1, 0.9);
                    starSizes.push(Math.random() * 2.5 + 1.2);
                } else if (colorType < 0.1133) {
                    // Gå‹æ˜Ÿï¼ˆé»„è‰²ã€å¤ªé™½å‹ï¼‰
                    starColors.push(1, 0.96, 0.8);
                    starSizes.push(Math.random() * 2 + 1);
                } else if (colorType < 0.2343) {
                    // Kå‹æ˜Ÿï¼ˆã‚ªãƒ¬ãƒ³ã‚¸è‰²ã€å¤šã„ï¼‰
                    starColors.push(1, 0.85, 0.65);
                    starSizes.push(Math.random() * 1.8 + 0.8);
                } else {
                    // Må‹æ˜Ÿï¼ˆèµ¤è‰²çŸ®æ˜Ÿã€æœ€ã‚‚å¤šã„ - 76%ï¼‰
                    const mSubtype = Math.random();
                    if (mSubtype < 0.3) {
                        // åˆæœŸMå‹ï¼ˆæ˜ã‚‹ã„èµ¤ï¼‰
                        starColors.push(1, 0.7, 0.5);
                        starSizes.push(Math.random() * 1.5 + 0.7);
                    } else if (mSubtype < 0.7) {
                        // ä¸­æœŸMå‹ï¼ˆä¸­ç¨‹åº¦ã®èµ¤ï¼‰
                        starColors.push(1, 0.6, 0.4);
                        starSizes.push(Math.random() * 1.2 + 0.5);
                    } else {
                        // å¾ŒæœŸMå‹ï¼ˆæš—ã„èµ¤ï¼‰
                        starColors.push(0.9, 0.5, 0.3);
                        starSizes.push(Math.random() * 0.8 + 0.3);
                    }
                }
                
                // è·é›¢ã«åŸºã¥ãæ˜åº¦èª¿æ•´ï¼ˆé ã„æ˜Ÿã¯æš—ãï¼‰
                const distanceFactor = Math.max(0.3, 1 - distanceFromCenter / 400);
                const lastSize = starSizes[starSizes.length - 1];
                starSizes[starSizes.length - 1] = lastSize * distanceFactor;
            }
            
            // å¤©ã®å·ã®æ˜ã‚‹ã„æ˜ŸåŸŸãƒ»æ˜Ÿé›²ã‚’è¿½åŠ ï¼ˆã•ã‚‰ã«5000å€‹ã®æ˜ã‚‹ã„æ˜Ÿï¼‰
            for (let i = 0; i < 5000; i++) {
                // å¤©ã®å·ã®ä¸­å¿ƒå¹³é¢ã«é›†ä¸­ã—ã¦é…ç½®
                const galacticRadius = 80 + Math.random() * 180;
                const galacticAngle = Math.random() * Math.PI * 2;
                
                // å¤©ã®å·ã®å¸¯çŠ¶æ§‹é€ ã‚’å¼·èª¿
                const heightVariation = (Math.random() - 0.5) * 8; // éå¸¸ã«è–„ã„å¸¯çŠ¶
                
                const x = galacticRadius * Math.cos(galacticAngle);
                const y = heightVariation;
                const z = galacticRadius * Math.sin(galacticAngle);
                
                starPositions.push(x, y, z);
                
                // æ˜ã‚‹ã„æ˜Ÿã‚„æ˜Ÿé›²ã®è‰²ï¼ˆé’ç™½ã„æ˜Ÿå½¢æˆé ˜åŸŸã‚„èµ¤ã„æ•£å…‰æ˜Ÿé›²ï¼‰
                const brightType = Math.random();
                if (brightType < 0.3) {
                    // é’ã„æ˜Ÿå½¢æˆé ˜åŸŸ
                    starColors.push(0.8, 0.9, 1);
                    starSizes.push(Math.random() * 2 + 1.5);
                } else if (brightType < 0.6) {
                    // ç™½ã„æ˜ã‚‹ã„æ˜Ÿ
                    starColors.push(1, 1, 0.95);
                    starSizes.push(Math.random() * 2.5 + 1.8);
                } else {
                    // èµ¤ã„æ•£å…‰æ˜Ÿé›²
                    starColors.push(1, 0.6, 0.6);
                    starSizes.push(Math.random() * 1.8 + 1.2);
                }
            }
            
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
            starGeometry.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));
            
            const starMaterial = new THREE.PointsMaterial({
                vertexColors: true,
                size: 0.08, // å°‘ã—å¤§ããã—ã¦å¤©ã®å·ã®ç¾ã—ã•ã‚’å¼·èª¿
                transparent: true,
                opacity: 0, // åˆæœŸå€¤ã‚’0ã«è¨­å®š
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending
            });
            
            return new THREE.Points(starGeometry, starMaterial);
        }

        // èƒŒæ™¯ãƒ•ã‚§ãƒ¼ãƒ‰ç”¨ã®çƒä½“ã‚’ä½œæˆ
        function createBackgroundSphere() {
            const geometry = new THREE.SphereGeometry(300, 32, 16);
            const material = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0,
                side: THREE.BackSide // å†…å´ã‹ã‚‰è¦‹ãˆã‚‹ã‚ˆã†ã«
            });
            
            return new THREE.Mesh(geometry, material);
        }

        // å°æƒ‘æ˜Ÿå¸¯ã‚’ä½œæˆï¼ˆç«æ˜Ÿã¨æœ¨æ˜Ÿã®é–“ï¼‰
        function createAsteroidBelt() {
            const asteroidGroup = new THREE.Group();
            const asteroidCount = 500; // ç¾å®Ÿçš„ãªå°æƒ‘æ˜Ÿæ•°ã«å¤§å¹…å¢—åŠ 
            const innerRadius = 1.7;  // ç«æ˜Ÿè»Œé“ã‚ˆã‚Šå¤–å´
            const outerRadius = 1.9;  // æœ¨æ˜Ÿè»Œé“ã‚ˆã‚Šå†…å´
            
            for (let i = 0; i < asteroidCount; i++) {
                // ç¾å®Ÿçš„ãªå°æƒ‘æ˜Ÿåˆ†å¸ƒï¼ˆã‚±ãƒ¬ã‚¹ã€ãƒ™ã‚¹ã‚¿ãªã©å¤§ããªã‚‚ã®ã‚‚å«ã‚€ï¼‰
                let distance, size, asteroidType;
                
                // å°æƒ‘æ˜Ÿã®ã‚¿ã‚¤ãƒ—åˆ†é¡ï¼ˆç¾å®Ÿçš„ãªåˆ†å¸ƒï¼‰
                const typeRand = Math.random();
                if (typeRand < 0.001) {
                    // æº–æƒ‘æ˜Ÿç´šï¼ˆã‚±ãƒ¬ã‚¹ç­‰ï¼‰
                    asteroidType = 'dwarf';
                    size = 0.015 + Math.random() * 0.01;
                    distance = innerRadius + Math.random() * (outerRadius - innerRadius);
                } else if (typeRand < 0.01) {
                    // å¤§å‹å°æƒ‘æ˜Ÿï¼ˆãƒ™ã‚¹ã‚¿ã€ãƒ‘ãƒ©ã‚¹ç­‰ï¼‰
                    asteroidType = 'large';
                    size = 0.005 + Math.random() * 0.008;
                    distance = innerRadius + Math.random() * (outerRadius - innerRadius);
                } else if (typeRand < 0.1) {
                    // ä¸­å‹å°æƒ‘æ˜Ÿ
                    asteroidType = 'medium';
                    size = 0.002 + Math.random() * 0.004;
                    distance = innerRadius + Math.random() * (outerRadius - innerRadius);
                } else {
                    // å°å‹å°æƒ‘æ˜Ÿï¼ˆæœ€ã‚‚å¤šã„ï¼‰
                    asteroidType = 'small';
                    size = 0.0005 + Math.random() * 0.002;
                    distance = innerRadius + Math.random() * (outerRadius - innerRadius);
                }
                
                const angle = Math.random() * Math.PI * 2;
                
                // ã‚ˆã‚Šç¾å®Ÿçš„ãªè»Œé“å‚¾æ–œï¼ˆå¤§éƒ¨åˆ†ã¯å¹³é¢çš„ã ãŒã€ä¸€éƒ¨ã¯å‚¾æ–œï¼‰
                const inclination = (Math.random() < 0.9) ? 
                    (Math.random() - 0.5) * 0.1 : // 90%ã¯å¹³é¢çš„
                    (Math.random() - 0.5) * 0.3;  // 10%ã¯å‚¾æ–œ
                
                // å°æƒ‘æ˜Ÿã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸã‚¸ã‚ªãƒ¡ãƒˆãƒª
                let geometry;
                if (asteroidType === 'dwarf' || asteroidType === 'large') {
                    geometry = new THREE.SphereGeometry(size, 12, 8); // é«˜å“è³ª
                } else {
                    geometry = new THREE.SphereGeometry(size, 6, 4); // è»½é‡
                }
                
                // ä¸è¦å‰‡ãªå½¢çŠ¶ã‚’ä½œæˆ
                const vertices = geometry.attributes.position.array;
                for (let j = 0; j < vertices.length; j += 3) {
                    const factor = 0.6 + Math.random() * 0.8; // ã‚ˆã‚Šå¼·ã„ä¸è¦å‰‡æ€§
                    vertices[j] *= factor;
                    vertices[j + 1] *= factor;
                    vertices[j + 2] *= factor;
                }
                geometry.attributes.position.needsUpdate = true;
                
                // å°æƒ‘æ˜Ÿã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸè‰²ã¨ãƒãƒ†ãƒªã‚¢ãƒ«
                let color, materialProps;
                switch(asteroidType) {
                    case 'dwarf':
                        // ã‚±ãƒ¬ã‚¹æ§˜ï¼ˆæ°·ã¨å²©çŸ³ï¼‰
                        color = new THREE.Color().setHSL(0.15, 0.2, 0.4 + Math.random() * 0.2);
                        materialProps = { roughness: 0.8, metalness: 0.1 };
                        break;
                    case 'large':
                        // ãƒ™ã‚¹ã‚¿æ§˜ï¼ˆç„æ­¦å²©è³ªï¼‰
                        color = new THREE.Color().setHSL(0.1, 0.4, 0.3 + Math.random() * 0.2);
                        materialProps = { roughness: 0.9, metalness: 0.05 };
                        break;
                    case 'medium':
                        // ä¸€èˆ¬çš„ãªå²©çŸ³è³ª
                        color = new THREE.Color().setHSL(0.08, 0.3, 0.25 + Math.random() * 0.25);
                        materialProps = { roughness: 0.85, metalness: 0.02 };
                        break;
                    default:
                        // å°å‹ï¼ˆç‚­ç´ è³ªã‚³ãƒ³ãƒ‰ãƒ©ã‚¤ãƒˆæ§˜ï¼‰
                        color = new THREE.Color().setHSL(0.05, 0.2, 0.15 + Math.random() * 0.2);
                        materialProps = { roughness: 0.95, metalness: 0.01 };
                }
                
                const material = new THREE.MeshLambertMaterial({
                    color: color
                });
                
                const asteroid = new THREE.Mesh(geometry, material);
                asteroid.position.x = Math.cos(angle) * distance;
                asteroid.position.z = Math.sin(angle) * distance;
                asteroid.position.y = inclination * distance; // ç¾å®Ÿçš„ãªè»Œé“å‚¾æ–œã‚’é©ç”¨
                
                asteroid.rotation.x = Math.random() * Math.PI * 2;
                asteroid.rotation.y = Math.random() * Math.PI * 2;
                asteroid.rotation.z = Math.random() * Math.PI * 2;
                
                asteroid.castShadow = true;
                asteroid.receiveShadow = true;
                
                // å›è»¢é€Ÿåº¦ã‚’è¨­å®š
                asteroid.userData = {
                    rotationSpeed: (Math.random() - 0.5) * 0.01,
                    orbitSpeed: 0.0001 + Math.random() * 0.0002,
                    angle: angle,
                    distance: distance
                };
                
                asteroidGroup.add(asteroid);
            }
            
            // æœ‰åãªå°æƒ‘æ˜Ÿã‚’ç‰¹åˆ¥ã«è¿½åŠ ï¼ˆç¾å®Ÿã®ä½ç½®ã«åŸºã¥ãï¼‰
            const famousAsteroids = [
                {name: 'ã‚±ãƒ¬ã‚¹(Ceres)', distance: 1.77, angle: Math.PI * 0.3, size: 0.025, type: 'dwarf'},
                {name: 'ãƒ™ã‚¹ã‚¿(Vesta)', distance: 1.75, angle: Math.PI * 1.2, size: 0.012, type: 'large'},
                {name: 'ãƒ‘ãƒ©ã‚¹(Pallas)', distance: 1.78, angle: Math.PI * 0.8, size: 0.011, type: 'large'},
                {name: 'ãƒ’ã‚®ã‚¨ã‚¢(Hygiea)', distance: 1.8, angle: Math.PI * 1.7, size: 0.01, type: 'large'},
                {name: 'ã‚¤ãƒ€(Ida)', distance: 1.76, angle: Math.PI * 0.1, size: 0.003, type: 'medium'},
                {name: 'ã‚¨ãƒ­ã‚¹(Eros)', distance: 1.74, angle: Math.PI * 1.5, size: 0.0025, type: 'medium'}
            ];
            
            famousAsteroids.forEach(asteroidData => {
                const geometry = new THREE.SphereGeometry(asteroidData.size, 16, 12);
                
                // ä¸è¦å‰‡ãªå½¢çŠ¶
                const vertices = geometry.attributes.position.array;
                for (let j = 0; j < vertices.length; j += 3) {
                    const factor = 0.5 + Math.random() * 1.0;
                    vertices[j] *= factor;
                    vertices[j + 1] *= factor;
                    vertices[j + 2] *= factor;
                }
                geometry.attributes.position.needsUpdate = true;
                
                let color;
                switch(asteroidData.type) {
                    case 'dwarf':
                        color = new THREE.Color(0x8B7D6B); // ã‚±ãƒ¬ã‚¹æ§˜ã®æ˜ã‚‹ã„ç°è‰²
                        break;
                    case 'large':
                        color = new THREE.Color(0x6B5B4F); // ãƒ™ã‚¹ã‚¿æ§˜ã®å²©çŸ³è‰²
                        break;
                    default:
                        color = new THREE.Color(0x4A4A4A); // ä¸€èˆ¬çš„ãªå²©çŸ³è‰²
                }
                
                const material = new THREE.MeshLambertMaterial({ color: color });
                const asteroid = new THREE.Mesh(geometry, material);
                
                asteroid.position.x = Math.cos(asteroidData.angle) * asteroidData.distance;
                asteroid.position.z = Math.sin(asteroidData.angle) * asteroidData.distance;
                asteroid.position.y = (Math.random() - 0.5) * 0.02;
                
                asteroid.rotation.x = Math.random() * Math.PI * 2;
                asteroid.rotation.y = Math.random() * Math.PI * 2;
                asteroid.rotation.z = Math.random() * Math.PI * 2;
                
                asteroid.castShadow = true;
                asteroid.receiveShadow = true;
                
                asteroid.userData = {
                    name: asteroidData.name,
                    rotationSpeed: (Math.random() - 0.5) * 0.005,
                    orbitSpeed: 0.0001 + Math.random() * 0.0001,
                    angle: asteroidData.angle,
                    distance: asteroidData.distance,
                    famous: true
                };
                
                asteroidGroup.add(asteroid);
            });
            
            solarSystemGroup.add(asteroidGroup);
            return asteroidGroup;
        }

        // ã‚«ã‚¤ãƒ‘ãƒ¼ãƒ™ãƒ«ãƒˆã‚’ä½œæˆï¼ˆæµ·ç‹æ˜Ÿã®å¤–å´ï¼‰
        function createKuiperBelt() {
            const kuiperGroup = new THREE.Group();
            const objectCount = 200; // ç¾å®Ÿçš„ãªã‚«ã‚¤ãƒ‘ãƒ¼ãƒ™ãƒ«ãƒˆå¤©ä½“æ•°
            const innerRadius = 4.2;  // æµ·ç‹æ˜Ÿè»Œé“ã‚ˆã‚Šå¤–å´
            const outerRadius = 6.0;  // ã•ã‚‰ã«å¤–å´
            
            for (let i = 0; i < objectCount; i++) {
                // ç¾å®Ÿçš„ãªã‚«ã‚¤ãƒ‘ãƒ¼ãƒ™ãƒ«ãƒˆå¤©ä½“ã®åˆ†å¸ƒ
                let distance, size, kboType;
                
                const typeRand = Math.random();
                if (typeRand < 0.005) {
                    // å†¥ç‹æ˜Ÿç´šï¼ˆæº–æƒ‘æ˜Ÿï¼‰
                    kboType = 'dwarf';
                    size = 0.02 + Math.random() * 0.01;
                    distance = innerRadius + Math.random() * (outerRadius - innerRadius);
                } else if (typeRand < 0.02) {
                    // å¤§å‹å¤©ä½“ï¼ˆãƒã‚±ãƒã‚±ã€ãƒã‚¦ãƒ¡ã‚¢ç´šï¼‰
                    kboType = 'large';
                    size = 0.008 + Math.random() * 0.012;
                    distance = innerRadius + Math.random() * (outerRadius - innerRadius);
                } else if (typeRand < 0.1) {
                    // ä¸­å‹å¤©ä½“
                    kboType = 'medium';
                    size = 0.003 + Math.random() * 0.006;
                    distance = innerRadius + Math.random() * (outerRadius - innerRadius);
                } else {
                    // å°å‹å¤©ä½“ï¼ˆæœ€ã‚‚å¤šã„ï¼‰
                    kboType = 'small';
                    size = 0.001 + Math.random() * 0.004;
                    distance = innerRadius + Math.random() * (outerRadius - innerRadius);
                }
                
                const angle = Math.random() * Math.PI * 2;
                
                // å¤©ä½“ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸå“è³ªã¨ã‚¸ã‚ªãƒ¡ãƒˆãƒª
                let geometry;
                if (kboType === 'dwarf' || kboType === 'large') {
                    geometry = new THREE.SphereGeometry(size, 16, 12); // é«˜å“è³ª
                } else {
                    geometry = new THREE.SphereGeometry(size, 8, 6); // è»½é‡
                }
                
                // å¤©ä½“ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸè‰²ï¼ˆæ°·è³ªãŒå¤šã„ï¼‰
                let color;
                switch(kboType) {
                    case 'dwarf':
                        // å†¥ç‹æ˜Ÿæ§˜ï¼ˆçª’ç´ æ°·ã€ãƒ¡ã‚¿ãƒ³æ°·ï¼‰
                        color = new THREE.Color().setHSL(0.05, 0.2, 0.6 + Math.random() * 0.2);
                        break;
                    case 'large':
                        // å¤§å‹å¤©ä½“ï¼ˆæ°´æ°·ã€å²©çŸ³ï¼‰
                        color = new THREE.Color().setHSL(0.55, 0.3, 0.4 + Math.random() * 0.3);
                        break;
                    case 'medium':
                        // ä¸­å‹å¤©ä½“ï¼ˆæ°·è³ªï¼‰
                        color = new THREE.Color().setHSL(0.6, 0.4, 0.3 + Math.random() * 0.25);
                        break;
                    default:
                        // å°å‹å¤©ä½“ï¼ˆæ±šã‚ŒãŸæ°·ï¼‰
                        color = new THREE.Color().setHSL(0.65, 0.3, 0.15 + Math.random() * 0.2);
                }
                
                const material = new THREE.MeshLambertMaterial({ color: color });
                
                const kbo = new THREE.Mesh(geometry, material);
                kbo.position.x = Math.cos(angle) * distance;
                kbo.position.z = Math.sin(angle) * distance;
                
                // ç¾å®Ÿçš„ãªè»Œé“å‚¾æ–œï¼ˆã‚«ã‚¤ãƒ‘ãƒ¼ãƒ™ãƒ«ãƒˆã¯æ•£é–‹ã—ã¦ã„ã‚‹ï¼‰
                const inclination = (Math.random() < 0.7) ? 
                    (Math.random() - 0.5) * 0.3 : // 70%ã¯æ¯”è¼ƒçš„å¹³é¢çš„
                    (Math.random() - 0.5) * 0.8;  // 30%ã¯é«˜å‚¾æ–œ
                kbo.position.y = inclination * distance;
                
                kbo.castShadow = true;
                kbo.receiveShadow = true;
                
                kbo.userData = {
                    rotationSpeed: (Math.random() - 0.5) * 0.005,
                    orbitSpeed: 0.00005 + Math.random() * 0.00005,
                    angle: angle,
                    distance: distance
                };
                
                kuiperGroup.add(kbo);
            }
            
            solarSystemGroup.add(kuiperGroup);
            return kuiperGroup;
        }

        // å¤ªé™½ç³»å¤–ã®æ’æ˜Ÿã‚’ä½œæˆ
        function createDistantStars() {
            const starGroup = new THREE.Group();
            const starCount = 25; // 50ã‹ã‚‰25ã«è»½é‡åŒ–
            
            for (let i = 0; i < starCount; i++) {
                // é æ–¹ã®æ’æ˜Ÿ
                const distance = 20 + Math.random() * 80;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                // ã‚ˆã‚Šè‡ªç„¶ãªæ’æ˜Ÿã®å®Ÿè£…
                const starType = Math.random();
                let size, color, intensity;
                
                // ã‚µã‚¤ã‚ºã‚’å¤§å¹…ã«ç¸®å°ã—ã¦ç‚¹å…‰æºã®ã‚ˆã†ã«è¦‹ã›ã‚‹
                if (starType < 0.4) {
                    // èµ¤è‰²çŸ®æ˜Ÿï¼ˆæœ€ã‚‚å¤šã„ï¼‰
                    size = 0.02 + Math.random() * 0.03;
                    color = new THREE.Color(0xFF8866);
                    intensity = 0.2;
                } else if (starType < 0.7) {
                    // å¤ªé™½å‹æ˜Ÿ
                    size = 0.025 + Math.random() * 0.035;
                    color = new THREE.Color(0xFFFFDD);
                    intensity = 0.3;
                } else if (starType < 0.85) {
                    // é’è‰²æ˜Ÿ
                    size = 0.03 + Math.random() * 0.04;
                    color = new THREE.Color(0xDDEEFF);
                    intensity = 0.4;
                } else {
                    // å·¨æ˜Ÿï¼ˆç¨€ï¼‰
                    size = 0.04 + Math.random() * 0.05;
                    color = new THREE.Color(0xFFDD88);
                    intensity = 0.35;
                }
                
                const geometry = new THREE.SphereGeometry(size, 8, 6); // ãƒãƒªã‚´ãƒ³æ•°å‰Šæ¸›
                const material = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: (0.8 + Math.random() * 0.2) * intensity // é€æ˜åº¦ã§æ˜ã‚‹ã•ã‚’èª¿æ•´
                });
                
                const star = new THREE.Mesh(geometry, material);
                star.position.x = distance * Math.sin(phi) * Math.cos(theta);
                star.position.y = distance * Math.sin(phi) * Math.sin(theta);
                star.position.z = distance * Math.cos(phi);
                
                // éå¸¸ã«æ§ãˆã‚ãªå…‰æºã‚’è¿½åŠ 
                if (Math.random() < 0.3) { // 30%ã®ç¢ºç‡ã§ã®ã¿å…‰æºã‚’è¿½åŠ 
                    const starLight = new THREE.PointLight(color, 0.05, distance * 0.3);
                    starLight.position.copy(star.position);
                    scene.add(starLight);
                }
                
                starGroup.add(star);
            }
            
            scene.add(starGroup);
            registerUniverseElement(starGroup);
            return starGroup;
        }

        // ç¾å®Ÿçš„ãªéŠ€æ²³é…ç½®ã‚’ä½œæˆï¼ˆç²’å­ã‚·ã‚¹ãƒ†ãƒ ç‰ˆï¼‰
        function createDistantGalaxies() {
            const galaxyGroup = new THREE.Group();
            
            // å®Ÿéš›ã®æœ‰åãªéŠ€æ²³ã‚’é…ç½®
            const realGalaxies = [
                // å±€æ‰€éŠ€æ²³ç¾¤ï¼ˆè¿‘è·é›¢ï¼‰
                {name: 'ã‚¢ãƒ³ãƒ‰ãƒ­ãƒ¡ãƒ€éŠ€æ²³(M31)', distance: 120, direction: {x: 0.8, y: 0.3, z: -0.5}, size: 8, type: 'spiral', brightness: 0.9},
                {name: 'å¤§ãƒã‚¼ãƒ©ãƒ³é›²', distance: 80, direction: {x: -0.6, y: -0.4, z: 0.7}, size: 4, type: 'irregular', brightness: 0.7},
                {name: 'å°ãƒã‚¼ãƒ©ãƒ³é›²', distance: 85, direction: {x: -0.5, y: -0.5, z: 0.7}, size: 2, type: 'irregular', brightness: 0.6},
                {name: 'ã•ã‚“ã‹ãåº§éŠ€æ²³(M33)', distance: 140, direction: {x: 0.7, y: 0.6, z: -0.4}, size: 5, type: 'spiral', brightness: 0.6},
                
                // ãŠã¨ã‚åº§éŠ€æ²³å›£ï¼ˆä¸­è·é›¢ï¼‰
                {name: 'ãŠã¨ã‚åº§A(M87)', distance: 200, direction: {x: 0.2, y: 0.8, z: 0.6}, size: 6, type: 'elliptical', brightness: 0.8},
                {name: 'ã‚½ãƒ³ãƒ–ãƒ¬ãƒ­éŠ€æ²³(M104)', distance: 210, direction: {x: 0.4, y: 0.7, z: 0.6}, size: 4, type: 'spiral', brightness: 0.7},
                {name: 'å­æŒã¡éŠ€æ²³(M51)', distance: 190, direction: {x: 0.6, y: 0.8, z: 0.1}, size: 4, type: 'spiral', brightness: 0.6},
                {name: 'M81(ãƒœãƒ¼ãƒ‡éŠ€æ²³)', distance: 180, direction: {x: 0.9, y: 0.3, z: 0.3}, size: 5, type: 'spiral', brightness: 0.7},
                {name: 'M82(è‘‰å·»éŠ€æ²³)', distance: 185, direction: {x: 0.9, y: 0.35, z: 0.25}, size: 3, type: 'starburst', brightness: 0.8},
                
                // ã‹ã¿ã®ã‘åº§éŠ€æ²³å›£ï¼ˆé è·é›¢ï¼‰
                {name: 'ã‹ã¿ã®ã‘åº§éŠ€æ²³å›£', distance: 280, direction: {x: 0.1, y: 0.9, z: 0.4}, size: 7, type: 'cluster', brightness: 0.5},
                
                // ã‚ˆã‚Šé æ–¹ã®éŠ€æ²³ï¼ˆè¶…é è·é›¢ï¼‰
                {name: 'ã‚±ãƒ³ã‚¿ã‚¦ãƒ«ã‚¹åº§A', distance: 250, direction: {x: -0.3, y: -0.7, z: 0.6}, size: 5, type: 'elliptical', brightness: 0.6},
                {name: 'NGC253(ã¡ã‚‡ã†ã“ãã—ã¤åº§éŠ€æ²³)', distance: 170, direction: {x: -0.8, y: -0.4, z: -0.4}, size: 4, type: 'spiral', brightness: 0.6},
                {name: 'M101(å›è»¢èŠ±ç«éŠ€æ²³)', distance: 220, direction: {x: 0.7, y: 0.7, z: 0.1}, size: 6, type: 'spiral', brightness: 0.5},
                {name: 'M106', distance: 200, direction: {x: 0.8, y: 0.5, z: 0.3}, size: 4, type: 'spiral', brightness: 0.6},
                {name: 'NGC5128', distance: 240, direction: {x: -0.2, y: -0.8, z: 0.6}, size: 5, type: 'elliptical', brightness: 0.7}
            ];
            
            realGalaxies.forEach(galaxyData => {
                const galaxy = createGalaxyParticleSystem(galaxyData);
                galaxyGroup.add(galaxy);
            });
            
            // è¿½åŠ ã®ãƒ©ãƒ³ãƒ€ãƒ éŠ€æ²³ç¾¤ï¼ˆç¾å®Ÿçš„ãªåˆ†å¸ƒï¼‰
            for (let cluster = 0; cluster < 3; cluster++) { // 5ã‹ã‚‰3ã«å‰Šæ¸›ï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Šï¼‰
                const clusterCenter = {
                    x: (Math.random() - 0.5) * 2,
                    y: (Math.random() - 0.5) * 2,
                    z: (Math.random() - 0.5) * 2
                };
                const clusterDistance = 300 + Math.random() * 200;
                const galaxyCount = 5 + Math.floor(Math.random() * 8); // æ•°ã‚’å‰Šæ¸›
                
                for (let i = 0; i < galaxyCount; i++) {
                    const offset = {
                        x: (Math.random() - 0.5) * 0.4,
                        y: (Math.random() - 0.5) * 0.4,
                        z: (Math.random() - 0.5) * 0.4
                    };
                    
                    const direction = {
                        x: clusterCenter.x + offset.x,
                        y: clusterCenter.y + offset.y,
                        z: clusterCenter.z + offset.z
                    };
                    
                    // éŠ€æ²³ã®ç¨®é¡ã‚’ç¾å®Ÿçš„ãªæ¯”ç‡ã§æ±ºå®š
                    let type;
                    const typeRand = Math.random();
                    if (typeRand < 0.6) type = 'elliptical';      // 60% æ¥•å††éŠ€æ²³
                    else if (typeRand < 0.9) type = 'spiral';     // 30% æ¸¦å·»éŠ€æ²³
                    else type = 'irregular';                      // 10% ä¸è¦å‰‡éŠ€æ²³
                    
                    const galaxyData = {
                        name: `éŠ€æ²³ç¾¤${cluster}-${i}`,
                        distance: clusterDistance + (Math.random() - 0.5) * 50,
                        direction: direction,
                        size: 1 + Math.random() * 3,
                        type: type,
                        brightness: 0.2 + Math.random() * 0.4
                    };
                    
                    const galaxy = createGalaxyParticleSystem(galaxyData);
                    galaxyGroup.add(galaxy);
                }
            }
            
            scene.add(galaxyGroup);
            registerUniverseElement(galaxyGroup);
            return galaxyGroup;
        }
        
        // éŠ€æ²³ç²’å­ã‚·ã‚¹ãƒ†ãƒ ä½œæˆé–¢æ•°
        function createGalaxyParticleSystem(galaxyData) {
            const normalizedDir = new THREE.Vector3(galaxyData.direction.x, galaxyData.direction.y, galaxyData.direction.z);
            normalizedDir.normalize();
            
            const position = normalizedDir.multiplyScalar(galaxyData.distance);
            
            // éŠ€æ²³ã®ã‚µã‚¤ã‚ºã‚’è·é›¢ã«å¿œã˜ã¦èª¿æ•´
            const apparentSize = galaxyData.size * (100 / galaxyData.distance);
            
            // ç²’å­ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
            const particleData = generateGalaxyParticles(galaxyData.type, apparentSize, galaxyData.brightness);
            
            // ã‚¸ã‚ªãƒ¡ãƒˆãƒªã¨ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’ä½œæˆ
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(particleData.positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(particleData.colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(particleData.sizes, 1));
            
            const material = new THREE.PointsMaterial({
                vertexColors: true,
                size: 0.02, // åŸºæœ¬ã‚µã‚¤ã‚º
                transparent: true,
                opacity: galaxyData.brightness,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const galaxy = new THREE.Points(geometry, material);
            galaxy.position.copy(position);
            galaxy.name = galaxyData.name;
            
            // éŠ€æ²³ã‚’åœ°çƒæ–¹å‘ã«å‘ã‘ã‚‹
            galaxy.lookAt(0, 0, 0);
            
            // éå¸¸ã«ã‚†ã£ãã‚Šã¨ã—ãŸå›è»¢
            galaxy.userData = {
                rotationSpeed: (Math.random() - 0.5) * 0.0003,
                originalBrightness: galaxyData.brightness,
                type: galaxyData.type
            };
            
            return galaxy;
        }
        
        // éŠ€æ²³ã‚¿ã‚¤ãƒ—åˆ¥ç²’å­ç”Ÿæˆ
        function generateGalaxyParticles(type, size, brightness) {
            const positions = [];
            const colors = [];
            const sizes = [];
            
            let particleCount;
            
            // éŠ€æ²³ã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­å®š
            switch(type) {
                case 'spiral':
                    particleCount = Math.min(1000, Math.max(300, size * 30)); // ç²’å­æ•°ã‚’åˆ¶é™
                    break;
                case 'elliptical':
                    particleCount = Math.min(800, Math.max(200, size * 25));
                    break;
                case 'irregular':
                    particleCount = Math.min(400, Math.max(150, size * 15));
                    break;
                case 'starburst':
                    particleCount = Math.min(600, Math.max(200, size * 20));
                    break;
                case 'cluster':
                    particleCount = Math.min(1200, Math.max(400, size * 35));
                    break;
                default:
                    particleCount = 300;
            }
            
            for (let i = 0; i < particleCount; i++) {
                let x, y, z, color, particleSize;
                
                switch(type) {
                    case 'spiral':
                        // æ¸¦å·»éŠ€æ²³ï¼š4æœ¬ã®ã‚¢ãƒ¼ãƒ ã‚’æŒã¤èºæ—‹æ§‹é€ 
                        const armIndex = Math.floor(Math.random() * 4);
                        const armAngle = (armIndex * Math.PI / 2) + (Math.random() - 0.5) * 0.3;
                        const radius = Math.random() * size / 2;
                        const spiralAngle = armAngle + radius * 3;
                        
                        // ä¸­å¤®ãƒãƒ«ã‚¸ã‚‚å«ã‚ã‚‹
                        if (Math.random() < 0.3) {
                            // ä¸­å¤®ãƒãƒ«ã‚¸
                            const bulgeRadius = (size / 4) * Math.sqrt(Math.random());
                            const bulgeAngle = Math.random() * Math.PI * 2;
                            x = Math.cos(bulgeAngle) * bulgeRadius;
                            z = Math.sin(bulgeAngle) * bulgeRadius * 0.6; // æ‰å¹³
                            y = (Math.random() - 0.5) * size / 8;
                            color = [1, 0.9, 0.7]; // é»„è‰²ã£ã½ã„å¤ã„æ˜Ÿ
                        } else {
                            // æ¸¦å·»ãã‚¢ãƒ¼ãƒ 
                            x = Math.cos(spiralAngle) * radius;
                            z = Math.sin(spiralAngle) * radius * 0.8;
                            y = (Math.random() - 0.5) * size / 12;
                            
                            // æ˜Ÿå½¢æˆé ˜åŸŸã¯é’ã£ã½ã
                            if (Math.random() < 0.2) {
                                color = [0.7, 0.9, 1]; // é’ã„è‹¥ã„æ˜Ÿ
                            } else {
                                color = [1, 1, 0.9]; // ç™½ã£ã½ã„æ˜Ÿ
                            }
                        }
                        
                        particleSize = 0.3 + Math.random() * 0.7;
                        break;
                        
                    case 'elliptical':
                        // æ¥•å††éŠ€æ²³ï¼šæ¥•å††ä½“åˆ†å¸ƒ
                        const ellipseRadius = size / 2 * Math.pow(Math.random(), 0.5); // ä¸­å¿ƒã«é›†ä¸­
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos(2 * Math.random() - 1);
                        
                        x = ellipseRadius * Math.sin(phi) * Math.cos(theta);
                        z = ellipseRadius * Math.sin(phi) * Math.sin(theta) * 0.6; // æ‰å¹³
                        y = ellipseRadius * Math.cos(phi) * 0.4;
                        
                        // å¤ã„æ˜ŸãŒå¤šã„ï¼ˆèµ¤ã£ã½ã„ï¼‰
                        color = [1, 0.8 + Math.random() * 0.2, 0.6 + Math.random() * 0.2];
                        particleSize = 0.4 + Math.random() * 0.6;
                        break;
                        
                    case 'irregular':
                        // ä¸è¦å‰‡éŠ€æ²³ï¼šãƒ©ãƒ³ãƒ€ãƒ åˆ†å¸ƒã ãŒè‹¥å¹²ã®é›†ä¸­ã‚ã‚Š
                        const irregularRadius = size / 2;
                        const clumpX = (Math.random() - 0.5) * irregularRadius;
                        const clumpZ = (Math.random() - 0.5) * irregularRadius;
                        
                        x = clumpX + (Math.random() - 0.5) * irregularRadius / 2;
                        z = clumpZ + (Math.random() - 0.5) * irregularRadius / 2;
                        y = (Math.random() - 0.5) * size / 6;
                        
                        // å¤šæ§˜ãªæ˜Ÿã®è‰²
                        const colorType = Math.random();
                        if (colorType < 0.4) {
                            color = [0.7, 0.9, 1]; // é’ã„æ˜Ÿ
                        } else if (colorType < 0.7) {
                            color = [1, 1, 0.9]; // ç™½ã„æ˜Ÿ
                        } else {
                            color = [1, 0.8, 0.6]; // é»„è‰²ã„æ˜Ÿ
                        }
                        
                        particleSize = 0.2 + Math.random() * 0.8;
                        break;
                        
                    case 'starburst':
                        // ã‚¹ã‚¿ãƒ¼ãƒãƒ¼ã‚¹ãƒˆéŠ€æ²³ï¼šä¸­å¿ƒéƒ¨ã«é›†ä¸­ã—ãŸæ´»ç™ºãªæ˜Ÿå½¢æˆ
                        const starburstRadius = size / 3 * Math.sqrt(Math.random());
                        const starburstAngle = Math.random() * Math.PI * 2;
                        
                        x = Math.cos(starburstAngle) * starburstRadius;
                        z = Math.sin(starburstAngle) * starburstRadius;
                        y = (Math.random() - 0.5) * size / 10;
                        
                        // éå¸¸ã«æ˜ã‚‹ã„è‹¥ã„æ˜Ÿï¼ˆé’ç™½ã„ï¼‰
                        color = [0.8 + Math.random() * 0.2, 0.9 + Math.random() * 0.1, 1];
                        particleSize = 0.5 + Math.random() * 1;
                        break;
                        
                    case 'cluster':
                        // éŠ€æ²³å›£ï¼šè¤‡æ•°ã®å°ã•ãªéŠ€æ²³ã®é›†åˆ
                        const clusterCount = 5 + Math.floor(Math.random() * 5);
                        const whichCluster = Math.floor(Math.random() * clusterCount);
                        const clusterAngle = (whichCluster / clusterCount) * Math.PI * 2;
                        const clusterDistance = size / 4 + Math.random() * size / 4;
                        const clusterCenterX = Math.cos(clusterAngle) * clusterDistance;
                        const clusterCenterZ = Math.sin(clusterAngle) * clusterDistance;
                        
                        const localRadius = size / 8 * Math.random();
                        const localAngle = Math.random() * Math.PI * 2;
                        
                        x = clusterCenterX + Math.cos(localAngle) * localRadius;
                        z = clusterCenterZ + Math.sin(localAngle) * localRadius;
                        y = (Math.random() - 0.5) * size / 8;
                        
                        // æ§˜ã€…ãªéŠ€æ²³ã‚¿ã‚¤ãƒ—ã®æ˜Ÿã®è‰²
                        color = [0.9 + Math.random() * 0.1, 0.8 + Math.random() * 0.2, 0.7 + Math.random() * 0.3];
                        particleSize = 0.3 + Math.random() * 0.5;
                        break;
                        
                    default:
                        x = (Math.random() - 0.5) * size;
                        z = (Math.random() - 0.5) * size;
                        y = (Math.random() - 0.5) * size / 4;
                        color = [1, 1, 1];
                        particleSize = 0.5;
                }
                
                positions.push(x, y, z);
                colors.push(color[0] * brightness, color[1] * brightness, color[2] * brightness);
                sizes.push(particleSize);
            }
            
            return { positions, colors, sizes };
        }


        // æœ‰åãªæ˜Ÿåº§ã‚’ä½œæˆ
        function createConstellations() {
            const constellationGroup = new THREE.Group();
            
            // ã‚ªãƒªã‚ªãƒ³åº§ã‚’ä½œæˆ
            const orionStars = [
                // ãƒ™ãƒ†ãƒ«ã‚®ã‚¦ã‚¹ï¼ˆå·¦è‚©ï¼‰
                { name: 'ãƒ™ãƒ†ãƒ«ã‚®ã‚¦ã‚¹', pos: [-30, 25, -80], color: 0xFF6644, size: 0.15 },
                // ãƒªã‚²ãƒ«ï¼ˆå³è¶³ï¼‰
                { name: 'ãƒªã‚²ãƒ«', pos: [25, -25, -80], color: 0xAADDFF, size: 0.12 },
                // ãƒ™ãƒ©ãƒˆãƒªãƒƒã‚¯ã‚¹ï¼ˆå³è‚©ï¼‰
                { name: 'ãƒ™ãƒ©ãƒˆãƒªãƒƒã‚¯ã‚¹', pos: [20, 15, -80], color: 0xDDEEFF, size: 0.08 },
                // ã‚ªãƒªã‚ªãƒ³ãƒ™ãƒ«ãƒˆ
                { name: 'ã‚¢ãƒ«ãƒ‹ã‚¿ã‚¯', pos: [-8, 0, -80], color: 0xDDEEFF, size: 0.09 },
                { name: 'ã‚¢ãƒ«ãƒ‹ãƒ©ãƒ ', pos: [0, 0, -80], color: 0xDDEEFF, size: 0.09 },
                { name: 'ãƒŸãƒ³ã‚¿ã‚«', pos: [8, 0, -80], color: 0xDDEEFF, size: 0.08 },
                // å‰£
                { name: 'ã‚ªãƒªã‚ªãƒ³æ˜Ÿé›²', pos: [0, -15, -80], color: 0xFF99DD, size: 0.1 }
            ];
            
            orionStars.forEach(star => {
                const geometry = new THREE.SphereGeometry(star.size, 16, 12);
                const material = new THREE.MeshBasicMaterial({
                    color: star.color
                });
                
                const starMesh = new THREE.Mesh(geometry, material);
                starMesh.position.set(star.pos[0], star.pos[1], star.pos[2]);
                starMesh.name = star.name;
                
                // æ˜Ÿã®å…‰ã‚’è¿½åŠ 
                const starLight = new THREE.PointLight(star.color, 0.5, 50);
                starLight.position.copy(starMesh.position);
                scene.add(starLight);
                
                constellationGroup.add(starMesh);
            });
            
            // åŒ—æ–—ä¸ƒæ˜Ÿã‚’ä½œæˆ
            const bigDipperStars = [
                { pos: [-60, 40, -90], color: 0xFFFFAA, size: 0.1 },
                { pos: [-50, 45, -90], color: 0xFFFFAA, size: 0.09 },
                { pos: [-40, 42, -90], color: 0xFFFFAA, size: 0.08 },
                { pos: [-30, 40, -90], color: 0xFFFFAA, size: 0.09 },
                { pos: [-20, 35, -90], color: 0xFFFFAA, size: 0.08 },
                { pos: [-15, 25, -90], color: 0xFFFFAA, size: 0.09 },
                { pos: [-10, 15, -90], color: 0xFFFFAA, size: 0.08 }
            ];
            
            bigDipperStars.forEach((star, index) => {
                const geometry = new THREE.SphereGeometry(star.size, 16, 12);
                const material = new THREE.MeshBasicMaterial({
                    color: star.color
                });
                
                const starMesh = new THREE.Mesh(geometry, material);
                starMesh.position.set(star.pos[0], star.pos[1], star.pos[2]);
                starMesh.name = `åŒ—æ–—ä¸ƒæ˜Ÿ${index + 1}`;
                
                constellationGroup.add(starMesh);
            });
            
            // ã‚«ã‚·ã‚ªãƒšã‚¢åº§ã‚’ä½œæˆï¼ˆWå­—å‹ï¼‰
            const cassiopeiaStars = [
                { pos: [60, 50, -85], color: 0xDDEEFF, size: 0.09 },
                { pos: [55, 55, -85], color: 0xDDEEFF, size: 0.08 },
                { pos: [50, 52, -85], color: 0xDDEEFF, size: 0.1 },
                { pos: [45, 58, -85], color: 0xDDEEFF, size: 0.08 },
                { pos: [40, 55, -85], color: 0xDDEEFF, size: 0.09 }
            ];
            
            cassiopeiaStars.forEach((star, index) => {
                const geometry = new THREE.SphereGeometry(star.size, 16, 12);
                const material = new THREE.MeshBasicMaterial({
                    color: star.color
                });
                
                const starMesh = new THREE.Mesh(geometry, material);
                starMesh.position.set(star.pos[0], star.pos[1], star.pos[2]);
                starMesh.name = `ã‚«ã‚·ã‚ªãƒšã‚¢${index + 1}`;
                
                constellationGroup.add(starMesh);
            });
            
            scene.add(constellationGroup);
            registerUniverseElement(constellationGroup);
            return constellationGroup;
        }

        // ãƒ¬ãƒ³ã‚ºãƒ•ãƒ¬ã‚¢ç”¨ãƒ†ã‚¯ã‚¹ãƒãƒ£ä½œæˆï¼ˆé«˜å“è³ªåŒ–ï¼‰
        function createLensFlareTexture(size = 256, color = 0xffffff, type = 'main') {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            const centerX = size / 2;
            const centerY = size / 2;
            const radius = size / 2;
            
            let gradient;
            
            if (type === 'main') {
                // ãƒ¡ã‚¤ãƒ³ãƒ•ãƒ¬ã‚¢ï¼ˆè¶…é«˜å“è³ªãªä¸­å¿ƒéƒ¨ï¼‰
                gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.1, 'rgba(255, 255, 255, 0.95)');
                gradient.addColorStop(0.2, 'rgba(255, 255, 240, 0.8)');
                gradient.addColorStop(0.3, 'rgba(255, 250, 220, 0.6)');
                gradient.addColorStop(0.4, 'rgba(255, 240, 180, 0.4)');
                gradient.addColorStop(0.5, 'rgba(255, 220, 140, 0.3)');
                gradient.addColorStop(0.6, 'rgba(255, 200, 100, 0.2)');
                gradient.addColorStop(0.8, 'rgba(255, 160, 60, 0.1)');
                gradient.addColorStop(1, 'rgba(255, 120, 20, 0)');
                
                // å†…å´ã®å¼·ã„å…‰èŠ¯ã‚’è¿½åŠ 
                const innerGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius * 0.3);
                innerGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                innerGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
            } else if (type === 'sub') {
                // ã‚µãƒ–ãƒ•ãƒ¬ã‚¢ï¼ˆé«˜å“è³ªãªå°ã•ãªå…‰ï¼‰
                gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                gradient.addColorStop(0.2, 'rgba(255, 245, 200, 0.7)');
                gradient.addColorStop(0.4, 'rgba(255, 230, 150, 0.5)');
                gradient.addColorStop(0.6, 'rgba(255, 200, 100, 0.3)');
                gradient.addColorStop(0.8, 'rgba(255, 160, 60, 0.1)');
                gradient.addColorStop(1, 'rgba(255, 120, 20, 0)');
                
            } else if (type === 'hexagon') {
                // å…­è§’å½¢ãƒ•ãƒ¬ã‚¢ï¼ˆã‚«ãƒ¡ãƒ©ã®çµã‚Šã‚’æ¨¡æ“¬ï¼‰
                ctx.fillStyle = 'rgba(0, 0, 0, 0)';
                ctx.fillRect(0, 0, size, size);
                
                // å…­è§’å½¢ãƒ‘ã‚¹ä½œæˆ
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const x = centerX + Math.cos(angle) * radius * 0.7;
                    const y = centerY + Math.sin(angle) * radius * 0.7;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                
                gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius * 0.7);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                gradient.addColorStop(0.5, 'rgba(255, 220, 150, 0.4)');
                gradient.addColorStop(1, 'rgba(255, 180, 100, 0)');
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                return new THREE.CanvasTexture(canvas);
                
            } else if (type === 'star') {
                // æ˜Ÿå‹ãƒ•ãƒ¬ã‚¢ï¼ˆå›æŠ˜ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
                ctx.fillStyle = 'rgba(0, 0, 0, 0)';
                ctx.fillRect(0, 0, size, size);
                
                // åå­—ã®å…‰èŠ’ã‚’æç”»
                const armLength = radius * 0.9;
                const armWidth = 3;
                
                // æ°´å¹³ç·š
                gradient = ctx.createLinearGradient(centerX - armLength, centerY, centerX + armLength, centerY);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
                gradient.addColorStop(0.3, 'rgba(255, 240, 200, 0.6)');
                gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.8)');
                gradient.addColorStop(0.7, 'rgba(255, 240, 200, 0.6)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, centerY - armWidth, size, armWidth * 2);
                
                // å‚ç›´ç·š
                gradient = ctx.createLinearGradient(centerX, centerY - armLength, centerX, centerY + armLength);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
                gradient.addColorStop(0.3, 'rgba(255, 240, 200, 0.6)');
                gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.8)');
                gradient.addColorStop(0.7, 'rgba(255, 240, 200, 0.6)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(centerX - armWidth, 0, armWidth * 2, size);
                
                return new THREE.CanvasTexture(canvas);
            }
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);
            
            // ãƒ¡ã‚¤ãƒ³ãƒ•ãƒ¬ã‚¢ã®å ´åˆã€å†…å´ã®å¼·ã„å…‰èŠ¯ã‚’è¿½åŠ æç”»
            if (type === 'main') {
                const innerGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius * 0.2);
                innerGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                innerGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = innerGradient;
                ctx.fillRect(0, 0, size, size);
            }
            
            return new THREE.CanvasTexture(canvas);
        }

        // ãƒ¬ãƒ³ã‚ºãƒ•ãƒ¬ã‚¢ä½œæˆ
        function createLensFlare() {
            const lensFlareGroup = new THREE.Group();
            
            // ãƒ¬ãƒ³ã‚ºãƒ•ãƒ¬ã‚¢ã‚’å¸¸ã«å¯è¦–ã«ã™ã‚‹ãŸã‚ã®è¨­å®š
            lensFlareGroup.frustumCulled = false; // è¦–éŒå°ã‚«ãƒªãƒ³ã‚°ã‚’ç„¡åŠ¹åŒ–
            lensFlareGroup.renderOrder = 999; // æœ€å‰é¢ã«æç”»
            
            // ãƒ¡ã‚¤ãƒ³ãƒ•ãƒ¬ã‚¢ï¼ˆæœ€ã‚‚æ˜ã‚‹ã„ä¸­å¿ƒéƒ¨ï¼‰- é«˜å“è³ªåŒ–
            const mainTexture = createLensFlareTexture(1024, 0xffffff, 'main');
            const mainGeometry = new THREE.PlaneGeometry(1.5, 1.5); // å¤ªé™½ã®ã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦ç¸®å°
            const mainMaterial = new THREE.MeshBasicMaterial({
                map: mainTexture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                depthTest: false, // æ·±åº¦ãƒ†ã‚¹ãƒˆã‚’ç„¡åŠ¹åŒ–
                fog: false // ãƒ•ã‚©ã‚°ã®å½±éŸ¿ã‚’å—ã‘ãªã„
            });
            const mainFlare = new THREE.Mesh(mainGeometry, mainMaterial);
            mainFlare.frustumCulled = false; // å€‹åˆ¥ã§ã‚‚è¦–éŒå°ã‚«ãƒªãƒ³ã‚°ã‚’ç„¡åŠ¹åŒ–
            mainFlare.renderOrder = 999;
            lensFlareGroup.add(mainFlare);
            
            // ã‚µãƒ–ãƒ•ãƒ¬ã‚¢ï¼ˆè¤‡æ•°ã®å°ã•ãªå…‰ï¼‰- é«˜å“è³ªåŒ–
            const subTexture = createLensFlareTexture(512, 0xffffff, 'sub');
            const hexagonTexture = createLensFlareTexture(256, 0xffffff, 'hexagon');
            const starTexture = createLensFlareTexture(256, 0xffffff, 'star');
            
            const flareData = [
                { size: 0.6, distance: 0.4, opacity: 0.6, texture: subTexture, color: 0xffffff },
                { size: 0.4, distance: 0.6, opacity: 0.5, texture: hexagonTexture, color: 0xffeeaa },
                { size: 0.5, distance: 0.8, opacity: 0.4, texture: subTexture, color: 0xffdddd },
                { size: 0.3, distance: 1.0, opacity: 0.5, texture: starTexture, color: 0xaaffff },
                { size: 0.4, distance: 1.3, opacity: 0.3, texture: subTexture, color: 0xffaaaa },
                { size: 0.25, distance: 1.5, opacity: 0.4, texture: hexagonTexture, color: 0xffffaa },
                { size: 0.35, distance: 1.8, opacity: 0.2, texture: subTexture, color: 0xaaffaa }
            ];
            
            flareData.forEach(data => {
                const geometry = new THREE.PlaneGeometry(data.size, data.size);
                const material = new THREE.MeshBasicMaterial({
                    map: data.texture,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    depthTest: false, // æ·±åº¦ãƒ†ã‚¹ãƒˆã‚’ç„¡åŠ¹åŒ–
                    fog: false, // ãƒ•ã‚©ã‚°ã®å½±éŸ¿ã‚’å—ã‘ãªã„
                    opacity: data.opacity,
                    color: new THREE.Color(data.color)
                });
                const flare = new THREE.Mesh(geometry, material);
                flare.userData = { distance: data.distance, baseOpacity: data.opacity };
                flare.frustumCulled = false; // å€‹åˆ¥ã§ã‚‚è¦–éŒå°ã‚«ãƒªãƒ³ã‚°ã‚’ç„¡åŠ¹åŒ–
                flare.renderOrder = 999;
                lensFlareGroup.add(flare);
            });
            
            lensFlareGroup.userData = { isLensFlare: true };
            return lensFlareGroup;
        }

        // ãƒ¬ãƒ³ã‚ºãƒ•ãƒ¬ã‚¢æ›´æ–°
        function updateLensFlare(lensFlare, sunPosition) {
            if (!lensFlare || !sunPosition) return;
            
            // ã‚«ãƒ¡ãƒ©ã‹ã‚‰å¤ªé™½ã¸ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆæ­£ç¢ºãªè¨ˆç®—ï¼‰
            const cameraWorldPosition = new THREE.Vector3();
            camera.getWorldPosition(cameraWorldPosition);
            const sunDirection = new THREE.Vector3().subVectors(sunPosition, cameraWorldPosition).normalize();
            
            // ãƒ¬ãƒ³ã‚ºãƒ•ãƒ¬ã‚¢ã‚’ç¢ºå®Ÿã«å¤ªé™½ã®ä½ç½®ã«é…ç½®
            lensFlare.position.copy(sunPosition);
            
            // ãƒ¬ãƒ³ã‚ºãƒ•ãƒ¬ã‚¢ã‚’ã‚«ãƒ¡ãƒ©ã®æ–¹å‘ã«å‘ã‘ã‚‹ï¼ˆã‚ˆã‚Šå®‰å®šã—ãŸè¨ˆç®—ï¼‰
            lensFlare.lookAt(cameraWorldPosition);
            
            // è·é›¢ã«é–¢ä¿‚ãªãå¸¸ã«å¯è¦–æ€§ã‚’ä¿è¨¼
            lensFlare.visible = true;
            lensFlare.frustumCulled = false;
            
            // å„ãƒ•ãƒ¬ã‚¢è¦ç´ ã®é€æ˜åº¦ã¨ä½ç½®ã‚’èª¿æ•´ï¼ˆå®‰å®šæ€§å‘ä¸Šãƒ»è·é›¢éä¾å­˜ï¼‰
            lensFlare.children.forEach((flare, index) => {
                if (flare && flare.material) {
                    // è·é›¢ã«ã‚ˆã‚‹æ¶ˆå¤±ã‚’é˜²ããŸã‚ã®å¼·åˆ¶è¨­å®š
                    flare.visible = true;
                    flare.frustumCulled = false;
                    flare.renderOrder = 999;
                    
                    if (index === 0) {
                        // ãƒ¡ã‚¤ãƒ³ãƒ•ãƒ¬ã‚¢ï¼ˆå¸¸ã«å¤ªé™½ã®ä¸­å¿ƒï¼‰
                        flare.position.set(0, 0, 0); // ç›¸å¯¾ä½ç½®ã‚’ãƒªã‚»ãƒƒãƒˆ
                        flare.material.opacity = 0.8; // è·é›¢ã«é–¢ä¿‚ãªãä¸€å®šã®é€æ˜åº¦
                    } else {
                        // ã‚µãƒ–ãƒ•ãƒ¬ã‚¢ï¼ˆå¤ªé™½ã‹ã‚‰é›¢ã‚ŒãŸä½ç½®ã«é…ç½®ï¼‰
                        const baseOpacity = flare.userData.baseOpacity || 0.5;
                        flare.material.opacity = baseOpacity * 0.7; // è·é›¢ã«é–¢ä¿‚ãªãä¸€å®šã®é€æ˜åº¦
                        
                        // ã‚µãƒ–ãƒ•ãƒ¬ã‚¢ã‚’å¤ªé™½ã‹ã‚‰æ”¾å°„çŠ¶ã«é…ç½®ï¼ˆã‚ˆã‚Šå®‰å®šã—ãŸè¨ˆç®—ï¼‰
                        const distance = flare.userData.distance || 1;
                        const offset = sunDirection.clone().multiplyScalar(-distance * 0.8);
                        flare.position.copy(offset);
                    }
                }
            });
        }

        // WebXRã‚µãƒãƒ¼ãƒˆãƒã‚§ãƒƒã‚¯
        async function checkXRSupport() {
            if ('xr' in navigator) {
                try {
                    const supported = await navigator.xr.isSessionSupported('immersive-ar');
                    xrSupported = supported;
                } catch (error) {
                    try {
                        const supported = await navigator.xr.isSessionSupported('immersive-vr');
                        xrSupported = supported;
                    } catch (error) {
                        xrSupported = false;
                    }
                }
            }

            const button = document.getElementById('xr-button');
            button.disabled = true; // åˆæœŸçŠ¶æ…‹ã§ã¯ç„¡åŠ¹
            
            if (!xrSupported) {
                button.textContent = 'XRéå¯¾å¿œãƒ‡ãƒã‚¤ã‚¹';
                document.getElementById('warning-panel').style.display = 'block';
            } else {
                button.textContent = 'èª­ã¿è¾¼ã¿ä¸­...';
            }
        }

        // åˆæœŸåŒ–
        function init() {
            const container = document.getElementById('container');

            // BGMåˆæœŸåŒ–
            bgMusic = document.getElementById('bgm');
            bgMusic.volume = 0.3; // éŸ³é‡ã‚’30%ã«è¨­å®š
            
            // ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ã‚¿ãƒ¼åˆæœŸåŒ–
            raycaster = new THREE.Raycaster();

            // ã‚·ãƒ¼ãƒ³ä½œæˆ
            scene = new THREE.Scene();

            // ã‚«ãƒ¡ãƒ©ä½œæˆï¼ˆfarè·é›¢ã‚’æ‹¡å¼µã—ã¦ãƒ¬ãƒ³ã‚ºãƒ•ãƒ¬ã‚¢ã®æ¶ˆå¤±ã‚’é˜²æ­¢ï¼‰
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.001, 10000);
            camera.position.set(0, 1.6, 5);

            // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ä½œæˆ
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            // å¤ªé™½ç³»ã‚°ãƒ«ãƒ¼ãƒ—
            solarSystemGroup = new THREE.Group();
            solarSystemGroup.position.set(0, 1, -2);
            scene.add(solarSystemGroup);
            registerUniverseElement(solarSystemGroup);
            
            // åˆæœŸãƒ¦ãƒ¼ã‚¶ãƒ¼ä½ç½®ã‚’è¨­å®š
            updateUserPosition();

            // æ˜Ÿç©º
            const stars = createStarField();
            scene.add(stars);
            originalStars = stars; // å…ƒã®æ˜Ÿç©ºã‚’ä¿å­˜
            registerUniverseElement(stars);

            // å®‡å®™ç©ºé–“ã®æ˜Ÿç©ºã‚’æº–å‚™ï¼ˆæœ€åˆã¯éè¡¨ç¤ºï¼‰
            spaceStars = createSpaceStarField();
            spaceStars.visible = false;
            scene.add(spaceStars);
            registerUniverseElement(spaceStars);

            // èƒŒæ™¯ãƒ•ã‚§ãƒ¼ãƒ‰ç”¨çƒä½“ã‚’ä½œæˆ
            backgroundSphere = createBackgroundSphere();
            scene.add(backgroundSphere);

            // ãƒ¡ã‚¤ãƒ³å¤ªé™½å…‰æºï¼ˆç™½é£›ã³é˜²æ­¢ã®ãŸã‚ã•ã‚‰ã«èª¿æ•´ï¼‰
            const sunLight = new THREE.PointLight(0xFFFFDD, 2.5, 100);
            sunLight.position.set(0, 0, 0);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 4096;
            sunLight.shadow.mapSize.height = 4096;
            sunLight.shadow.camera.near = 0.1;
            sunLight.shadow.camera.far = 100;
            solarSystemGroup.add(sunLight);
            
            // è¿½åŠ ã®å¤ªé™½å…‰æºï¼ˆæ§ãˆã‚ã«ï¼‰
            const sunLight2 = new THREE.PointLight(0xFFDD88, 1.2, 80);
            sunLight2.position.set(0, 0, 0);
            solarSystemGroup.add(sunLight2);
            
            // å¤ªé™½ã‚³ãƒ­ãƒŠå…‰æºï¼ˆã•ã‚‰ã«æ§ãˆã‚ã«ï¼‰
            const coronaLight = new THREE.PointLight(0xFFFFFF, 0.6, 60);
            coronaLight.position.set(0, 0, 0);
            solarSystemGroup.add(coronaLight);

            // ç’°å¢ƒå…‰ï¼ˆãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ãƒ‡ã‚£ãƒ†ãƒ¼ãƒ«ã‚’ä¿è­·ï¼‰
            const ambientLight = new THREE.AmbientLight(0x404080, 0.3);
            scene.add(ambientLight);

            // å°æƒ‘æ˜Ÿå¸¯ã‚’ä½œæˆï¼ˆç«æ˜Ÿã¨æœ¨æ˜Ÿã®é–“ï¼‰
            createAsteroidBelt();
            
            // ã‚«ã‚¤ãƒ‘ãƒ¼ãƒ™ãƒ«ãƒˆã‚’ä½œæˆï¼ˆæµ·ç‹æ˜Ÿã®å¤–å´ï¼‰
            createKuiperBelt();
            
            // å¤ªé™½ç³»å¤–ã®æ’æ˜Ÿã‚’ä½œæˆ
            createDistantStars();
            
            // é æ–¹ã®éŠ€æ²³ã‚’ä½œæˆ
            createDistantGalaxies();
            
            // æœ‰åãªæ˜Ÿåº§ã‚’ä½œæˆ
            createConstellations();
            
            // æƒ‘æ˜Ÿä½œæˆ
            planetData.forEach((data, index) => {
                const geometry = new THREE.SphereGeometry(data.size, 64, 32); // ã‚ˆã‚Šé«˜å“è³ªãªã‚¸ã‚ªãƒ¡ãƒˆãƒª
                const texture = createPlanetTexture(data.type, 2048); // é«˜è§£åƒåº¦ãƒ†ã‚¯ã‚¹ãƒãƒ£
                
                let material;
                if (data.name === 'å¤ªé™½') {
                    material = new THREE.MeshBasicMaterial({ 
                        map: texture,
                        emissive: new THREE.Color(0xFFFFFF), // ç´”ç™½ã®å¼·åŠ›ãªç™ºå…‰
                        emissiveIntensity: 6.0, // ã•ã‚‰ã«å¼·åŒ–ã—ã¦ãƒªã‚¢ãƒ«ãªè¼ãã«
                        transparent: false,
                        side: THREE.DoubleSide
                    });
                    
                    // ã‚·ãƒ³ãƒ—ãƒ«ã§è‡ªç„¶ãªã‚°ãƒ­ãƒ¼åŠ¹æœã®ã¿
                    const glowGeometry = new THREE.SphereGeometry(data.size * 1.05, 16, 12); // éå¸¸ã«è–„ã„å±¤
                    const glowMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            time: { value: 0 },
                            glowColor: { value: new THREE.Color(0xFFFF88) }
                        },
                        vertexShader: `
                            varying vec3 vNormal;
                            void main() {
                                vNormal = normalize(normalMatrix * normal);
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform float time;
                            uniform vec3 glowColor;
                            varying vec3 vNormal;
                            void main() {
                                float intensity = pow(0.4 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 0.8);
                                intensity *= (0.6 + 0.1 * sin(time * 2.0)); // å¾®ç´°ãªè„ˆå‹•
                                intensity *= 0.3; // æ§ãˆã‚ãªå¼·åº¦
                                gl_FragColor = vec4(glowColor, intensity);
                            }
                        `,
                        side: THREE.BackSide,
                        blending: THREE.AdditiveBlending,
                        transparent: true,
                        depthWrite: false
                    });
                    const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                    data.glowMaterial = glowMaterial;
                } else {
                    material = new THREE.MeshLambertMaterial({ 
                        map: texture,
                        bumpMap: texture,
                        bumpScale: 0.001
                    });
                }
                
                const planet = new THREE.Mesh(geometry, material);
                planet.position.x = data.distance;
                planet.castShadow = data.name !== 'å¤ªé™½';
                planet.receiveShadow = data.name !== 'å¤ªé™½';
                
                // å¤ªé™½ã®å ´åˆã¯ã‚·ãƒ³ãƒ—ãƒ«ãªã‚°ãƒ­ãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’è¿½åŠ 
                if (data.name === 'å¤ªé™½' && data.glowMaterial) {
                    const glowGeometry = new THREE.SphereGeometry(data.size * 1.05, 16, 12); // è–„ã„å±¤
                    const glowMesh = new THREE.Mesh(glowGeometry, data.glowMaterial);
                    planet.add(glowMesh);
                    data.glowMesh = glowMesh; // å‚ç…§ã‚’ä¿å­˜
                    
                    // ãƒ¬ãƒ³ã‚ºãƒ•ãƒ¬ã‚¢åŠ¹æœã‚’è¿½åŠ 
                    const lensFlare = createLensFlare();
                    scene.add(lensFlare); // ã‚·ãƒ¼ãƒ³ã«ç›´æ¥è¿½åŠ ï¼ˆå¸¸ã«ã‚«ãƒ¡ãƒ©ã®æ–¹ã‚’å‘ãï¼‰
                    data.lensFlare = lensFlare; // å‚ç…§ã‚’ä¿å­˜
                    
                    // ãƒ¬ãƒ³ã‚ºãƒ•ãƒ¬ã‚¢ã®æ¶ˆå¤±ã‚’å®Œå…¨ã«é˜²ããŸã‚ã®è¿½åŠ è¨­å®š
                    lensFlare.traverse((child) => {
                        if (child.isMesh) {
                            child.frustumCulled = false;
                            child.renderOrder = 999;
                            if (child.material) {
                                child.material.depthTest = false;
                                child.material.fog = false;
                            }
                        }
                    });
                }
                
                // è»Œé“è¡¨ç¤º
                if (data.distance > 0) {
                    const orbitPoints = [];
                    for (let i = 0; i <= 64; i++) {
                        const angle = (i / 64) * Math.PI * 2;
                        orbitPoints.push(new THREE.Vector3(
                            Math.cos(angle) * data.distance,
                            0,
                            Math.sin(angle) * data.distance
                        ));
                    }
                    const orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
                    const orbitMaterial = new THREE.LineBasicMaterial({ 
                        color: 0x444444, 
                        transparent: true, 
                        opacity: 0.2
                    });
                    const orbit = new THREE.Line(orbitGeometry, orbitMaterial);
                    orbit.userData = { type: 'orbit' }; // è»Œé“ç·šã‚’è­˜åˆ¥ã™ã‚‹ã‚¿ã‚°
                    solarSystemGroup.add(orbit);
                }

                // åœŸæ˜Ÿã®ãƒªãƒ³ã‚°
                if (data.name === 'åœŸæ˜Ÿ') {
                    const ringGeometry = new THREE.RingGeometry(data.size + 0.03, data.size + 0.08, 32);
                    const ringMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xD2691E,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.8
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.PI / 2;
                    planet.add(ring);
                }

                // åœ°çƒã®æœˆ
                if (data.name === 'åœ°çƒ') {
                    const moonGeometry = new THREE.SphereGeometry(0.0035, 16, 8);
                    const moonMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                    const moon = new THREE.Mesh(moonGeometry, moonMaterial);
                    moon.position.x = 0.045;
                    moon.castShadow = true;
                    moon.userData = { speed: 0.08, distance: 0.045 };
                    planet.add(moon);
                }

                planets.push({ 
                    mesh: planet, 
                    data: data, 
                    angle: Math.random() * Math.PI * 2,
                    rotationSpeed: data.rotationSpeed
                });
                solarSystemGroup.add(planet);
            });

            setupXRControllers();
            animate();
            
            // ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å®Œäº†
            dataLoaded = true;
            
            // ãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹åŒ–
            const xrButton = document.getElementById('xr-button');
            if (xrSupported) {
                xrButton.disabled = false;
                xrButton.textContent = 'ğŸ¥½ MRå¤ªé™½ç³»ã‚’é–‹å§‹';
            }
            
            document.getElementById('loading').style.display = 'none';
        }

        // XRã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        function setupXRControllers() {
            // å‚è€ƒãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¨åŒæ§˜ã®é…åˆ—ãƒ™ãƒ¼ã‚¹ã®å®Ÿè£…
            controllers = [
                renderer.xr.getController(0),
                renderer.xr.getController(1)
            ];
            
            controllers.forEach((controller, index) => {
                if (!controller) return;
                
                const hand = index === 0 ? 'left' : 'right';
                
                controller.addEventListener('selectstart', (event) => onSelectStart(event, hand));
                controller.addEventListener('selectend', (event) => onSelectEnd(event, hand));
                controller.addEventListener('squeezestart', () => onGripStart(hand));
                controller.addEventListener('squeezeend', () => onGripEnd(hand));
                
                // ãƒ¬ãƒ¼ã‚¶ãƒ¼ãƒã‚¤ãƒ³ã‚¿ãƒ¼è¿½åŠ 
                createControllerRay(controller, 0x00ff88);
                
                scene.add(controller);
            });
            
            // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚°ãƒªãƒƒãƒ—ã‚‚è¿½åŠ 
            const leftControllerGrip = renderer.xr.getControllerGrip(0);
            const rightControllerGrip = renderer.xr.getControllerGrip(1);
            scene.add(leftControllerGrip);
            scene.add(rightControllerGrip);
            
            console.log('XR Controllers setup completed');
        }
        
        // ãƒ¬ãƒ¼ã‚¶ãƒ¼ãƒã‚¤ãƒ³ã‚¿ãƒ¼ä½œæˆé–¢æ•°
        function createControllerRay(controller, color) {
            // é•·ã„ãƒ¬ãƒ¼ã‚¶ãƒ¼ã‚’ä½œæˆï¼ˆé€”åˆ‡ã‚Œãªã„ã‚ˆã†ã«ï¼‰
            const geometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, -50) // é•·ã„ãƒ¬ãƒ¼ã‚¶ãƒ¼
            ]);
            const material = new THREE.LineBasicMaterial({ 
                color: color, 
                transparent: true, 
                opacity: 0.8 
            });

            const ray = new THREE.Line(geometry, material);
            ray.userData.isRay = true;
            ray.userData.originalLength = 50; // å…ƒã®é•·ã•ã‚’è¨˜éŒ²
            controller.add(ray);
            
            // ã‚«ãƒ¼ã‚½ãƒ«ï¼ˆä¸¸ã„éƒ¨åˆ†ï¼‰ã¯å‰Šé™¤
        }
        
        // ãƒ¬ãƒ¼ã‚¶ãƒ¼ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã®é•·ã•ã‚’èª¿æ•´ã™ã‚‹é–¢æ•°
        function updateControllerRayLength(controller, intersects) {
            const ray = controller.children.find(child => child.userData.isRay);
            if (!ray) return;
            
            let targetLength = ray.userData.originalLength; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®é•·ã•
            
            if (intersects.length > 0) {
                // æœ€ã‚‚è¿‘ã„äº¤å·®ç‚¹ã¾ã§ã®è·é›¢
                targetLength = Math.min(intersects[0].distance, ray.userData.originalLength);
            }
            
            // ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’æ›´æ–°
            const positions = ray.geometry.attributes.position.array;
            positions[5] = -targetLength; // zåº§æ¨™ã‚’æ›´æ–°
            ray.geometry.attributes.position.needsUpdate = true;
        }
        
        // æƒ…å ±ãƒ‘ãƒãƒ«è¡¨ç¤ºä¸­ã®ã‚«ãƒ¼ã‚½ãƒ«è¡¨ç¤ºåˆ¶å¾¡
        function updateControllerRayVisibility(controller, controllerIndex) {
            const ray = controller.children.find(child => child.userData.isRay);
            if (!ray) return;
            
            // æƒ…å ±ãƒ‘ãƒãƒ«ãŒè¡¨ç¤ºä¸­ã§ã€ã‹ã¤ãã®ãƒ‘ãƒãƒ«ãŒã“ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã«ä»˜ã„ã¦ã„ã‚‹å ´åˆã¯éè¡¨ç¤º
            if (planetInfoVisible && planetInfoPanel && 
                controllers.length > 0 && controllers[0] === controller && 
                planetInfoPanel.parent === controller) {
                ray.visible = false;
            } else {
                ray.visible = true;
            }
        }

        // XRã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
        function onSelectStart(event, hand) {
            console.log('ãƒˆãƒªã‚¬ãƒ¼æŠ¼ä¸‹:', hand, 'ãƒ‘ãƒãƒ«å­˜åœ¨:', !!planetInfoPanel, 'è¡¨ç¤ºçŠ¶æ…‹:', planetInfoVisible, 'ã‚¯ãƒ­ãƒ¼ã‚ºä¸­:', panelClosing);
            
            // ã“ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
            const controllerIndex = hand === 'left' ? 0 : 1;
            const thisControllerHighlight = highlightedPlanets[controllerIndex];
            
            // ãƒ‘ãƒãƒ«ã‚¯ãƒ­ãƒ¼ã‚ºå‡¦ç†ä¸­ã¯ä½•ã‚‚ã—ãªã„
            if (panelClosing) {
                console.log('ãƒ‘ãƒãƒ«ã‚¯ãƒ­ãƒ¼ã‚ºå‡¦ç†ä¸­ã€æ“ä½œç„¡åŠ¹');
                return;
            }
            
            // æƒ…å ±ãƒ‘ãƒãƒ«ãŒè¡¨ç¤ºä¸­ã®å ´åˆã¯é–‰ã˜ã‚‹
            if (planetInfoPanel && planetInfoVisible) {
                console.log('æƒ…å ±ãƒ‘ãƒãƒ«ã‚’é–‰ã˜ã¾ã™');
                hide3DPlanetInfo();
                return;
            }
            
            if (spaceMode) {
                // å®‡å®™ç©ºé–“ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆ
                if (thisControllerHighlight) {
                    // ã“ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã§ãƒã‚¤ãƒ©ã‚¤ãƒˆã•ã‚Œã¦ã„ã‚‹æƒ‘æ˜Ÿã®æƒ…å ±è¡¨ç¤º
                    console.log('æƒ‘æ˜Ÿæƒ…å ±ã‚’è¡¨ç¤º:', thisControllerHighlight.data.name);
                    show3DPlanetInfo(thisControllerHighlight.data);
                } else {
                    // ã“ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã§ä½•ã‚‚ãƒã‚¤ãƒ©ã‚¤ãƒˆã•ã‚Œã¦ã„ãªã„å ´åˆã¯MRãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã‚‹
                    console.log('MRãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆ');
                    toggleSpaceMode();
                }
                return;
            }
            
            // MRãƒ¢ãƒ¼ãƒ‰ã§ã®æ“ä½œ
            if (thisControllerHighlight) {
                // ã“ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã§ãƒã‚¤ãƒ©ã‚¤ãƒˆã•ã‚Œã¦ã„ã‚‹æƒ‘æ˜Ÿæƒ…å ±ã‚’è¨˜éŒ²ã—ã¦VRãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆ
                console.log('VRãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆ:', thisControllerHighlight.data.name);
                pendingPlanetInfo = thisControllerHighlight.data;
                toggleSpaceMode();
            }
        }

        function onSelectEnd(event, hand) {
            // ãƒˆãƒªã‚¬ãƒ¼çµ‚äº†
        }

        function onGripStart(hand) {
            gripStates[hand] = true;
            
            // ç‰‡æ‰‹ã‚°ãƒªãƒƒãƒ—ã®å ´åˆã¯ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹
            if (((gripStates.left && !gripStates.right) || (!gripStates.left && gripStates.right)) && controllers.length > 0) {
                isDragging = true;
                const controller = gripStates.left ? controllers[0] : controllers[1];
                if (controller) {
                    const tempMatrix = new THREE.Matrix4();
                    tempMatrix.identity().extractRotation(controller.matrixWorld);
                    dragStartPosition.setFromMatrixPosition(controller.matrixWorld);
                    userStartPosition.copy(userPosition);
                }
            }
            
            // ä¸¡æ‰‹ã§ã‚°ãƒªãƒƒãƒ—ã—ãŸå ´åˆã®åˆæœŸè·é›¢ã‚’è¨˜éŒ²
            if (gripStates.left && gripStates.right && controllers.length >= 2 && controllers[0] && controllers[1]) {
                isDragging = false;
                const leftPos = new THREE.Vector3();
                const rightPos = new THREE.Vector3();
                leftPos.setFromMatrixPosition(controllers[0].matrixWorld);
                rightPos.setFromMatrixPosition(controllers[1].matrixWorld);
                lastDistance = leftPos.distanceTo(rightPos);
            }
            
            updateGripStatus();
        }

        function onGripEnd(hand) {
            gripStates[hand] = false;
            isDragging = false;
            updateGripStatus();
        }

        function updateGripStatus() {
            const gripStatus = document.getElementById('grip-status');
            const isGripping = gripStates.left && gripStates.right;
            gripStatus.textContent = isGripping ? 'ON' : 'OFF';
            gripStatus.style.color = isGripping ? '#00ff88' : '#ffffff';
        }

        // 3Dæƒ‘æ˜Ÿæƒ…å ±ãƒ‘ãƒãƒ«ä½œæˆ
        function create3DInfoPanel(planetData) {
            const canvas = document.createElement('canvas');
            canvas.width = 600; // ã‚µã‚¤ã‚ºã‚’å¤§ãã
            canvas.height = 700;
            const ctx = canvas.getContext('2d');
            
            // èƒŒæ™¯
            ctx.fillStyle = 'rgba(0, 20, 40, 0.95)';
            ctx.fillRect(0, 0, 600, 700);
            
            // æ ç·š
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 4;
            ctx.strokeRect(0, 0, 600, 700);
            
            // å†…å´ã®è£…é£¾æ 
            ctx.strokeStyle = 'rgba(0, 255, 136, 0.3)';
            ctx.lineWidth = 2;
            ctx.strokeRect(10, 10, 580, 680);
            
            // æƒ‘æ˜Ÿå
            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 42px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(planetData.name, 300, 60);
            
            // ã‚¢ãƒ³ãƒ€ãƒ¼ãƒ©ã‚¤ãƒ³
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(100, 75);
            ctx.lineTo(500, 75);
            ctx.stroke();
            
            // åŸºæœ¬æƒ…å ±é …ç›®ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼ˆç°¡ç•¥åŒ–ï¼‰
            ctx.textAlign = 'left';
            let yPos = 120;
            const lineHeight = 40;
            
            const infoItems = [
                { label: 'è·é›¢', value: planetData.realDistance, icon: 'ğŸŒ' },
                { label: 'ã‚µã‚¤ã‚º', value: planetData.realSize, icon: 'ğŸ“' },
                { label: 'å…¬è»¢å‘¨æœŸ', value: planetData.period, icon: 'ğŸ”„' },
                { label: 'ç™ºè¦‹', value: planetData.discovery, icon: 'ğŸ”­' }
            ];
            
            infoItems.forEach(item => {
                // ã‚¢ã‚¤ã‚³ãƒ³
                ctx.font = '22px Arial';
                ctx.fillStyle = '#ffffff';
                ctx.fillText(item.icon, 30, yPos);
                
                // ãƒ©ãƒ™ãƒ«
                ctx.fillStyle = '#ffaa00';
                ctx.font = 'bold 22px Arial';
                ctx.fillText(item.label + ':', 70, yPos);
                
                // å€¤
                ctx.fillStyle = '#ffffff';
                ctx.font = '20px Arial';
                const labelWidth = ctx.measureText(item.label + ': ').width;
                ctx.fillText(item.value, 70 + labelWidth, yPos);
                
                yPos += lineHeight;
            });
            
            // ç‰¹å¾´ã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆã‚ˆã‚Šå¤§ããï¼‰
            yPos += 30;
            ctx.fillStyle = '#ffaa00';
            ctx.font = 'bold 28px Arial';
            ctx.fillText('âœ¨ ç‰¹å¾´:', 30, yPos);
            
            yPos += 40;
            ctx.fillStyle = '#ffffff';
            ctx.font = '18px Arial';
            
            // ç‰¹å¾´ãƒ†ã‚­ã‚¹ãƒˆã‚’è¤‡æ•°è¡Œã«åˆ†å‰²ï¼ˆã‚ˆã‚Šè©³ç´°ã«ï¼‰
            const features = planetData.feature;
            const maxWidth = 520;
            const words = features.split('');
            let line = '';
            
            for (let i = 0; i < words.length; i++) {
                const testLine = line + words[i];
                const metrics = ctx.measureText(testLine);
                
                if (metrics.width > maxWidth && i > 0) {
                    ctx.fillText(line, 50, yPos);
                    line = words[i];
                    yPos += 24;
                } else {
                    line = testLine;
                }
            }
            ctx.fillText(line, 50, yPos);
            
            // è±†çŸ¥è­˜ã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆã‚ˆã‚Šå¤§ããï¼‰
            yPos += 50;
            ctx.fillStyle = '#00ddff';
            ctx.font = 'bold 28px Arial';
            ctx.fillText('ğŸ’¡ è±†çŸ¥è­˜:', 30, yPos);
            
            yPos += 40;
            ctx.fillStyle = '#ddffdd';
            ctx.font = '18px Arial';
            
            // è±†çŸ¥è­˜ãƒ†ã‚­ã‚¹ãƒˆã‚’è¤‡æ•°è¡Œã«åˆ†å‰²ï¼ˆã‚ˆã‚Šè©³ç´°ã«ï¼‰
            const facts = planetData.fact;
            const factWords = facts.split('');
            let factLine = '';
            
            for (let i = 0; i < factWords.length; i++) {
                const testLine = factLine + factWords[i];
                const metrics = ctx.measureText(testLine);
                
                if (metrics.width > maxWidth && i > 0) {
                    ctx.fillText(factLine, 50, yPos);
                    factLine = factWords[i];
                    yPos += 24;
                } else {
                    factLine = testLine;
                }
            }
            ctx.fillText(factLine, 50, yPos);
            
            // æ“ä½œèª¬æ˜
            ctx.fillStyle = '#888888';
            ctx.font = '18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ãƒˆãƒªã‚¬ãƒ¼ã§é–‰ã˜ã‚‹', 300, 660);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            return texture;
        }

        function show3DPlanetInfo(planetData) {
            console.log('show3DPlanetInfo called for:', planetData.name, 'Current state - visible:', planetInfoVisible, 'closing:', panelClosing, 'panel exists:', !!planetInfoPanel);
            
            // åŠ¹æœéŸ³ã‚’å†ç”Ÿ
            playInfoPanelSound();
            
            // å¼·åˆ¶çš„ã«æ—¢å­˜ãƒ‘ãƒãƒ«ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            forceCleanupPanel();
            
            // æ–°ã—ã„ãƒ‘ãƒãƒ«ã‚’ä½œæˆ
            setTimeout(() => {
                createNewInfoPanel(planetData);
            }, 100); // çŸ­æ™‚é–“å¾…ã£ã¦ã‹ã‚‰ä½œæˆ
        }
        
        function forceCleanupPanel() {
            console.log('Force cleanup panel, current panel:', !!planetInfoPanel);
            
            if (planetInfoPanel) {
                try {
                    // è¦ªã‹ã‚‰ç¢ºå®Ÿã«å‰Šé™¤
                    if (planetInfoPanel.parent) {
                        planetInfoPanel.parent.remove(planetInfoPanel);
                        console.log('Removed from parent');
                    }
                    
                    // ã‚·ãƒ¼ãƒ³ã‹ã‚‰ã‚‚å‰Šé™¤
                    scene.remove(planetInfoPanel);
                    console.log('Removed from scene');
                    
                    // ãƒãƒ†ãƒªã‚¢ãƒ«ã¨ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’å®Œå…¨ã«è§£æ”¾
                    if (planetInfoPanel.material) {
                        if (planetInfoPanel.material.map) {
                            planetInfoPanel.material.map.dispose();
                            console.log('Texture disposed');
                        }
                        planetInfoPanel.material.dispose();
                        console.log('Material disposed');
                    }
                    
                    // ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’è§£æ”¾
                    if (planetInfoPanel.geometry) {
                        planetInfoPanel.geometry.dispose();
                        console.log('Geometry disposed');
                    }
                    
                    // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®å¼·åˆ¶æ›´æ–°
                    if (renderer) {
                        renderer.renderLists.dispose();
                    }
                    
                } catch (error) {
                    console.error('Error during panel cleanup:', error);
                }
                
                planetInfoPanel = null;
                console.log('Panel reference set to null');
            }
            
            // çŠ¶æ…‹ã‚’å®Œå…¨ã«ãƒªã‚»ãƒƒãƒˆ
            planetInfoVisible = false;
            panelClosing = false;
            panelFadeAnimation.opacity = 0;
            panelFadeAnimation.target = 0;
            
            // å…¨ã¦ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ã‚«ãƒ¼ã‚½ãƒ«ã‚’å†è¡¨ç¤º
            if (controllers && controllers.length > 0) {
                controllers.forEach(controller => {
                    if (controller) {
                        const ray = controller.children.find(child => child.userData.isRay);
                        if (ray) {
                            ray.visible = true;
                        }
                    }
                });
            }
            
            console.log('Panel cleanup completed - all states reset');
        }
        
        function createNewInfoPanel(planetData) {
            console.log('Creating new info panel for:', planetData.name);
            
            // åŠ¹æœéŸ³ã¯ show3DPlanetInfo ã§å†ç”Ÿæ¸ˆã¿ãªã®ã§ã“ã“ã§ã¯å†ç”Ÿã—ãªã„
            
            const texture = create3DInfoPanel(planetData);
            const geometry = new THREE.PlaneGeometry(0.35, 0.4);
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                side: THREE.DoubleSide,
                opacity: 0, // åˆæœŸå€¤ã‚’0ã«è¨­å®š
                alphaTest: 0.01 // å®Œå…¨ã«é€æ˜ãªéƒ¨åˆ†ã¯æç”»ã—ãªã„
            });
            
            planetInfoPanel = new THREE.Mesh(geometry, material);
            planetInfoPanel.name = 'planet-info-panel';
            
            // å·¦æ‰‹ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ä½ç½®ã«é…ç½®
            if (controllers.length > 0 && controllers[0]) {
                controllers[0].add(planetInfoPanel);
                planetInfoPanel.position.set(0, 0.1, -0.2);
                planetInfoPanel.rotation.x = -Math.PI / 6;
            } else {
                scene.add(planetInfoPanel);
                planetInfoPanel.position.set(-0.5, 1.8, -1);
            }
            
            // çŠ¶æ…‹ã‚’è¨­å®š
            planetInfoVisible = true;
            panelClosing = false;
            
            // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
            panelFadeAnimation.target = 1;
            panelFadeAnimation.opacity = 0;
            
            console.log('New panel created and fade-in started');
        }

        function hide3DPlanetInfo() {
            console.log('hide3DPlanetInfo called, panel exists:', !!planetInfoPanel, 'closing:', panelClosing, 'visible:', planetInfoVisible);
            
            if (planetInfoPanel && !panelClosing) {
                // ã‚¯ãƒ­ãƒ¼ã‚ºå‡¦ç†ä¸­ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
                panelClosing = true;
                
                // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
                panelFadeAnimation.target = 0;
                console.log('ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹');
                
                // è¡¨ç¤ºçŠ¶æ…‹ã‚’å³åº§ã«æ›´æ–°ï¼ˆãƒˆãƒªã‚¬ãƒ¼åˆ¤å®šç”¨ï¼‰
                planetInfoVisible = false;
            } else if (!planetInfoPanel) {
                console.log('No panel to hide, resetting states');
                // ãƒ‘ãƒãƒ«ãŒãªã„å ´åˆã‚‚çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                forceCleanupPanel();
            } else if (panelClosing) {
                console.log('Panel already closing');
            }
        }

        // ãƒ‘ãƒãƒ«ã‚’å®Œå…¨ã«å‰Šé™¤ã™ã‚‹é–¢æ•°
        function removePlanetInfoPanel() {
            console.log('removePlanetInfoPanel called - delegating to forceCleanupPanel');
            forceCleanupPanel(); // çµ±ä¸€ã•ã‚ŒãŸå‰Šé™¤å‡¦ç†ã‚’ä½¿ç”¨
        }

        // ãƒã‚¤ãƒ©ã‚¤ãƒˆåŠ¹æœ
        function highlightPlanet(planet, controllerIndex) {
            if (highlightedPlanets[controllerIndex] && highlightedPlanets[controllerIndex] !== planet) {
                // å‰ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’å‰Šé™¤
                removeHighlight(highlightedPlanets[controllerIndex], controllerIndex);
            }
            
            highlightedPlanets[controllerIndex] = planet;
            
            try {
                const material = planet.mesh.material;
                
                // å¤ªé™½ã®å ´åˆã¯ç‰¹åˆ¥å‡¦ç†ï¼ˆã‚¹ãƒ ãƒ¼ã‚ºãªã‚¹ã‚±ãƒ¼ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
                if (planet.data.name === 'å¤ªé™½') {
                    // å¤ªé™½ã®å ´åˆã¯ã‚¹ã‚±ãƒ¼ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é–‹å§‹
                    if (!planet.originalScale) {
                        planet.originalScale = planet.mesh.scale.clone();
                        sunScaleAnimation.current = 1;
                    }
                    sunScaleAnimation.target = 1.1;
                } else {
                    // ä»–ã®æƒ‘æ˜Ÿã¯ç™ºå…‰åŠ¹æœ
                    if (!planet.originalEmissive) {
                        if (material.emissive) {
                            planet.originalEmissive = material.emissive.clone();
                        } else {
                            planet.originalEmissive = new THREE.Color(0x000000);
                        }
                        
                        if (material.emissiveIntensity !== undefined) {
                            planet.originalEmissiveIntensity = material.emissiveIntensity;
                        } else {
                            planet.originalEmissiveIntensity = 0;
                        }
                    }
                    
                    // ç™ºå…‰åŠ¹æœã‚’è¨­å®š
                    if (!material.emissive) {
                        material.emissive = new THREE.Color();
                    }
                    material.emissive.setHex(0x00ff88);
                    
                    if (material.emissiveIntensity !== undefined) {
                        material.emissiveIntensity = 0.3;
                    }
                }
            } catch (error) {
                console.error(`Error highlighting planet ${planet.data.name}:`, error);
            }
        }

        function removeHighlight(planet, controllerIndex) {
            try {
                if (planet && planet.mesh) {
                    // ã“ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ä»¥å¤–ã§ã‚‚ãƒã‚¤ãƒ©ã‚¤ãƒˆã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                    const otherControllerIndex = controllerIndex === 0 ? 1 : 0;
                    const stillHighlighted = highlightedPlanets[otherControllerIndex] === planet;
                    
                    if (!stillHighlighted) {
                        // ä»–ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã§ãƒã‚¤ãƒ©ã‚¤ãƒˆã•ã‚Œã¦ã„ãªã„å ´åˆã®ã¿ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’å‰Šé™¤
                        if (planet.data.name === 'å¤ªé™½') {
                            // å¤ªé™½ã®å ´åˆã¯ã‚¹ã‚±ãƒ¼ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å…ƒã«æˆ»ã™
                            sunScaleAnimation.target = 1;
                        } else {
                            // ä»–ã®æƒ‘æ˜Ÿã¯ç™ºå…‰ã‚’å…ƒã«æˆ»ã™
                            if (planet.mesh.material && planet.originalEmissive) {
                                const material = planet.mesh.material;
                                
                                if (material.emissive && planet.originalEmissive) {
                                    material.emissive.copy(planet.originalEmissive);
                                }
                                
                                if (material.emissiveIntensity !== undefined && planet.originalEmissiveIntensity !== undefined) {
                                    material.emissiveIntensity = planet.originalEmissiveIntensity;
                                }
                                
                                planet.originalEmissive = null;
                                planet.originalEmissiveIntensity = null;
                            }
                        }
                    }
                }
            } catch (error) {
                console.error(`Error removing highlight from planet:`, error);
            }
        }

        function clearHighlight(controllerIndex) {
            if (highlightedPlanets[controllerIndex]) {
                removeHighlight(highlightedPlanets[controllerIndex], controllerIndex);
                highlightedPlanets[controllerIndex] = null;
            }
        }
        
        function clearAllHighlights() {
            clearHighlight(0);
            clearHighlight(1);
        }

        // XRã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹
        async function startXRSession() {
            if (!xrSupported || !dataLoaded) return;

            try {
                // BGMå†ç”Ÿé–‹å§‹
                if (bgMusic) {
                    try {
                        await bgMusic.play();
                    } catch (error) {
                        console.log('BGM autoplay prevented:', error);
                        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ“ä½œå¾Œã«å†ç”Ÿã‚’è©¦ã¿ã‚‹
                    }
                }

                let sessionInit = { 
                    requiredFeatures: ['local-floor'],
                    optionalFeatures: ['hand-tracking', 'anchors', 'plane-detection']
                };
                
                let session;
                try {
                    session = await navigator.xr.requestSession('immersive-ar', sessionInit);
                } catch (arError) {
                    session = await navigator.xr.requestSession('immersive-vr', sessionInit);
                }

                await renderer.xr.setSession(session);
                xrActive = true;
                
                // XRã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹å¾Œã«ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
                setupXRControllers();

                // UIæ›´æ–°
                document.getElementById('xr-button').style.display = 'none';
                document.getElementById('instructions').style.display = 'none';
                document.getElementById('troubleshooting').style.display = 'none';
                document.getElementById('info-panel').style.display = 'block';

                session.addEventListener('end', () => {
                    xrActive = false;
                    
                    // BGMåœæ­¢
                    if (bgMusic) {
                        bgMusic.pause();
                        bgMusic.currentTime = 0;
                    }
                    
                    // 3Dæƒ…å ±ãƒ‘ãƒãƒ«ã‚’å¼·åˆ¶çš„ã«ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                    forceCleanupPanel();
                    
                    // ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’ã‚¯ãƒªã‚¢
                    clearAllHighlights();
                    
                    // ä¿ç•™ä¸­ã®æƒ‘æ˜Ÿæƒ…å ±ã‚‚ã‚¯ãƒªã‚¢
                    pendingPlanetInfo = null;
                    
                    document.getElementById('xr-button').style.display = 'block';
                    document.getElementById('instructions').style.display = 'block';
                    document.getElementById('troubleshooting').style.display = 'block';
                    document.getElementById('info-panel').style.display = 'none';
                });

            } catch (error) {
                alert('XRã‚»ãƒƒã‚·ãƒ§ãƒ³ã®é–‹å§‹ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
            }
        }

        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
        let time = 0;
        function animate() {
            renderer.setAnimationLoop(animate);
            time += 0.01;

            // å¤ªé™½ã®ã‚¹ã‚±ãƒ¼ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            if (Math.abs(sunScaleAnimation.current - sunScaleAnimation.target) > 0.001) {
                sunScaleAnimation.current += (sunScaleAnimation.target - sunScaleAnimation.current) * sunScaleAnimation.speed;
                
                // å¤ªé™½ã‚’è¦‹ã¤ã‘ã¦ã‚¹ã‚±ãƒ¼ãƒ«ã‚’é©ç”¨
                const sunPlanet = planets.find(p => p.data.name === 'å¤ªé™½');
                if (sunPlanet && sunPlanet.originalScale) {
                    sunPlanet.mesh.scale.copy(sunPlanet.originalScale);
                    sunPlanet.mesh.scale.multiplyScalar(sunScaleAnimation.current);
                }
            }

            // æƒ…å ±ãƒ‘ãƒãƒ«ã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            if (planetInfoPanel && Math.abs(panelFadeAnimation.opacity - panelFadeAnimation.target) > 0.001) {
                panelFadeAnimation.opacity += (panelFadeAnimation.target - panelFadeAnimation.opacity) * panelFadeAnimation.speed;
                
                // é€æ˜åº¦ã‚’é©ç”¨ï¼ˆ0ä»¥ä¸‹ã«ãªã‚‰ãªã„ã‚ˆã†ã«ï¼‰
                const actualOpacity = Math.max(0, Math.min(1, panelFadeAnimation.opacity));
                
                if (planetInfoPanel && planetInfoPanel.material) {
                    planetInfoPanel.material.opacity = actualOpacity;
                    
                    // å®Œå…¨ã«é€æ˜ãªå ´åˆã¯æç”»ã‚’ç„¡åŠ¹åŒ–
                    if (actualOpacity <= 0.01) {
                        planetInfoPanel.visible = false;
                    } else {
                        planetInfoPanel.visible = true;
                    }
                }
                
                // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆå®Œäº†æ™‚ã«ãƒ‘ãƒãƒ«ã‚’å‰Šé™¤ï¼ˆå®Œå…¨ã«é€æ˜ã«ãªã£ã¦ã‹ã‚‰å‰Šé™¤ï¼‰
                if (panelFadeAnimation.target === 0 && actualOpacity <= 0.01) {
                    console.log('ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆå®Œäº†ã€ãƒ‘ãƒãƒ«å‰Šé™¤');
                    removePlanetInfoPanel();
                }
            }

            // ã‚¹ãƒšãƒ¼ã‚¹ãƒ¢ãƒ¼ãƒ‰ã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            if (spaceFadeAnimation.transitioning) {
                const oldProgress = spaceFadeAnimation.progress;
                spaceFadeAnimation.progress += (spaceFadeAnimation.target - spaceFadeAnimation.progress) * spaceFadeAnimation.speed;
                
                applySpaceModeChange(spaceFadeAnimation.progress);
            }

            // å®‡å®™ç©ºé–“ãƒ¢ãƒ¼ãƒ‰ã§ã®æ˜Ÿã®å‹•ã
            if (spaceMode && spaceStars) {
                spaceRotation += 0.0001; // ã•ã‚‰ã«ã‚†ã£ãã‚Šã¨ã—ãŸå›è»¢
                spaceStars.rotation.y = spaceRotation;
                spaceStars.rotation.x = spaceRotation * 0.3;
                spaceStars.rotation.z = spaceRotation * 0.1;
            }

            // æƒ‘æ˜Ÿã®è»Œé“é‹å‹•ã¨è‡ªè»¢ï¼ˆå¸¸ã«å‹•ä½œï¼‰
            planets.forEach((planet) => {
                if (planet.data.distance > 0) {
                    planet.angle += planet.data.speed;
                    planet.mesh.position.x = Math.cos(planet.angle) * planet.data.distance;
                    planet.mesh.position.z = Math.sin(planet.angle) * planet.data.distance;
                }
                
                planet.mesh.rotation.y += planet.rotationSpeed;
                
                // å¤ªé™½ã®ã‚°ãƒ­ãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆæ›´æ–°
                if (planet.data.name === 'å¤ªé™½' && planet.data.glowMaterial) {
                    planet.data.glowMaterial.uniforms.time.value = time;
                    
                    // ãƒ¬ãƒ³ã‚ºãƒ•ãƒ¬ã‚¢åŠ¹æœã®æ›´æ–°
                    if (planet.data.lensFlare && planet.mesh) {
                        // å¤ªé™½ã®ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã‚’å–å¾—ï¼ˆã‚ˆã‚Šç¢ºå®Ÿãªæ–¹æ³•ï¼‰
                        const sunWorldPosition = new THREE.Vector3();
                        planet.mesh.updateMatrixWorld(); // ãƒãƒˆãƒªãƒƒã‚¯ã‚¹ã‚’å¼·åˆ¶æ›´æ–°
                        planet.mesh.getWorldPosition(sunWorldPosition);
                        
                        // ãƒ¬ãƒ³ã‚ºãƒ•ãƒ¬ã‚¢ãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ã‹ã‚‰æ›´æ–°
                        if (planet.data.lensFlare.parent) {
                            updateLensFlare(planet.data.lensFlare, sunWorldPosition);
                        }
                    }
                }
                
                // è¡›æ˜Ÿã®å…¬è»¢
                planet.mesh.children.forEach(moon => {
                    if (moon.userData && moon.userData.speed) {
                        const moonAngle = time * moon.userData.speed;
                        moon.position.x = Math.cos(moonAngle) * moon.userData.distance;
                        moon.position.z = Math.sin(moonAngle) * moon.userData.distance;
                    }
                });
            });

            // å°æƒ‘æ˜Ÿã¨ã‚«ã‚¤ãƒ‘ãƒ¼ãƒ™ãƒ«ãƒˆå¤©ä½“ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            solarSystemGroup.children.forEach(child => {
                if (child.isGroup) {
                    child.children.forEach(object => {
                        if (object.userData && object.userData.rotationSpeed) {
                            // è‡ªè»¢
                            object.rotation.x += object.userData.rotationSpeed;
                            object.rotation.y += object.userData.rotationSpeed * 0.7;
                            object.rotation.z += object.userData.rotationSpeed * 0.3;
                            
                            // å…¬è»¢ï¼ˆå°æƒ‘æ˜Ÿã¨ã‚«ã‚¤ãƒ‘ãƒ¼ãƒ™ãƒ«ãƒˆå¤©ä½“ï¼‰
                            if (object.userData.orbitSpeed) {
                                object.userData.angle += object.userData.orbitSpeed;
                                object.position.x = Math.cos(object.userData.angle) * object.userData.distance;
                                object.position.z = Math.sin(object.userData.angle) * object.userData.distance;
                            }
                        }
                    });
                }
            });

            // é æ–¹ã®éŠ€æ²³ã®å›è»¢ï¼ˆç²’å­ã‚·ã‚¹ãƒ†ãƒ ç”¨ï¼‰
            scene.children.forEach(child => {
                if (child.isGroup && child.children.length > 0) {
                    child.children.forEach(galaxy => {
                        if (galaxy.userData && galaxy.userData.rotationSpeed) {
                            // ç²’å­ã‚·ã‚¹ãƒ†ãƒ ã®å ´åˆã¯é©åˆ‡ãªè»¸ã§å›è»¢
                            if (galaxy.userData.type === 'spiral') {
                                galaxy.rotation.y += galaxy.userData.rotationSpeed; // æ¸¦å·»ãã¯å¹³é¢å›è»¢
                            } else {
                                galaxy.rotation.z += galaxy.userData.rotationSpeed;
                            }
                        }
                    });
                }
            });

            // ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆï¼ˆä¸¡æ–¹ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‹ã‚‰æƒ‘æ˜Ÿã¸ã®å½“ãŸã‚Šåˆ¤å®šï¼‰
            // æƒ…å ±ãƒ‘ãƒãƒ«è¡¨ç¤ºä¸­ã‚‚ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆã¯ç¶™ç¶šï¼ˆãƒã‚¤ãƒ©ã‚¤ãƒˆå‡¦ç†ã®ã¿åœæ­¢ï¼‰
            if (xrActive && controllers.length > 0) {
                // å„ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã§ç‹¬ç«‹ã—ã¦ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆå‡¦ç†
                controllers.forEach((controller, index) => {
                    if (controller && controller.visible) {
                        try {
                            // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ä½ç½®ã¨æ–¹å‘ã‚’å–å¾—
                            const tempMatrix = new THREE.Matrix4();
                            tempMatrix.identity().extractRotation(controller.matrixWorld);
                            
                            const controllerPosition = new THREE.Vector3();
                            controllerPosition.setFromMatrixPosition(controller.matrixWorld);
                            
                            const controllerDirection = new THREE.Vector3(0, 0, -1);
                            controllerDirection.applyMatrix4(tempMatrix);
                            controllerDirection.normalize();
                            
                            raycaster.set(controllerPosition, controllerDirection);
                            
                            // æƒ‘æ˜Ÿã®ãƒ¡ãƒƒã‚·ãƒ¥ã®ã¿ã‚’ãƒã‚§ãƒƒã‚¯
                            const planetMeshes = planets.map(p => p.mesh).filter(mesh => mesh && mesh.visible);
                            const intersects = raycaster.intersectObjects(planetMeshes);
                            
                            // ãƒ¬ãƒ¼ã‚¶ãƒ¼ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã®é•·ã•ã‚’èª¿æ•´
                            updateControllerRayLength(controller, intersects);
                            
                            // æƒ…å ±ãƒ‘ãƒãƒ«è¡¨ç¤ºä¸­ã®ã‚«ãƒ¼ã‚½ãƒ«åˆ¶å¾¡
                            updateControllerRayVisibility(controller, index);
                            
                            // æƒ…å ±ãƒ‘ãƒãƒ«è¡¨ç¤ºä¸­ã¯ãƒã‚¤ãƒ©ã‚¤ãƒˆå‡¦ç†ã‚’ã‚¹ã‚­ãƒƒãƒ—
                            if (!planetInfoVisible) {
                                if (intersects.length > 0) {
                                    const intersectedPlanet = planets.find(p => p.mesh === intersects[0].object);
                                    if (intersectedPlanet && intersectedPlanet !== highlightedPlanets[index]) {
                                        highlightPlanet(intersectedPlanet, index);
                                    }
                                } else {
                                    clearHighlight(index);
                                }
                            }
                        } catch (error) {
                            // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã¯ã“ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’ã‚¯ãƒªã‚¢
                            clearHighlight(index);
                        }
                    } else {
                        // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãŒéè¡¨ç¤ºã®å ´åˆã¯ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’ã‚¯ãƒªã‚¢
                        clearHighlight(index);
                    }
                });
            }

            // ç‰‡æ‰‹ã‚°ãƒªãƒƒãƒ—ã§ã®ãƒ‰ãƒ©ãƒƒã‚°ç§»å‹•ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ä½ç½®ã‚’ç§»å‹•ï¼‰
            if (isDragging && controllers.length > 0) {
                const activeController = gripStates.left ? controllers[0] : controllers[1];
                if (activeController) {
                    const currentPosition = new THREE.Vector3();
                    currentPosition.setFromMatrixPosition(activeController.matrixWorld);
                    
                    const deltaPosition = new THREE.Vector3().subVectors(currentPosition, dragStartPosition);
                    // ç§»å‹•æ–¹å‘ã‚’åè»¢ã•ã›ã¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒç§»å‹•ã—ã¦ã„ã‚‹æ„Ÿè¦šã«ã™ã‚‹
                    deltaPosition.multiplyScalar(-5);
                    userPosition.copy(userStartPosition).add(deltaPosition);
                    
                    // ã‚«ãƒ¡ãƒ©ã¨ã‚·ãƒ¼ãƒ³å…¨ä½“ã®ä½ç½®ã‚’æ›´æ–°
                    updateUserPosition();
                }
            }

            // ä¸¡æ‰‹ã‚°ãƒªãƒƒãƒ—ã§ã®ã‚¹ã‚±ãƒ¼ãƒ«èª¿æ•´ï¼ˆå¸¸ã«å‹•ä½œï¼‰
            if (gripStates.left && gripStates.right && controllers.length >= 2 && controllers[0] && controllers[1] && !isDragging) {
                const leftPos = new THREE.Vector3();
                const rightPos = new THREE.Vector3();
                leftPos.setFromMatrixPosition(controllers[0].matrixWorld);
                rightPos.setFromMatrixPosition(controllers[1].matrixWorld);
                const currentDistance = leftPos.distanceTo(rightPos);
                
                if (lastDistance > 0 && currentDistance > 0) {
                    const scaleChange = currentDistance / lastDistance;
                    scaleFactor *= scaleChange;
                    
                    // ã‚¹ã‚±ãƒ¼ãƒ«åˆ¶é™ã‚’è§£é™¤ï¼ˆè‡ªç”±ãªæ‹¡å¤§ç¸®å°ã‚’è¨±å¯ï¼‰
                    // scaleFactor = Math.max(0.1, Math.min(10, scaleFactor));
                    
                    solarSystemGroup.scale.setScalar(scaleFactor);
                    
                    // UIæ›´æ–°
                    document.getElementById('scale-value').textContent = scaleFactor.toFixed(2);
                }
                
                lastDistance = currentDistance;
            }

            renderer.render(scene, camera);
        }

        // ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ©ãƒ¼
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        window.addEventListener('resize', onWindowResize);
        document.getElementById('xr-button').addEventListener('click', startXRSession);

        // åˆæœŸåŒ–é–‹å§‹
        checkXRSupport().then(() => {
            init();
        });

        // å®‡å®™ç©ºé–“ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
        function toggleSpaceMode() {
            if (spaceFadeAnimation.transitioning) {
                return; // æ—¢ã«ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ä¸­ã®å ´åˆã¯ç„¡è¦–
            }
            
            spaceFadeAnimation.transitioning = true;
            spaceFadeAnimation.targetMode = !spaceMode;
            
            if (spaceFadeAnimation.targetMode) {
                // å®‡å®™ç©ºé–“ãƒ¢ãƒ¼ãƒ‰ã¸
                spaceFadeAnimation.target = 1;
                spaceFadeAnimation.progress = 0;
            } else {
                // MRãƒ¢ãƒ¼ãƒ‰ã¸
                spaceFadeAnimation.target = 1;
                spaceFadeAnimation.progress = 0;
            }
        }

        // ãƒ•ã‚§ãƒ¼ãƒ‰åŠ¹æœä»˜ãã®å®Ÿéš›ã®ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
        function applySpaceModeChange(progress) {
            const targetMode = spaceFadeAnimation.targetMode;
            
            if (targetMode) {
                // å®‡å®™ç©ºé–“ãƒ¢ãƒ¼ãƒ‰ã¸ã®åˆ‡ã‚Šæ›¿ãˆ
                if (originalStars && originalStars.material) {
                    originalStars.material.opacity = Math.max(0, 1 - progress);
                }
                if (spaceStars && spaceStars.material) {
                    spaceStars.material.opacity = Math.min(1, progress);
                }
                
                // èƒŒæ™¯çƒä½“ã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ï¼ˆå®Œå…¨ã«ä¸é€æ˜ã«ï¼‰
                if (backgroundSphere && backgroundSphere.material) {
                    backgroundSphere.material.opacity = Math.min(1.0, progress);
                }
                
                // æ˜Ÿã®è¡¨ç¤ºçŠ¶æ…‹ã‚’ç®¡ç†
                if (progress > 0.1) {
                    spaceStars.visible = true;
                    backgroundSphere.visible = true;
                }
                if (progress > 0.9) {
                    originalStars.visible = false;
                }
                
                // ã‚«ãƒ¡ãƒ©ä½ç½®ã®è£œé–“
                const startPos = new THREE.Vector3(0, 1.6, 5);
                const endPos = new THREE.Vector3(0, 0, 0);
                camera.position.lerpVectors(startPos, endPos, progress);
                
            } else {
                // MRãƒ¢ãƒ¼ãƒ‰ã¸ã®å¾©å¸°
                if (spaceStars && spaceStars.material) {
                    spaceStars.material.opacity = Math.max(0, 1 - progress);
                }
                if (originalStars && originalStars.material) {
                    originalStars.material.opacity = Math.min(1, progress);
                }
                
                // èƒŒæ™¯çƒä½“ã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
                if (backgroundSphere && backgroundSphere.material) {
                    backgroundSphere.material.opacity = Math.max(0, 1.0 * (1 - progress));
                }
                
                // æ˜Ÿã®è¡¨ç¤ºçŠ¶æ…‹ã‚’ç®¡ç†
                if (progress > 0.1) {
                    originalStars.visible = true;
                }
                if (progress > 0.9) {
                    spaceStars.visible = false;
                    backgroundSphere.visible = false;
                }
                
                // ã‚«ãƒ¡ãƒ©ä½ç½®ã®è£œé–“
                const startPos = new THREE.Vector3(0, 0, 0);
                const endPos = new THREE.Vector3(0, 1.6, 5);
                camera.position.lerpVectors(startPos, endPos, progress);
            }
            
            // å®Œäº†å‡¦ç†
            if (Math.abs(progress - spaceFadeAnimation.target) < 0.05) {
                spaceMode = targetMode;
                spaceFadeAnimation.transitioning = false;
                
                if (spaceMode) {
                    // å®‡å®™ç©ºé–“ãƒ¢ãƒ¼ãƒ‰å®Œäº†
                    originalStars.visible = false;
                    spaceStars.visible = true;
                    backgroundSphere.visible = true;
                    originalStars.material.opacity = 0;
                    spaceStars.material.opacity = 1;
                    backgroundSphere.material.opacity = 1.0;
                    camera.position.set(0, 0, 0);
                    
                    // VRãƒ¢ãƒ¼ãƒ‰ã§ã¯è»Œé“ç·šã‚’éè¡¨ç¤º
                    toggleOrbitVisibility(false);
                    
                    // è¨˜éŒ²ã•ã‚ŒãŸæƒ‘æ˜Ÿæƒ…å ±ãŒã‚ã‚Œã°è‡ªå‹•è¡¨ç¤º
                    if (pendingPlanetInfo) {
                        setTimeout(() => {
                            show3DPlanetInfo(pendingPlanetInfo);
                            pendingPlanetInfo = null;
                        }, 500);
                    }
                } else {
                    // MRãƒ¢ãƒ¼ãƒ‰å®Œäº†
                    spaceStars.visible = false;
                    originalStars.visible = true;
                    backgroundSphere.visible = false;
                    spaceStars.material.opacity = 0;
                    originalStars.material.opacity = 1;
                    backgroundSphere.material.opacity = 0;
                    camera.position.set(0, 1.6, 5);
                    
                    // MRãƒ¢ãƒ¼ãƒ‰ã§ã¯è»Œé“ç·šã‚’è¡¨ç¤º
                    toggleOrbitVisibility(true);
                    
                    // MRãƒ¢ãƒ¼ãƒ‰å¾©å¸°æ™‚ã¯ä¿ç•™ä¸­ã®æƒ‘æ˜Ÿæƒ…å ±ã‚’ã‚¯ãƒªã‚¢
                    pendingPlanetInfo = null;
                }
            }
        }

        // æ§ãˆã‚ãªåŠ¹æœéŸ³ã‚’ç”Ÿæˆãƒ»å†ç”Ÿã™ã‚‹é–¢æ•°
        function playInfoPanelSound() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (error) {
                    return;
                }
            }

            try {
                // è¤‡æ•°ã®éŸ³ã‚’é‡ã­ã¦ç¾ã—ã„åŠ¹æœéŸ³ã‚’ä½œæˆ
                const now = audioContext.currentTime;
                
                // ãƒ¡ã‚¤ãƒ³ãƒ™ãƒ«éŸ³ï¼ˆåŸºéŸ³ï¼‰
                const oscillator1 = audioContext.createOscillator();
                const gainNode1 = audioContext.createGain();
                oscillator1.connect(gainNode1);
                gainNode1.connect(audioContext.destination);
                
                oscillator1.frequency.setValueAtTime(880, now); // A5éŸ³
                oscillator1.frequency.exponentialRampToValueAtTime(660, now + 0.5); // E5éŸ³ã¸ä¸‹é™
                oscillator1.type = 'sine';
                
                gainNode1.gain.setValueAtTime(0, now);
                gainNode1.gain.linearRampToValueAtTime(0.05, now + 0.02); // 0.15 â†’ 0.05 ã«éŸ³é‡ã‚’ä¸‹ã’ã‚‹
                gainNode1.gain.exponentialRampToValueAtTime(0.001, now + 1.2);
                
                // ãƒãƒ¼ãƒ¢ãƒ‹ãƒ¼éŸ³ï¼ˆç¬¬5åº¦ï¼‰
                const oscillator2 = audioContext.createOscillator();
                const gainNode2 = audioContext.createGain();
                oscillator2.connect(gainNode2);
                gainNode2.connect(audioContext.destination);
                
                oscillator2.frequency.setValueAtTime(1320, now); // E6éŸ³
                oscillator2.frequency.exponentialRampToValueAtTime(990, now + 0.5); // B5éŸ³ã¸ä¸‹é™
                oscillator2.type = 'sine';
                
                gainNode2.gain.setValueAtTime(0, now);
                gainNode2.gain.linearRampToValueAtTime(0.03, now + 0.02); // 0.08 â†’ 0.03 ã«éŸ³é‡ã‚’ä¸‹ã’ã‚‹
                gainNode2.gain.exponentialRampToValueAtTime(0.001, now + 1.0);
                
                // å¾®ç´°ãªéŸ¿ãï¼ˆã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ä¸Šï¼‰
                const oscillator3 = audioContext.createOscillator();
                const gainNode3 = audioContext.createGain();
                oscillator3.connect(gainNode3);
                gainNode3.connect(audioContext.destination);
                
                oscillator3.frequency.setValueAtTime(1760, now); // A6éŸ³
                oscillator3.type = 'triangle';
                
                gainNode3.gain.setValueAtTime(0, now);
                gainNode3.gain.linearRampToValueAtTime(0.02, now + 0.01); // 0.04 â†’ 0.02 ã«éŸ³é‡ã‚’ä¸‹ã’ã‚‹
                gainNode3.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
                
                // å†ç”Ÿé–‹å§‹
                oscillator1.start(now);
                oscillator1.stop(now + 1.2);
                
                oscillator2.start(now);
                oscillator2.stop(now + 1.0);
                
                oscillator3.start(now);
                oscillator3.stop(now + 0.8);
                
            } catch (error) {
                // ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
            }
        }

        // è»Œé“ç·šã®è¡¨ç¤ºåˆ¶å¾¡
        function toggleOrbitVisibility(visible) {
            solarSystemGroup.children.forEach(child => {
                if (child.userData && child.userData.type === 'orbit') {
                    child.visible = visible;
                }
            });
        }

        // ç§»å‹•å¯¾è±¡ã¨ãªã‚‹å®‡å®™è¦ç´ ã®ãƒªã‚¹ãƒˆ
        let universeElements = [];

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½ç½®ã®æ›´æ–°
        function updateUserPosition() {
            if (!xrActive) {
                // éXRãƒ¢ãƒ¼ãƒ‰ã§ã®ã‚«ãƒ¡ãƒ©ä½ç½®æ›´æ–°
                camera.position.copy(userPosition);
            } else {
                // XRãƒ¢ãƒ¼ãƒ‰ã§ã¯å…¨ã¦ã®å®‡å®™è¦ç´ ã‚’ç›¸å¯¾çš„ã«ç§»å‹•
                const offset = new THREE.Vector3().subVectors(new THREE.Vector3(0, 1.6, 5), userPosition);
                
                // ã™ã¹ã¦ã®ç™»éŒ²ã•ã‚ŒãŸå®‡å®™è¦ç´ ã‚’ç§»å‹•
                universeElements.forEach(element => {
                    if (element && element.position) {
                        element.position.copy(element.originalPosition).add(offset);
                    }
                });
            }
        }

        // å®‡å®™è¦ç´ ã‚’ç™»éŒ²ã™ã‚‹é–¢æ•°
        function registerUniverseElement(element) {
            if (element && element.position) {
                // å…ƒã®ä½ç½®ã‚’ä¿å­˜
                element.originalPosition = element.position.clone();
                universeElements.push(element);
            }
        }
    </script>
</body>
</html>