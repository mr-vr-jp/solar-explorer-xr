<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR MR å¤ªé™½ç³»æ¢ç´¢</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0c0c1e 0%, #1a1a2e 50%, #16213e 100%);
            overflow: hidden;
            height: 100vh;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #canvas {
            display: block;
        }

        .overlay {
            position: absolute;
            color: white;
            font-size: 14px;
            background: rgba(0, 0, 32, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 136, 0.3);
            backdrop-filter: blur(10px);
            pointer-events: none;
        }

        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            z-index: 1000;
        }

        #xr-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            background: linear-gradient(45deg, #00ff88, #0088ff);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            z-index: 100;
        }

        #xr-button:disabled {
            background: #666666;
            cursor: not-allowed;
        }

        #instructions {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 14px;
            max-width: 400px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            text-align: left;
            z-index: 100;
        }

        #info-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            display: none;
            z-index: 9999;
        }

        #warning-panel {
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(139, 0, 0, 0.8);
            text-align: center;
            display: none;
        }

        #planet-info {
            position: absolute !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
            background: rgba(0, 20, 40, 0.98) !important;
            border: 3px solid rgba(0, 255, 136, 1) !important;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.8) !important;
            max-width: 350px;
            display: none;
            z-index: 999999 !important;
            pointer-events: auto;
            color: white !important;
            font-family: 'Courier New', monospace !important;
            font-size: 14px !important;
            opacity: 0; /* XRãƒ¢ãƒ¼ãƒ‰ã§ã¯3Dè¡¨ç¤ºã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚éè¡¨ç¤º */
            visibility: hidden;
        }

        .info-title {
            color: #00ff88;
            font-size: 18px;
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 0 0 10px #00ff88;
        }

        .info-item {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
        }

        .info-label {
            color: #ffaa00;
        }

        .info-value {
            color: #ffffff;
        }

        .highlight {
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
        }

        .warning {
            color: #ffaa00;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">
            <div style="text-align: center;">
                <div>ğŸŒŒ MRå¤ªé™½ç³»ã‚’æº–å‚™ä¸­...</div>
                <div style="margin-top: 20px; font-size: 16px;">
                    WebXRã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’åˆæœŸåŒ–ã—ã¦ã„ã¾ã™
                </div>
            </div>
        </div>

        <button id="xr-button">
            ğŸ¥½ MRå¤ªé™½ç³»ã‚’é–‹å§‹
        </button>

        <div id="instructions">
            <h3 class="highlight" style="margin: 0 0 10px 0;">ğŸŒŸ æ“ä½œæ–¹æ³•</h3>
            <div>â€¢ ç§»å‹•ï¼šç‰‡æ‰‹ã‚°ãƒªãƒƒãƒ—+ãƒ‰ãƒ©ãƒƒã‚°</div>
            <div>â€¢ æ‹¡å¤§/ç¸®å°ï¼šä¸¡æ‰‹ã‚°ãƒªãƒƒãƒ—</div>
            <div>â€¢ æƒ‘æ˜Ÿã‚¯ãƒªãƒƒã‚¯ï¼šVR+æƒ…å ±è¡¨ç¤º</div>
            <div>â€¢ ç©ºé–“ã‚¯ãƒªãƒƒã‚¯ï¼šMRå¾©å¸°</div>
        </div>

        <div id="info-panel" class="overlay">
            <div class="highlight" style="margin-bottom: 10px;">
                ğŸ¥½ MRãƒ¢ãƒ¼ãƒ‰ï¼šã‚¢ã‚¯ãƒ†ã‚£ãƒ–
            </div>
            <div>ã‚¹ã‚±ãƒ¼ãƒ«: <span id="scale-value">1.00</span>x</div>
            <div>ä¸¡æ‰‹ã‚°ãƒªãƒƒãƒ—: <span id="grip-status">OFF</span></div>
        </div>

        <div id="warning-panel" class="overlay">
            <div style="margin-bottom: 10px;">âš ï¸ WebXRéå¯¾å¿œç’°å¢ƒ</div>
            <div>ã“ã®ãƒ‡ãƒã‚¤ã‚¹ã§ã¯MRæ©Ÿèƒ½ã‚’ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚</div>
            <div>Meta Questã€HoloLensã€Magic Leapç­‰ã®å¯¾å¿œãƒ‡ãƒã‚¤ã‚¹ã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚</div>
        </div>

        <div id="planet-info" class="overlay">
            <div class="info-title" id="planet-name">æƒ‘æ˜Ÿå</div>
            <div class="info-item">
                <span class="info-label">è·é›¢:</span>
                <span class="info-value" id="planet-distance">-</span>
            </div>
            <div class="info-item">
                <span class="info-label">ã‚µã‚¤ã‚º:</span>
                <span class="info-value" id="planet-size">-</span>
            </div>
            <div class="info-item">
                <span class="info-label">å…¬è»¢å‘¨æœŸ:</span>
                <span class="info-value" id="planet-period">-</span>
            </div>
            <div class="info-item">
                <span class="info-label">ç‰¹å¾´:</span>
                <span class="info-value" id="planet-feature">-</span>
            </div>
            <div style="text-align: center; margin-top: 15px; color: #888;">
                ãƒˆãƒªã‚¬ãƒ¼ã§é–‰ã˜ã‚‹
            </div>
        </div>

        <!-- BGM -->
        <audio id="bgm" loop preload="auto" style="display: none;">
            <source src="Mystical Cosmos.mp3" type="audio/mpeg">
        </audio>
    </div>

    <script>
        let scene, camera, renderer, solarSystemGroup;
        let planets = [];
        let controllers = { left: null, right: null };
        let gripStates = { left: false, right: false };
        let lastDistance = 0;
        let scaleFactor = 1;
        let xrSupported = false;
        let xrActive = false;
        let raycaster = new THREE.Raycaster();
        let highlightedPlanet = null;
        let planetInfoVisible = false;
        let isDragging = false;
        let dragStartPosition = new THREE.Vector3();
        let userStartPosition = new THREE.Vector3();
        let userPosition = new THREE.Vector3(0, 1.6, 5); // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ä»®æƒ³ä½ç½®
        let planetInfoPanel = null;
        let sunScaleAnimation = { target: 1, current: 1, speed: 0.05 };
        let panelFadeAnimation = { opacity: 0, target: 0, speed: 0.05 };
        let spaceMode = false;
        let spaceStars = null;
        let originalStars = null;
        let originalBackground = null;
        let spaceRotation = 0;
        let spaceFadeAnimation = { 
            transitioning: false, 
            progress: 0, 
            target: 0, 
            speed: 0.04,
            targetMode: false 
        };
        let backgroundSphere = null;
        let pendingPlanetInfo = null; // VRãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆå¾Œã«è¡¨ç¤ºäºˆå®šã®æƒ‘æ˜Ÿæƒ…å ±
        let dataLoaded = false; // ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å®Œäº†ãƒ•ãƒ©ã‚°
        let bgMusic = null; // BGMç”¨
        let audioContext = null; // Web Audio APIç”¨

        // æƒ‘æ˜Ÿãƒ‡ãƒ¼ã‚¿
        const planetData = [
            { name: 'å¤ªé™½', size: 0.25, distance: 0, color: 0xFFA500, speed: 0, type: 'sun', emissive: 0xFFAA00, rotationSpeed: 0.001, 
              realDistance: '0', realSize: '1,392,700km', period: '-', 
              feature: 'å¤ªé™½ç³»ã®ä¸­å¿ƒã«ä½ç½®ã™ã‚‹æ’æ˜Ÿã§ã€æ°´ç´ ã¨ãƒ˜ãƒªã‚¦ãƒ ã®æ ¸èåˆã«ã‚ˆã‚Šè«å¤§ãªã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’æ”¾å‡ºã—ã¦ã„ã‚‹ã€‚è¡¨é¢æ¸©åº¦ã¯ç´„5,778Kã€ä¸­å¿ƒéƒ¨ã¯1,500ä¸‡åº¦ã«é”ã™ã‚‹ã€‚å¤ªé™½é¢¨ã¨å‘¼ã°ã‚Œã‚‹è·é›»ç²’å­ã®æµã‚Œã‚’å¸¸ã«æ”¾å‡ºã—ã¦ãŠã‚Šã€ã“ã‚ŒãŒåœ°çƒã®ã‚ªãƒ¼ãƒ­ãƒ©ã®åŸå› ã¨ãªã£ã¦ã„ã‚‹ã€‚',
              discovery: 'å¤ä»£', 
              fact: 'å¤ªé™½ã¯1ç§’é–“ã«400ä¸‡ãƒˆãƒ³ã®è³ªé‡ã‚’ã‚¨ãƒãƒ«ã‚®ãƒ¼ã«å¤‰æ›ã—ã¦ã„ã‚‹ã€‚åœ°çƒã«å±Šãå¤ªé™½å…‰ã¯8åˆ†19ç§’å‰ã«å¤ªé™½è¡¨é¢ã‚’å‡ºç™ºã—ãŸã‚‚ã®ã€‚å¤ªé™½ã®æ ¸ã§ä½œã‚‰ã‚ŒãŸå…‰å­ãŒè¡¨é¢ã«åˆ°é”ã™ã‚‹ã¾ã§ã«ã¯10ä¸‡å¹´ã‹ã‚‰17ä¸‡å¹´ã‹ã‹ã‚‹ã€‚å¤ªé™½ç³»ã®è³ªé‡ã®99.86%ã‚’å ã‚ã¦ãŠã‚Šã€åœ°çƒ130ä¸‡å€‹åˆ†ã®ä½“ç©ã‚’æŒã¤ã€‚' },
            { name: 'æ°´æ˜Ÿ', size: 0.008, distance: 0.6, color: 0x8C7853, speed: 0.002, type: 'mercury', rotationSpeed: 0.0002,
              realDistance: '0.39AU', realSize: '4,879km', period: '88æ—¥', 
              feature: 'å¤ªé™½ã«æœ€ã‚‚è¿‘ã„æƒ‘æ˜Ÿã§ã€æ¥µç«¯ãªæ¸©åº¦å·®ãŒç‰¹å¾´ã€‚å¤§æ°—ãŒã»ã¨ã‚“ã©å­˜åœ¨ã—ãªã„ãŸã‚ã€æ˜¼é–“ã¯427Â°Cã€å¤œé–“ã¯-173Â°Cã¨590Â°Cã‚‚ã®æ¸©åº¦å·®ãŒç”Ÿã˜ã‚‹ã€‚è¡¨é¢ã¯ã‚¯ãƒ¬ãƒ¼ã‚¿ãƒ¼ã ã‚‰ã‘ã§æœˆã«ä¼¼ã¦ã„ã‚‹ãŒã€å·¨å¤§ãªã‚«ãƒ­ãƒªã‚¹ç›†åœ°ã¨ã„ã†ç›´å¾„1,550kmã®è¡çªã‚¯ãƒ¬ãƒ¼ã‚¿ãƒ¼ãŒå­˜åœ¨ã™ã‚‹ã€‚',
              discovery: 'å¤ä»£', 
              fact: 'æ°´æ˜Ÿã®1æ—¥ï¼ˆè‡ªè»¢å‘¨æœŸï¼‰ã¯åœ°çƒã®59æ—¥ã«ç›¸å½“ã™ã‚‹ãŒã€1å¹´ï¼ˆå…¬è»¢å‘¨æœŸï¼‰ã¯88æ—¥ã—ã‹ãªã„ã€‚ãã®ãŸã‚æ°´æ˜Ÿã§ã¯1æ—¥ãŒ1å¹´ã®3åˆ†ã®2ã‚‚ã®é•·ã•ã«ãªã‚‹ã€‚ã¾ãŸã€æ°´æ˜Ÿã¯å¤ªé™½ç³»ã§æœ€ã‚‚è»Œé“é›¢å¿ƒç‡ãŒå¤§ããã€è¿‘æ—¥ç‚¹ã¨é æ—¥ç‚¹ã®è·é›¢å·®ã¯2,400ä¸‡kmã‚‚ã‚ã‚‹ã€‚æ°·ãŒå­˜åœ¨ã™ã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹æ¥µåœ°ã®ã‚¯ãƒ¬ãƒ¼ã‚¿ãƒ¼ãŒã‚ã‚‹ã€‚' },
            { name: 'é‡‘æ˜Ÿ', size: 0.012, distance: 0.85, color: 0xFFC649, speed: 0.0015, type: 'venus', rotationSpeed: -0.00005,
              realDistance: '0.72AU', realSize: '12,104km', period: '225æ—¥', 
              feature: 'å¤ªé™½ç³»ã§æœ€ã‚‚é«˜æ¸©ã®æƒ‘æ˜Ÿã§ã€åšã„äºŒé…¸åŒ–ç‚­ç´ ã®å¤§æ°—ã¨ç¡«é…¸ã®é›²ã«è¦†ã‚ã‚Œã¦ã„ã‚‹ã€‚æ¸©å®¤åŠ¹æœã«ã‚ˆã‚Šè¡¨é¢æ¸©åº¦ã¯462Â°Cã«é”ã—ã€é‰›ã‚‚æº¶ã‘ã‚‹ã»ã©ã€‚å¤§æ°—åœ§ã¯åœ°çƒã®90å€ã‚‚ã‚ã‚‹ã€‚èˆˆå‘³æ·±ã„ã“ã¨ã«ã€ä»–ã®æƒ‘æ˜Ÿã¨ã¯é€†æ–¹å‘ã«è‡ªè»¢ã—ã¦ã„ã‚‹ã€‚ã“ã®é€†å›è»¢ã«ã‚ˆã‚Šã€é‡‘æ˜Ÿã§ã¯å¤ªé™½ãŒè¥¿ã‹ã‚‰æ˜‡ã‚Šæ±ã«æ²ˆã‚€ã€‚',
              discovery: 'å¤ä»£', 
              fact: 'é‡‘æ˜Ÿã®1æ—¥ã¯åœ°çƒã®243æ—¥ã«ç›¸å½“ã—ã€ã“ã‚Œã¯é‡‘æ˜Ÿã®1å¹´ï¼ˆ225æ—¥ï¼‰ã‚ˆã‚Šã‚‚é•·ã„ã€‚ã¤ã¾ã‚Šé‡‘æ˜Ÿã§ã¯1æ—¥ãŒ1å¹´ã‚ˆã‚Šé•·ã„å”¯ä¸€ã®æƒ‘æ˜Ÿã€‚é‡‘æ˜Ÿã®é›²ã¯ç¡«é…¸ã§ã§ãã¦ãŠã‚Šã€æ™‚é€Ÿ350kmã¨ã„ã†çŒ›çƒˆãªé¢¨ãŒå¹ã„ã¦ã„ã‚‹ã€‚è¡¨é¢ã«ã¯ç´„1,000å€‹ã®ç«å±±ãŒã‚ã‚Šã€ç¾åœ¨ã‚‚æ´»å‹•ã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã€‚' },
            { name: 'åœ°çƒ', size: 0.013, distance: 1.15, color: 0x6B93D6, speed: 0.001, type: 'earth', rotationSpeed: 0.004,
              realDistance: '1.00AU', realSize: '12,756km', period: '365æ—¥', 
              feature: 'å¤ªé™½ç³»ã§å”¯ä¸€ç”Ÿå‘½ãŒå­˜åœ¨ã™ã‚‹ã“ã¨ãŒç¢ºèªã•ã‚Œã¦ã„ã‚‹æƒ‘æ˜Ÿã€‚è¡¨é¢ã®71%ãŒæµ·ã§è¦†ã‚ã‚Œã€é…¸ç´ ã¨çª’ç´ ã‹ã‚‰ãªã‚‹å¤§æ°—ã«åŒ…ã¾ã‚Œã¦ã„ã‚‹ã€‚æœˆã¨ã„ã†å¤§ããªè¡›æ˜Ÿã‚’æŒã¡ã€ã“ã‚ŒãŒæ½®æ±ã‚’ç”Ÿã¿å‡ºã—åœ°è»¸ã‚’å®‰å®šã•ã›ã¦ã„ã‚‹ã€‚ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ†ã‚¯ãƒˆãƒ‹ã‚¯ã‚¹ã«ã‚ˆã‚Šåœ°è¡¨ãŒå¸¸ã«å¤‰åŒ–ã—ç¶šã‘ã¦ã„ã‚‹ã€‚ç£å ´ã«ã‚ˆã‚Šå¤ªé™½é¢¨ã‹ã‚‰ä¿è­·ã•ã‚Œã¦ã„ã‚‹ã€‚',
              discovery: 'å¤ä»£', 
              fact: 'åœ°çƒä¸Šã®ç”Ÿå‘½ã¯ç´„38å„„å¹´å‰ã«èª•ç”Ÿã—ãŸã¨ã•ã‚Œã€æœ€åˆã¯å˜ç´°èƒç”Ÿç‰©ã ã£ãŸã€‚åœ°çƒã®æ ¸ã¯æ¶²ä½“ã®é‰„ã¨ãƒ‹ãƒƒã‚±ãƒ«ã§ã§ãã¦ãŠã‚Šã€ãã®æµå‹•ã«ã‚ˆã‚Šç£å ´ãŒç”Ÿæˆã•ã‚Œã‚‹ã€‚1æ—¥ã¯å®Ÿéš›ã«ã¯23æ™‚é–“56åˆ†4ç§’ã§ã€ã“ã‚Œã‚’æ’æ˜Ÿæ—¥ã¨ã„ã†ã€‚åœ°çƒã®é‡åŠ›ã«ã‚ˆã‚Šæ™‚ç©ºãŒæ­ªã¿ã€GPSè¡›æ˜Ÿã¯ç›¸å¯¾æ€§ç†è«–ã®è£œæ­£ãŒå¿…è¦ã€‚' },
            { name: 'ç«æ˜Ÿ', size: 0.009, distance: 1.45, color: 0xCD5C5C, speed: 0.0008, type: 'mars', rotationSpeed: 0.0038,
              realDistance: '1.52AU', realSize: '6,792km', period: '687æ—¥', 
              feature: 'èµ¤ã„æƒ‘æ˜Ÿã¨ã—ã¦çŸ¥ã‚‰ã‚Œã€é…¸åŒ–é‰„ï¼ˆéŒ†ï¼‰ã«ã‚ˆã‚Šèµ¤ãè¦‹ãˆã‚‹ã€‚å¤ªé™½ç³»æœ€å¤§ã®ç«å±±ã‚ªãƒªãƒ³ãƒã‚¹å±±ï¼ˆé«˜ã•21kmï¼‰ã¨æœ€å¤§ã®å³¡è°·ãƒ´ã‚¡ãƒ¬ã‚¹ãƒ»ãƒãƒªãƒãƒªã‚¹ã‚’æŒã¤ã€‚æ¥µåœ°ã«ã¯æ°·ãŒå­˜åœ¨ã—ã€éå»ã«ã¯æ¶²ä½“ã®æ°´ãŒæµã‚Œã¦ã„ãŸè¨¼æ‹ ãŒã‚ã‚‹ã€‚è–„ã„å¤§æ°—ã‚’æŒã¡ã€å·¨å¤§ãªç ‚åµãŒæƒ‘æ˜Ÿå…¨ä½“ã‚’è¦†ã†ã“ã¨ãŒã‚ã‚‹ã€‚',
              discovery: 'å¤ä»£', 
              fact: 'ç«æ˜Ÿã«ã¯å¤ªé™½ç³»æœ€å¤§ã®ç«å±±ã‚ªãƒªãƒ³ãƒã‚¹å±±ãŒã‚ã‚Šã€ã“ã‚Œã¯ã‚¨ãƒ™ãƒ¬ã‚¹ãƒˆã®ç´„3å€ã®é«˜ã•ã€‚ç«æ˜Ÿã®é‡åŠ›ã¯åœ°çƒã®38%ãªã®ã§ã€åœ°çƒã§50kg ã®äººã¯ç«æ˜Ÿã§ã¯19kgã«ãªã‚‹ã€‚ç«æ˜Ÿã®1æ—¥ã¯24æ™‚é–“37åˆ†ã¨åœ°çƒã¨ã»ã¼åŒã˜ã€‚ç«æ˜Ÿã«ã¯ã€Œãƒ•ã‚©ãƒœã‚¹ã€ã¨ã€Œãƒ‡ã‚¤ãƒ¢ã‚¹ã€ã¨ã„ã†2ã¤ã®å°ã•ãªè¡›æ˜ŸãŒã‚ã‚Šã€ã©ã¡ã‚‰ã‚‚ã‚¸ãƒ£ã‚¬ã‚¤ãƒ¢ã®ã‚ˆã†ãªä¸è¦å‰‡ãªå½¢ã‚’ã—ã¦ã„ã‚‹ã€‚' },
            { name: 'æœ¨æ˜Ÿ', size: 0.11, distance: 2.0, color: 0xD2691E, speed: 0.0005, type: 'jupiter', rotationSpeed: 0.009,
              realDistance: '5.20AU', realSize: '142,984km', period: '12å¹´', 
              feature: 'å¤ªé™½ç³»æœ€å¤§ã®æƒ‘æ˜Ÿã§ã€åœ°çƒã®1,300å€ä»¥ä¸Šã®ä½“ç©ã‚’æŒã¤ã‚¬ã‚¹å·¨æ˜Ÿã€‚å¤§èµ¤æ–‘ã¨ã„ã†åœ°çƒ2å€‹åˆ†ã®å·¨å¤§ãªé«˜æ°—åœ§ã®åµãŒ300å¹´ä»¥ä¸Šç¶šã„ã¦ã„ã‚‹ã€‚95å€‹ã®è¡›æ˜Ÿã‚’æŒã¡ã€ãã®ä¸­ã«ã¯æ°·ã®ä¸‹ã«æµ·ãŒã‚ã‚‹ã‚¨ã‚¦ãƒ­ãƒ‘ã‚„ã€æ´»ç«å±±ãŒã‚ã‚‹ã‚¤ã‚ªãªã©ãŒã‚ã‚‹ã€‚æœ¨æ˜Ÿã¯å¤ªé™½ç³»ã®æƒé™¤æ©Ÿã®å½¹å‰²ã‚’æœãŸã—ã€å°æƒ‘æ˜Ÿã‚„å½—æ˜Ÿã‚’å¼•ãå¯„ã›ã¦åœ°çƒã‚’å®ˆã£ã¦ã„ã‚‹ã€‚',
              discovery: 'å¤ä»£', 
              fact: 'æœ¨æ˜Ÿã¯å¤ªé™½ç³»ã®ä»–ã®ã™ã¹ã¦ã®æƒ‘æ˜Ÿã‚’åˆã‚ã›ãŸã‚ˆã‚Šã‚‚é‡ã„ã€‚æœ¨æ˜Ÿã®é‡åŠ›ã«ã‚ˆã‚Šã€å¤ªé™½ç³»å¤–ç¸éƒ¨ã®å°å¤©ä½“ãŒå†…å´ã«ä¾µå…¥ã™ã‚‹ã®ã‚’é˜²ã„ã§ã„ã‚‹ã€‚æœ¨æ˜Ÿã®è¡›æ˜Ÿã‚¤ã‚ªã¯å¤ªé™½ç³»ã§æœ€ã‚‚ç«å±±æ´»å‹•ãŒæ´»ç™ºã§ã€ç¡«é»„ã®å™´ç«ã«ã‚ˆã‚Šé»„è‰²ãè¦‹ãˆã‚‹ã€‚æœ¨æ˜Ÿã¯å®Ÿã¯å°ã•ãªæ’æ˜Ÿã«ãªã‚Šãã“ã­ãŸæ˜Ÿã§ã€ã‚‚ã†å°‘ã—é‡ã‘ã‚Œã°ç¬¬äºŒã®å¤ªé™½ã«ãªã£ã¦ã„ãŸã€‚' },
            { name: 'åœŸæ˜Ÿ', size: 0.09, distance: 2.6, color: 0xB8860B, speed: 0.0004, type: 'saturn', rotationSpeed: 0.008,
              realDistance: '9.58AU', realSize: '120,536km', period: '29å¹´', 
              feature: 'ç¾ã—ã„ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã§æœ‰åãªã‚¬ã‚¹å·¨æ˜Ÿã€‚ãƒªãƒ³ã‚°ã¯æ°·ã¨å²©çŸ³ã®ç ´ç‰‡ã§ã§ãã¦ãŠã‚Šã€æ•°å„„å€‹ã®ç²’å­ãŒè»Œé“ã‚’æã„ã¦ã„ã‚‹ã€‚146å€‹ã®è¡›æ˜Ÿã‚’æŒã¡ã€ãã®ä¸­ã«ã¯æ¿ƒã„å¤§æ°—ã¨æ¶²ä½“ãƒ¡ã‚¿ãƒ³ã®æ¹–ãŒã‚ã‚‹ã‚¿ã‚¤ã‚¿ãƒ³ã‚„ã€æ°·ã®é–“æ¬ æ³‰ã‚’å™´å‡ºã™ã‚‹ã‚¨ãƒ³ã‚±ãƒ©ãƒ‰ã‚¹ãŒã‚ã‚‹ã€‚å¯†åº¦ãŒæ°´ã‚ˆã‚Šè»½ãã€ç†è«–ä¸Šã¯å·¨å¤§ãªãƒ—ãƒ¼ãƒ«ãŒã‚ã‚Œã°æµ®ãã“ã¨ãŒã§ãã‚‹ã€‚',
              discovery: 'å¤ä»£', 
              fact: 'åœŸæ˜Ÿã®ãƒªãƒ³ã‚°ã®åšã•ã¯ã‚ãšã‹10ãƒ¡ãƒ¼ãƒˆãƒ«ã»ã©ã—ã‹ãªã„ã€‚åœŸæ˜Ÿã®è¡›æ˜Ÿã‚¿ã‚¤ã‚¿ãƒ³ã¯å¤ªé™½ç³»ã§å”¯ä¸€æ¿ƒã„å¤§æ°—ã‚’æŒã¤è¡›æ˜Ÿã§ã€ãƒ¡ã‚¿ãƒ³ã®é›¨ãŒé™ã‚Šã€ãƒ¡ã‚¿ãƒ³ã¨ã‚¨ã‚¿ãƒ³ã®æ¹–ãŒã‚ã‚‹ã€‚åœŸæ˜Ÿã®åŒ—æ¥µã«ã¯å…­è§’å½¢ã®åµãŒã‚ã‚Šã€ã“ã‚Œã¯ä»–ã®æƒ‘æ˜Ÿã§ã¯è¦‹ã‚‰ã‚Œãªã„ç¾è±¡ã€‚åœŸæ˜Ÿã¯å¤ªé™½ç³»ã§æœ€ã‚‚å¹³ãŸã„æƒ‘æ˜Ÿã§ã€æ¥µå¾„ã¨èµ¤é“å¾„ã®å·®ãŒç´„12,000kmã‚‚ã‚ã‚‹ã€‚' },
            { name: 'å¤©ç‹æ˜Ÿ', size: 0.04, distance: 3.2, color: 0x4FD0E7, speed: 0.0003, type: 'uranus', rotationSpeed: 0.007,
              realDistance: '19.2AU', realSize: '51,118km', period: '84å¹´', 
              feature: 'è‡ªè»¢è»¸ãŒ98åº¦å‚¾ã„ã¦ãŠã‚Šã€æ¨ªå€’ã—ã«å›è»¢ã—ã¦ã„ã‚‹æ°·ã®å·¨æ˜Ÿã€‚ã“ã®ç‰¹ç•°ãªè‡ªè»¢ã«ã‚ˆã‚Šã€æ¥µåœ°ã§ã¯42å¹´é–“æ˜¼ãŒç¶šãã€ãã®å¾Œ42å¹´é–“å¤œãŒç¶šãã€‚ãƒ¡ã‚¿ãƒ³æ°·ã®é›²ã«ã‚ˆã‚Šç¾ã—ã„é’ç·‘è‰²ã«è¦‹ãˆã‚‹ã€‚éå¸¸ã«æš—ã„ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã‚’æŒã¡ã€27å€‹ã®è¡›æ˜ŸãŒã‚ã‚‹ã€‚ç£å ´ãŒè‡ªè»¢è»¸ã‹ã‚‰59åº¦ã‚‚å‚¾ã„ã¦ã„ã‚‹å¥‡å¦™ãªæƒ‘æ˜Ÿã€‚',
              discovery: '1781å¹´', 
              fact: 'å¤©ç‹æ˜Ÿã¯å¤ªé™½ç³»ã§æœ€ã‚‚å¯’ã„æƒ‘æ˜Ÿã§ã€æœ€ä½æ¸©åº¦ã¯-224Â°Cã«é”ã™ã‚‹ã€‚æœ¨æ˜Ÿã‚„åœŸæ˜Ÿã‚ˆã‚Šã‚‚é ã„ã®ã«ã€ãªãœã‹æµ·ç‹æ˜Ÿã‚ˆã‚Šã‚‚å¯’ã„ã€‚å¤©ç‹æ˜Ÿã®ç™ºè¦‹ã«ã‚ˆã‚Šå¤ªé™½ç³»ã®å¤§ãã•ãŒä¸€æ°—ã«2å€ã«ãªã£ãŸã€‚å¤©ç‹æ˜Ÿã®è¡›æ˜Ÿã¯ã™ã¹ã¦ã‚·ã‚§ã‚¤ã‚¯ã‚¹ãƒ”ã‚¢ã®ä½œå“ã®ç™»å ´äººç‰©ã«ã¡ãªã‚“ã§åä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹ã€‚å¤©ç‹æ˜Ÿã®1å¹´ã¯åœ°çƒã®84å¹´ã«ç›¸å½“ã™ã‚‹ã€‚' },
            { name: 'æµ·ç‹æ˜Ÿ', size: 0.04, distance: 3.8, color: 0x4169E1, speed: 0.0002, type: 'neptune', rotationSpeed: 0.006,
              realDistance: '30.1AU', realSize: '49,528km', period: '165å¹´', 
              feature: 'å¤ªé™½ç³»æœ€ã‚‚é ã„æƒ‘æ˜Ÿã§ã€æ·±ã„é’è‰²ãŒç¾ã—ã„æ°·ã®å·¨æ˜Ÿã€‚å¤ªé™½ç³»ã§æœ€ã‚‚å¼·ã„é¢¨ãŒå¹ãã€ãã®é€Ÿåº¦ã¯æ™‚é€Ÿ2,100kmã«é”ã™ã‚‹ã€‚ã“ã‚Œã¯éŸ³é€Ÿã®1.5å€ã¨ã„ã†é©šç•°çš„ãªé€Ÿã•ã€‚å¤§æš—æ–‘ã¨ã„ã†å·¨å¤§ãªåµãŒã‚ã£ãŸãŒã€ç¾åœ¨ã¯æ¶ˆå¤±ã—ã¦ã„ã‚‹ã€‚16å€‹ã®è¡›æ˜Ÿã‚’æŒã¡ã€æœ€å¤§ã®è¡›æ˜Ÿãƒˆãƒªãƒˆãƒ³ã¯é€†è¡Œè»Œé“ã‚’æŒã¤çã—ã„è¡›æ˜Ÿã€‚',
              discovery: '1846å¹´', 
              fact: 'æµ·ç‹æ˜Ÿã¯è¨ˆç®—ã«ã‚ˆã£ã¦ç™ºè¦‹ã•ã‚ŒãŸå”¯ä¸€ã®æƒ‘æ˜Ÿã§ã€å¤©ç‹æ˜Ÿã®è»Œé“ã®ä¹±ã‚Œã‹ã‚‰å­˜åœ¨ãŒäºˆæ¸¬ã•ã‚ŒãŸã€‚æµ·ç‹æ˜Ÿã¯2011å¹´ã«ã‚ˆã†ã‚„ãç™ºè¦‹ä»¥æ¥åˆã‚ã¦ã®å…¬è»¢ã‚’å®Œäº†ã—ãŸã€‚æµ·ç‹æ˜Ÿã®è¡›æ˜Ÿãƒˆãƒªãƒˆãƒ³ã¯å¤ªé™½ç³»ã§æœ€ã‚‚å¯’ã„å ´æ‰€ã®ä¸€ã¤ã§ã€-235Â°Cã¨ã„ã†æ¥µä½æ¸©ã€‚æµ·ç‹æ˜Ÿã®ã‚³ã‚¢ã®æ¸©åº¦ã¯ç´„5,000Â°Cã§ã€å¤ªé™½ã®è¡¨é¢ã¨ã»ã¼åŒã˜æ¸©åº¦ã€‚' }
        ];

        // æƒ‘æ˜Ÿãƒ†ã‚¯ã‚¹ãƒãƒ£ç”Ÿæˆ
        function createPlanetTexture(type, size = 1024) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            switch(type) {
                case 'sun':
                    // é«˜å“è³ªãªå¤ªé™½ãƒ†ã‚¯ã‚¹ãƒãƒ£
                    const centerX = size / 2;
                    const centerY = size / 2;
                    const radius = size / 2;
                    
                    // ãƒ™ãƒ¼ã‚¹ã®æ”¾å°„ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆã‚ˆã‚Šæ˜ã‚‹ãå¼·åŒ–ï¼‰
                    const sunGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                    sunGradient.addColorStop(0, '#FFFFFF');  // ç´”ç™½ã®ä¸­å¿ƒ
                    sunGradient.addColorStop(0.1, '#FFFFCC'); // æ˜ã‚‹ã„é»„ç™½
                    sunGradient.addColorStop(0.3, '#FFFF66'); // æ˜ã‚‹ã„é»„è‰²
                    sunGradient.addColorStop(0.5, '#FFCC33'); // æ˜ã‚‹ã„ã‚ªãƒ¬ãƒ³ã‚¸é»„
                    sunGradient.addColorStop(0.7, '#FF9900'); // å¼·ã„ã‚ªãƒ¬ãƒ³ã‚¸
                    sunGradient.addColorStop(0.9, '#FF6600'); // æ·±ã„ã‚ªãƒ¬ãƒ³ã‚¸
                    sunGradient.addColorStop(1, '#DD4400');   // èµ¤ã¿ã®ã‚ã‚‹ç¸
                    ctx.fillStyle = sunGradient;
                    ctx.fillRect(0, 0, size, size);
                    
                    // å¼·åŒ–ã•ã‚ŒãŸã‚³ãƒ­ãƒŠåŠ¹æœ
                    for(let i = 0; i < 12; i++) {
                        const angle = (i / 12) * Math.PI * 2;
                        const coronaX = centerX + Math.cos(angle) * radius * 0.6;
                        const coronaY = centerY + Math.sin(angle) * radius * 0.6;
                        const coronaGradient = ctx.createRadialGradient(coronaX, coronaY, 0, coronaX, coronaY, radius * 0.4);
                        coronaGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)'); // ã‚ˆã‚Šæ˜ã‚‹ã„ç™½
                        coronaGradient.addColorStop(0.4, 'rgba(255, 255, 180, 0.7)');
                        coronaGradient.addColorStop(1, 'rgba(255, 255, 100, 0)');
                        ctx.fillStyle = coronaGradient;
                        ctx.fillRect(0, 0, size, size);
                    }
                    
                    // è¿½åŠ ã®æ˜ã‚‹ã„ã‚³ãƒ­ãƒŠãƒªãƒ³ã‚°
                    const mainCoronaGradient = ctx.createRadialGradient(centerX, centerY, radius * 0.8, centerX, centerY, radius);
                    mainCoronaGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                    mainCoronaGradient.addColorStop(0.5, 'rgba(255, 255, 200, 0.4)');
                    mainCoronaGradient.addColorStop(1, 'rgba(255, 255, 100, 0)');
                    ctx.fillStyle = mainCoronaGradient;
                    ctx.fillRect(0, 0, size, size);
                    
                    // ãƒ—ãƒ­ãƒŸãƒãƒ³ã‚¹ï¼ˆå¤ªé™½ãƒ•ãƒ¬ã‚¢ï¼‰
                    for(let i = 0; i < 12; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const flareX = centerX + Math.cos(angle) * radius * 0.8;
                        const flareY = centerY + Math.sin(angle) * radius * 0.8;
                        const flareLength = 20 + Math.random() * 40;
                        
                        ctx.beginPath();
                        ctx.moveTo(flareX, flareY);
                        ctx.lineTo(flareX + Math.cos(angle) * flareLength, flareY + Math.sin(angle) * flareLength);
                        ctx.strokeStyle = `rgba(255, ${200 + Math.random() * 55}, 100, ${0.4 + Math.random() * 0.4})`;
                        ctx.lineWidth = 2 + Math.random() * 3;
                        ctx.stroke();
                    }
                    
                    // è¡¨é¢ã®ç²’çŠ¶æ–‘
                    for(let i = 0; i < 200; i++) {
                        const granuleX = Math.random() * size;
                        const granuleY = Math.random() * size;
                        const granuleSize = 2 + Math.random() * 8;
                        const intensity = 0.2 + Math.random() * 0.3;
                        
                        ctx.beginPath();
                        ctx.arc(granuleX, granuleY, granuleSize, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, ${180 + Math.random() * 75}, 80, ${intensity})`;
                        ctx.fill();
                    }
                    
                    // ç£å ´ãƒ©ã‚¤ãƒ³
                    for(let i = 0; i < 15; i++) {
                        ctx.beginPath();
                        const startAngle = Math.random() * Math.PI * 2;
                        const startX = centerX + Math.cos(startAngle) * radius * 0.6;
                        const startY = centerY + Math.sin(startAngle) * radius * 0.6;
                        
                        ctx.moveTo(startX, startY);
                        for(let j = 1; j <= 5; j++) {
                            const t = j / 5;
                            const currentAngle = startAngle + (Math.random() - 0.5) * 0.5;
                            const currentRadius = radius * (0.6 + t * 0.3);
                            const x = centerX + Math.cos(currentAngle) * currentRadius;
                            const y = centerY + Math.sin(currentAngle) * currentRadius;
                            ctx.lineTo(x, y);
                        }
                        
                        ctx.strokeStyle = `rgba(255, 255, 150, ${0.2 + Math.random() * 0.2})`;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                    break;
                    
                case 'earth':
                    // é«˜å“è³ªãªåœ°çƒãƒ†ã‚¯ã‚¹ãƒãƒ£
                    const earthGradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                    earthGradient.addColorStop(0, '#5BA3E0');
                    earthGradient.addColorStop(0.6, '#4A90E2');
                    earthGradient.addColorStop(0.8, '#2E5A87');
                    earthGradient.addColorStop(1, '#1A3B5C');
                    ctx.fillStyle = earthGradient;
                    ctx.fillRect(0, 0, size, size);
                    
                    // ã‚ˆã‚Šè©³ç´°ãªå¤§é™¸é…ç½®
                    const continents = [
                        // ãƒ¦ãƒ¼ãƒ©ã‚·ã‚¢å¤§é™¸
                        {x: size*0.4, y: size*0.35, w: 160, h: 80, rotation: 0.1},
                        {x: size*0.55, y: size*0.4, w: 140, h: 70, rotation: -0.1},
                        // ã‚¢ãƒ•ãƒªã‚«å¤§é™¸
                        {x: size*0.45, y: size*0.55, w: 80, h: 120, rotation: 0},
                        // åŒ—ç±³å¤§é™¸
                        {x: size*0.15, y: size*0.4, w: 100, h: 140, rotation: 0.2},
                        // å—ç±³å¤§é™¸
                        {x: size*0.25, y: size*0.65, w: 60, h: 100, rotation: -0.15},
                        // ã‚ªãƒ¼ã‚¹ãƒˆãƒ©ãƒªã‚¢
                        {x: size*0.75, y: size*0.7, w: 50, h: 40, rotation: 0},
                        // ãã®ä»–ã®å³¶ã€…
                        {x: size*0.8, y: size*0.5, w: 30, h: 60, rotation: 0.3},
                        {x: size*0.1, y: size*0.65, w: 25, h: 35, rotation: 0}
                    ];
                    
                    continents.forEach(continent => {
                        ctx.save();
                        ctx.translate(continent.x, continent.y);
                        ctx.rotate(continent.rotation);
                        
                        // å¤§é™¸ã®å½±
                        ctx.fillStyle = '#1E5A1E';
                        ctx.beginPath();
                        ctx.ellipse(2, 2, continent.w/2, continent.h/2, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ãƒ¡ã‚¤ãƒ³å¤§é™¸
                        ctx.fillStyle = '#228B22';
                        ctx.beginPath();
                        ctx.ellipse(0, 0, continent.w/2, continent.h/2, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // å±±è„ˆã‚„é«˜åœ°
                        ctx.fillStyle = '#8B7355';
                        for(let i = 0; i < 3; i++) {
                            const mx = (Math.random() - 0.5) * continent.w * 0.6;
                            const my = (Math.random() - 0.5) * continent.h * 0.6;
                            ctx.beginPath();
                            ctx.ellipse(mx, my, 8 + Math.random() * 15, 4 + Math.random() * 8, Math.random() * Math.PI, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        ctx.restore();
                    });
                    
                    // æ¥µåœ°ã®æ°·
                    const northIceGradient = ctx.createRadialGradient(size/2, 20, 0, size/2, 20, 40);
                    northIceGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    northIceGradient.addColorStop(1, 'rgba(255, 255, 255, 0.6)');
                    ctx.fillStyle = northIceGradient;
                    ctx.beginPath();
                    ctx.arc(size/2, 20, 40, 0, Math.PI * 2);
                    ctx.fill();
                    
                    const southIceGradient = ctx.createRadialGradient(size/2, size-20, 0, size/2, size-20, 35);
                    southIceGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    southIceGradient.addColorStop(1, 'rgba(255, 255, 255, 0.6)');
                    ctx.fillStyle = southIceGradient;
                    ctx.beginPath();
                    ctx.arc(size/2, size-20, 35, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // é›²ã®ã‚·ã‚¹ãƒ†ãƒ 
                    ctx.globalAlpha = 0.6;
                    for(let i = 0; i < 30; i++) {
                        const cloudX = Math.random() * size;
                        const cloudY = Math.random() * size;
                        const cloudSize = 20 + Math.random() * 40;
                        
                        const cloudGradient = ctx.createRadialGradient(cloudX, cloudY, 0, cloudX, cloudY, cloudSize);
                        cloudGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                        cloudGradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.4)');
                        cloudGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                        
                        ctx.fillStyle = cloudGradient;
                        ctx.beginPath();
                        ctx.arc(cloudX, cloudY, cloudSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                    
                    // å¤œã®éƒ¨åˆ†ï¼ˆéƒ½å¸‚ã®å…‰ï¼‰
                    ctx.globalCompositeOperation = 'multiply';
                    const nightGradient = ctx.createLinearGradient(0, 0, size, 0);
                    nightGradient.addColorStop(0, 'rgba(100, 100, 150, 0.3)');
                    nightGradient.addColorStop(0.3, 'rgba(255, 255, 255, 1)');
                    nightGradient.addColorStop(1, 'rgba(100, 100, 150, 0.3)');
                    ctx.fillStyle = nightGradient;
                    ctx.fillRect(0, 0, size, size);
                    ctx.globalCompositeOperation = 'source-over';
                    break;
                    
                case 'mars':
                    const marsGradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                    marsGradient.addColorStop(0, '#CD853F');
                    marsGradient.addColorStop(0.5, '#CD5C5C');
                    marsGradient.addColorStop(1, '#8B0000');
                    ctx.fillStyle = marsGradient;
                    ctx.fillRect(0, 0, size, size);
                    
                    // ã‚ªãƒªãƒ³ãƒã‚¹å±±
                    ctx.fillStyle = '#A0522D';
                    ctx.beginPath();
                    ctx.arc(size*0.3, size*0.4, 18, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // æ¥µå† 
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.beginPath();
                    ctx.arc(size/2, 10, 35, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(size/2, size-10, 30, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'jupiter':
                    // é«˜å“è³ªãªæœ¨æ˜Ÿãƒ†ã‚¯ã‚¹ãƒãƒ£
                    const jupiterBase = ctx.createLinearGradient(0, 0, 0, size);
                    jupiterBase.addColorStop(0, '#F4E4BC');
                    jupiterBase.addColorStop(0.15, '#E6B87D');
                    jupiterBase.addColorStop(0.3, '#D2691E');
                    jupiterBase.addColorStop(0.45, '#CD853F');
                    jupiterBase.addColorStop(0.6, '#A0522D');
                    jupiterBase.addColorStop(0.75, '#8B4513');
                    jupiterBase.addColorStop(0.9, '#654321');
                    jupiterBase.addColorStop(1, '#4A2C17');
                    ctx.fillStyle = jupiterBase;
                    ctx.fillRect(0, 0, size, size);
                    
                    // ã‚ˆã‚Šè©³ç´°ãªç¸æ¨¡æ§˜
                    for(let i = 0; i < 40; i++) {
                        const y = (i / 40) * size;
                        const beltHeight = 8 + Math.random() * 25;
                        const opacity = 0.2 + Math.random() * 0.5;
                        const variation = Math.sin(i * 0.3) * 0.2;
                        
                        // ãƒ™ãƒ«ãƒˆã®åŸºæœ¬è‰²
                        const beltColors = [
                            `rgba(${220 + Math.random() * 35}, ${170 + Math.random() * 50}, ${100 + Math.random() * 40}, ${opacity})`,
                            `rgba(${180 + Math.random() * 40}, ${120 + Math.random() * 50}, ${80 + Math.random() * 30}, ${opacity})`,
                            `rgba(${160 + Math.random() * 30}, ${100 + Math.random() * 40}, ${60 + Math.random() * 25}, ${opacity})`
                        ];
                        
                        ctx.fillStyle = beltColors[i % 3];
                        
                        // æ³¢æ‰“ã¤ç¸æ¨¡æ§˜
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        for(let x = 0; x <= size; x += 10) {
                            const waveY = y + Math.sin(x * 0.02 + i) * (3 + variation * 5);
                            ctx.lineTo(x, waveY);
                        }
                        for(let x = size; x >= 0; x -= 10) {
                            const waveY = y + beltHeight + Math.sin(x * 0.015 + i + 1) * (2 + variation * 3);
                            ctx.lineTo(x, waveY);
                        }
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    // å¤§èµ¤æ–‘ï¼ˆã‚ˆã‚Šè©³ç´°ï¼‰
                    const grsX = size * 0.7;
                    const grsY = size * 0.45;
                    const grsWidth = 60;
                    const grsHeight = 40;
                    
                    // å¤§èµ¤æ–‘ã®å½±
                    ctx.fillStyle = 'rgba(100, 0, 0, 0.4)';
                    ctx.beginPath();
                    ctx.ellipse(grsX + 2, grsY + 2, grsWidth/2, grsHeight/2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // å¤§èµ¤æ–‘ã®ãƒ¡ã‚¤ãƒ³
                    const grsGradient = ctx.createRadialGradient(grsX, grsY, 0, grsX, grsY, grsWidth/2);
                    grsGradient.addColorStop(0, '#CC4444');
                    grsGradient.addColorStop(0.3, '#BB2222');
                    grsGradient.addColorStop(0.6, '#AA1111');
                    grsGradient.addColorStop(1, '#880000');
                    ctx.fillStyle = grsGradient;
                    ctx.beginPath();
                    ctx.ellipse(grsX, grsY, grsWidth/2, grsHeight/2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // å¤§èµ¤æ–‘ã®æ¸¦å·»ã
                    ctx.strokeStyle = 'rgba(150, 50, 50, 0.6)';
                    ctx.lineWidth = 2;
                    for(let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        const radius = 15 + i * 8;
                        for(let angle = 0; angle < Math.PI * 4; angle += 0.1) {
                            const spiralRadius = radius * (1 - angle / (Math.PI * 4)) * 0.8;
                            const x = grsX + Math.cos(angle) * spiralRadius;
                            const y = grsY + Math.sin(angle) * spiralRadius * 0.7; // æ¥•å††å½¢ã«
                            if(angle === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                    }
                    
                    // å°ã•ãªåµã‚„æ¸¦
                    for(let i = 0; i < 8; i++) {
                        const stormX = Math.random() * size;
                        const stormY = Math.random() * size;
                        const stormSize = 8 + Math.random() * 15;
                        
                        const stormGradient = ctx.createRadialGradient(stormX, stormY, 0, stormX, stormY, stormSize);
                        stormGradient.addColorStop(0, 'rgba(200, 150, 100, 0.6)');
                        stormGradient.addColorStop(1, 'rgba(200, 150, 100, 0)');
                        
                        ctx.fillStyle = stormGradient;
                        ctx.beginPath();
                        ctx.arc(stormX, stormY, stormSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                    
                default:
                    // ãã®ä»–ã®æƒ‘æ˜Ÿ
                    const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
                    gradient.addColorStop(0, '#AAAAAA');
                    gradient.addColorStop(1, '#666666');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, size, size);
            }
            
            return new THREE.CanvasTexture(canvas);
        }

        // æ˜Ÿç©ºä½œæˆ
        function createStarField() {
            const starGeometry = new THREE.BufferGeometry();
            const starPositions = [];
            const starSizes = [];
            
            for (let i = 0; i < 5000; i++) {
                starPositions.push(
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200
                );
                starSizes.push(Math.random() * 2 + 0.5);
            }
            
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));
            
            const starMaterial = new THREE.PointsMaterial({
                color: 0xFFFFFF,
                size: 0.05,
                transparent: true,
                opacity: 0.8
            });
            
            return new THREE.Points(starGeometry, starMaterial);
        }

        // å®‡å®™ç©ºé–“ã®æ˜Ÿç©ºä½œæˆï¼ˆå¤§å¹…å¼·åŒ–ï¼‰
        function createSpaceStarField() {
            const starGeometry = new THREE.BufferGeometry();
            const starPositions = [];
            const starColors = [];
            const starSizes = [];
            
            for (let i = 0; i < 12000; i++) { // 25000ã‹ã‚‰12000ã«è»½é‡åŒ–
                // ã‚ˆã‚Šåºƒç¯„å›²ã«æ˜Ÿã‚’é…ç½®ï¼ˆå¤©ã®å·éŠ€æ²³ã‚’æ¨¡æ“¬ï¼‰
                let radius, x, y, z;
                
                if (i < 9000) { // 20000ã‹ã‚‰9000ã«èª¿æ•´
                    // å¤©ã®å·éŠ€æ²³ã®å††ç›¤éƒ¨åˆ†
                    const diskRadius = 100 + Math.random() * 200;
                    const diskAngle = Math.random() * Math.PI * 2;
                    const diskHeight = (Math.random() - 0.5) * 20;
                    
                    x = diskRadius * Math.cos(diskAngle);
                    y = diskHeight;
                    z = diskRadius * Math.sin(diskAngle);
                } else {
                    // ãƒãƒ­ãƒ¼éƒ¨åˆ†ï¼ˆçƒçŠ¶åˆ†å¸ƒï¼‰
                    radius = 150 + Math.random() * 100;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    x = radius * Math.sin(phi) * Math.cos(theta);
                    y = radius * Math.sin(phi) * Math.sin(theta);
                    z = radius * Math.cos(phi);
                }
                
                starPositions.push(x, y, z);
                
                // ã‚ˆã‚Šç¾å®Ÿçš„ãªæ’æ˜Ÿã®è‰²åˆ†å¸ƒ
                const colorType = Math.random();
                if (colorType < 0.1) {
                    // Oå‹æ˜Ÿï¼ˆé’è‰²ã€éå¸¸ã«ç¨€ï¼‰
                    starColors.push(0.6, 0.8, 1);
                    starSizes.push(Math.random() * 4 + 2);
                } else if (colorType < 0.2) {
                    // Bå‹æ˜Ÿï¼ˆé’ç™½è‰²ï¼‰
                    starColors.push(0.8, 0.9, 1);
                    starSizes.push(Math.random() * 3 + 1.5);
                } else if (colorType < 0.3) {
                    // Aå‹æ˜Ÿï¼ˆç™½è‰²ï¼‰
                    starColors.push(1, 1, 1);
                    starSizes.push(Math.random() * 2.5 + 1);
                } else if (colorType < 0.4) {
                    // Få‹æ˜Ÿï¼ˆé»„ç™½è‰²ï¼‰
                    starColors.push(1, 1, 0.9);
                    starSizes.push(Math.random() * 2 + 0.8);
                } else if (colorType < 0.5) {
                    // Gå‹æ˜Ÿï¼ˆé»„è‰²ã€å¤ªé™½å‹ï¼‰
                    starColors.push(1, 0.95, 0.8);
                    starSizes.push(Math.random() * 1.8 + 0.7);
                } else if (colorType < 0.7) {
                    // Kå‹æ˜Ÿï¼ˆã‚ªãƒ¬ãƒ³ã‚¸è‰²ï¼‰
                    starColors.push(1, 0.8, 0.6);
                    starSizes.push(Math.random() * 1.5 + 0.6);
                } else {
                    // Må‹æ˜Ÿï¼ˆèµ¤è‰²çŸ®æ˜Ÿã€æœ€ã‚‚å¤šã„ï¼‰
                    starColors.push(1, 0.6, 0.4);
                    starSizes.push(Math.random() * 1 + 0.3);
                }
            }
            
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
            starGeometry.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));
            
            const starMaterial = new THREE.PointsMaterial({
                vertexColors: true,
                size: 0.06,
                transparent: true,
                opacity: 0, // åˆæœŸå€¤ã‚’0ã«è¨­å®š
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending
            });
            
            return new THREE.Points(starGeometry, starMaterial);
        }

        // èƒŒæ™¯ãƒ•ã‚§ãƒ¼ãƒ‰ç”¨ã®çƒä½“ã‚’ä½œæˆ
        function createBackgroundSphere() {
            const geometry = new THREE.SphereGeometry(300, 32, 16);
            const material = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0,
                side: THREE.BackSide // å†…å´ã‹ã‚‰è¦‹ãˆã‚‹ã‚ˆã†ã«
            });
            
            return new THREE.Mesh(geometry, material);
        }

        // å°æƒ‘æ˜Ÿå¸¯ã‚’ä½œæˆï¼ˆç«æ˜Ÿã¨æœ¨æ˜Ÿã®é–“ï¼‰
        function createAsteroidBelt() {
            const asteroidGroup = new THREE.Group();
            const asteroidCount = 80; // 200ã‹ã‚‰80ã«è»½é‡åŒ–
            const innerRadius = 1.7;  // ç«æ˜Ÿè»Œé“ã‚ˆã‚Šå¤–å´
            const outerRadius = 1.9;  // æœ¨æ˜Ÿè»Œé“ã‚ˆã‚Šå†…å´
            
            for (let i = 0; i < asteroidCount; i++) {
                // ãƒ©ãƒ³ãƒ€ãƒ ãªè·é›¢ï¼ˆå°æƒ‘æ˜Ÿå¸¯ã®ç¯„å›²å†…ï¼‰
                const distance = innerRadius + Math.random() * (outerRadius - innerRadius);
                const angle = Math.random() * Math.PI * 2;
                
                // å°æƒ‘æ˜Ÿã®ã‚µã‚¤ã‚ºï¼ˆéå¸¸ã«å°ã•ãï¼‰
                const size = 0.001 + Math.random() * 0.003;
                
                // ä¸è¦å‰‡ãªå½¢çŠ¶ã‚’ä½œæˆ
                const geometry = new THREE.SphereGeometry(size, 6, 4);
                const vertices = geometry.attributes.position.array;
                for (let j = 0; j < vertices.length; j += 3) {
                    const factor = 0.7 + Math.random() * 0.6; // ä¸è¦å‰‡æ€§
                    vertices[j] *= factor;
                    vertices[j + 1] *= factor;
                    vertices[j + 2] *= factor;
                }
                geometry.attributes.position.needsUpdate = true;
                
                const material = new THREE.MeshLambertMaterial({
                    color: new THREE.Color().setHSL(0.1, 0.3, 0.2 + Math.random() * 0.3)
                });
                
                const asteroid = new THREE.Mesh(geometry, material);
                asteroid.position.x = Math.cos(angle) * distance;
                asteroid.position.z = Math.sin(angle) * distance;
                asteroid.position.y = (Math.random() - 0.5) * 0.05; // å°‘ã—é«˜ã•ã«ã°ã‚‰ã¤ã
                
                asteroid.rotation.x = Math.random() * Math.PI * 2;
                asteroid.rotation.y = Math.random() * Math.PI * 2;
                asteroid.rotation.z = Math.random() * Math.PI * 2;
                
                asteroid.castShadow = true;
                asteroid.receiveShadow = true;
                
                // å›è»¢é€Ÿåº¦ã‚’è¨­å®š
                asteroid.userData = {
                    rotationSpeed: (Math.random() - 0.5) * 0.01,
                    orbitSpeed: 0.0001 + Math.random() * 0.0002,
                    angle: angle,
                    distance: distance
                };
                
                asteroidGroup.add(asteroid);
            }
            
            solarSystemGroup.add(asteroidGroup);
            return asteroidGroup;
        }

        // ã‚«ã‚¤ãƒ‘ãƒ¼ãƒ™ãƒ«ãƒˆã‚’ä½œæˆï¼ˆæµ·ç‹æ˜Ÿã®å¤–å´ï¼‰
        function createKuiperBelt() {
            const kuiperGroup = new THREE.Group();
            const objectCount = 60; // 150ã‹ã‚‰60ã«è»½é‡åŒ–
            const innerRadius = 4.2;  // æµ·ç‹æ˜Ÿè»Œé“ã‚ˆã‚Šå¤–å´
            const outerRadius = 6.0;  // ã•ã‚‰ã«å¤–å´
            
            for (let i = 0; i < objectCount; i++) {
                const distance = innerRadius + Math.random() * (outerRadius - innerRadius);
                const angle = Math.random() * Math.PI * 2;
                
                // ã‚«ã‚¤ãƒ‘ãƒ¼ãƒ™ãƒ«ãƒˆå¤©ä½“ã®ã‚µã‚¤ã‚º
                const size = 0.002 + Math.random() * 0.008;
                
                const geometry = new THREE.SphereGeometry(size, 8, 6);
                const material = new THREE.MeshLambertMaterial({
                    color: new THREE.Color().setHSL(0.6, 0.4, 0.15 + Math.random() * 0.2)
                });
                
                const kbo = new THREE.Mesh(geometry, material);
                kbo.position.x = Math.cos(angle) * distance;
                kbo.position.z = Math.sin(angle) * distance;
                kbo.position.y = (Math.random() - 0.5) * 0.3; // ã‚ˆã‚Šå¤§ããªè»Œé“å‚¾æ–œ
                
                kbo.castShadow = true;
                kbo.receiveShadow = true;
                
                kbo.userData = {
                    rotationSpeed: (Math.random() - 0.5) * 0.005,
                    orbitSpeed: 0.00005 + Math.random() * 0.00005,
                    angle: angle,
                    distance: distance
                };
                
                kuiperGroup.add(kbo);
            }
            
            solarSystemGroup.add(kuiperGroup);
            return kuiperGroup;
        }

        // å¤ªé™½ç³»å¤–ã®æ’æ˜Ÿã‚’ä½œæˆ
        function createDistantStars() {
            const starGroup = new THREE.Group();
            const starCount = 25; // 50ã‹ã‚‰25ã«è»½é‡åŒ–
            
            for (let i = 0; i < starCount; i++) {
                // é æ–¹ã®æ’æ˜Ÿ
                const distance = 20 + Math.random() * 80;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                // æ’æ˜Ÿã®ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸã‚µã‚¤ã‚ºã¨è‰²
                const starType = Math.random();
                let size, color, intensity;
                
                if (starType < 0.3) {
                    // èµ¤è‰²çŸ®æ˜Ÿ
                    size = 0.05 + Math.random() * 0.1;
                    color = new THREE.Color(0xFF6644);
                    intensity = 0.3;
                } else if (starType < 0.6) {
                    // å¤ªé™½å‹æ˜Ÿ
                    size = 0.08 + Math.random() * 0.12;
                    color = new THREE.Color(0xFFFFAA);
                    intensity = 0.5;
                } else if (starType < 0.8) {
                    // é’è‰²å·¨æ˜Ÿ
                    size = 0.12 + Math.random() * 0.2;
                    color = new THREE.Color(0xAADDFF);
                    intensity = 0.8;
                } else {
                    // èµ¤è‰²å·¨æ˜Ÿ
                    size = 0.2 + Math.random() * 0.3;
                    color = new THREE.Color(0xFF8844);
                    intensity = 0.6;
                }
                
                const geometry = new THREE.SphereGeometry(size, 16, 12);
                const material = new THREE.MeshBasicMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: intensity
                });
                
                const star = new THREE.Mesh(geometry, material);
                star.position.x = distance * Math.sin(phi) * Math.cos(theta);
                star.position.y = distance * Math.sin(phi) * Math.sin(theta);
                star.position.z = distance * Math.cos(phi);
                
                // å¾®ã‹ãªå…‰æºã‚’è¿½åŠ 
                const starLight = new THREE.PointLight(color, 0.1, distance * 0.5);
                starLight.position.copy(star.position);
                scene.add(starLight);
                
                starGroup.add(star);
            }
            
            scene.add(starGroup);
            return starGroup;
        }

        // é æ–¹ã®éŠ€æ²³ã‚’ä½œæˆ
        function createDistantGalaxies() {
            const galaxyGroup = new THREE.Group();
            const galaxyCount = 12; // 20ã‹ã‚‰12ã«è»½é‡åŒ–
            
            for (let i = 0; i < galaxyCount; i++) {
                // éå¸¸ã«é æ–¹ã®éŠ€æ²³
                const distance = 150 + Math.random() * 200;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                // éŠ€æ²³ã®å½¢çŠ¶ã‚’ä½œæˆ
                const galaxyGeometry = new THREE.PlaneGeometry(2 + Math.random() * 4, 1 + Math.random() * 2);
                
                // éŠ€æ²³ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ä½œæˆ
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                
                // éŠ€æ²³ã®æ¸¦å·»ãæ¨¡æ§˜
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                // èƒŒæ™¯
                ctx.fillStyle = 'rgba(0, 0, 0, 0)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // éŠ€æ²³ã‚³ã‚¢
                const coreGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 20);
                coreGradient.addColorStop(0, 'rgba(255, 220, 150, 0.8)');
                coreGradient.addColorStop(0.5, 'rgba(200, 150, 100, 0.4)');
                coreGradient.addColorStop(1, 'rgba(100, 100, 150, 0.1)');
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 20, 0, Math.PI * 2);
                ctx.fill();
                
                // æ¸¦å·»ãã‚¢ãƒ¼ãƒ 
                for (let arm = 0; arm < 2; arm++) {
                    ctx.strokeStyle = `rgba(150, 150, 200, ${0.3 + Math.random() * 0.2})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    for (let angle = 0; angle < Math.PI * 4; angle += 0.1) {
                        const radius = 5 + angle * 3;
                        const x = centerX + Math.cos(angle + arm * Math.PI) * radius;
                        const y = centerY + Math.sin(angle + arm * Math.PI) * radius * 0.3;
                        
                        if (angle === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                
                const galaxyTexture = new THREE.CanvasTexture(canvas);
                const galaxyMaterial = new THREE.MeshBasicMaterial({
                    map: galaxyTexture,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide
                });
                
                const galaxy = new THREE.Mesh(galaxyGeometry, galaxyMaterial);
                galaxy.position.x = distance * Math.sin(phi) * Math.cos(theta);
                galaxy.position.y = distance * Math.sin(phi) * Math.sin(theta);
                galaxy.position.z = distance * Math.cos(phi);
                
                // éŠ€æ²³ã‚’ã‚«ãƒ¡ãƒ©ã®æ–¹å‘ã«å‘ã‘ã‚‹
                galaxy.lookAt(0, 0, 0);
                
                // ã‚†ã£ãã‚Šã¨ã—ãŸå›è»¢
                galaxy.userData = {
                    rotationSpeed: (Math.random() - 0.5) * 0.001
                };
                
                galaxyGroup.add(galaxy);
            }
            
            scene.add(galaxyGroup);
            return galaxyGroup;
        }

        // æœ‰åãªæ˜Ÿåº§ã‚’ä½œæˆ
        function createConstellations() {
            const constellationGroup = new THREE.Group();
            
            // ã‚ªãƒªã‚ªãƒ³åº§ã‚’ä½œæˆ
            const orionStars = [
                // ãƒ™ãƒ†ãƒ«ã‚®ã‚¦ã‚¹ï¼ˆå·¦è‚©ï¼‰
                { name: 'ãƒ™ãƒ†ãƒ«ã‚®ã‚¦ã‚¹', pos: [-30, 25, -80], color: 0xFF6644, size: 0.15 },
                // ãƒªã‚²ãƒ«ï¼ˆå³è¶³ï¼‰
                { name: 'ãƒªã‚²ãƒ«', pos: [25, -25, -80], color: 0xAADDFF, size: 0.12 },
                // ãƒ™ãƒ©ãƒˆãƒªãƒƒã‚¯ã‚¹ï¼ˆå³è‚©ï¼‰
                { name: 'ãƒ™ãƒ©ãƒˆãƒªãƒƒã‚¯ã‚¹', pos: [20, 15, -80], color: 0xDDEEFF, size: 0.08 },
                // ã‚ªãƒªã‚ªãƒ³ãƒ™ãƒ«ãƒˆ
                { name: 'ã‚¢ãƒ«ãƒ‹ã‚¿ã‚¯', pos: [-8, 0, -80], color: 0xDDEEFF, size: 0.09 },
                { name: 'ã‚¢ãƒ«ãƒ‹ãƒ©ãƒ ', pos: [0, 0, -80], color: 0xDDEEFF, size: 0.09 },
                { name: 'ãƒŸãƒ³ã‚¿ã‚«', pos: [8, 0, -80], color: 0xDDEEFF, size: 0.08 },
                // å‰£
                { name: 'ã‚ªãƒªã‚ªãƒ³æ˜Ÿé›²', pos: [0, -15, -80], color: 0xFF99DD, size: 0.1 }
            ];
            
            orionStars.forEach(star => {
                const geometry = new THREE.SphereGeometry(star.size, 16, 12);
                const material = new THREE.MeshBasicMaterial({
                    color: star.color,
                    emissive: star.color,
                    emissiveIntensity: 0.8
                });
                
                const starMesh = new THREE.Mesh(geometry, material);
                starMesh.position.set(star.pos[0], star.pos[1], star.pos[2]);
                starMesh.name = star.name;
                
                // æ˜Ÿã®å…‰ã‚’è¿½åŠ 
                const starLight = new THREE.PointLight(star.color, 0.5, 50);
                starLight.position.copy(starMesh.position);
                scene.add(starLight);
                
                constellationGroup.add(starMesh);
            });
            
            // åŒ—æ–—ä¸ƒæ˜Ÿã‚’ä½œæˆ
            const bigDipperStars = [
                { pos: [-60, 40, -90], color: 0xFFFFAA, size: 0.1 },
                { pos: [-50, 45, -90], color: 0xFFFFAA, size: 0.09 },
                { pos: [-40, 42, -90], color: 0xFFFFAA, size: 0.08 },
                { pos: [-30, 40, -90], color: 0xFFFFAA, size: 0.09 },
                { pos: [-20, 35, -90], color: 0xFFFFAA, size: 0.08 },
                { pos: [-15, 25, -90], color: 0xFFFFAA, size: 0.09 },
                { pos: [-10, 15, -90], color: 0xFFFFAA, size: 0.08 }
            ];
            
            bigDipperStars.forEach((star, index) => {
                const geometry = new THREE.SphereGeometry(star.size, 16, 12);
                const material = new THREE.MeshBasicMaterial({
                    color: star.color,
                    emissive: star.color,
                    emissiveIntensity: 0.7
                });
                
                const starMesh = new THREE.Mesh(geometry, material);
                starMesh.position.set(star.pos[0], star.pos[1], star.pos[2]);
                starMesh.name = `åŒ—æ–—ä¸ƒæ˜Ÿ${index + 1}`;
                
                constellationGroup.add(starMesh);
            });
            
            // ã‚«ã‚·ã‚ªãƒšã‚¢åº§ã‚’ä½œæˆï¼ˆWå­—å‹ï¼‰
            const cassiopeiaStars = [
                { pos: [60, 50, -85], color: 0xDDEEFF, size: 0.09 },
                { pos: [55, 55, -85], color: 0xDDEEFF, size: 0.08 },
                { pos: [50, 52, -85], color: 0xDDEEFF, size: 0.1 },
                { pos: [45, 58, -85], color: 0xDDEEFF, size: 0.08 },
                { pos: [40, 55, -85], color: 0xDDEEFF, size: 0.09 }
            ];
            
            cassiopeiaStars.forEach((star, index) => {
                const geometry = new THREE.SphereGeometry(star.size, 16, 12);
                const material = new THREE.MeshBasicMaterial({
                    color: star.color,
                    emissive: star.color,
                    emissiveIntensity: 0.7
                });
                
                const starMesh = new THREE.Mesh(geometry, material);
                starMesh.position.set(star.pos[0], star.pos[1], star.pos[2]);
                starMesh.name = `ã‚«ã‚·ã‚ªãƒšã‚¢${index + 1}`;
                
                constellationGroup.add(starMesh);
            });
            
            scene.add(constellationGroup);
            return constellationGroup;
        }

        // WebXRã‚µãƒãƒ¼ãƒˆãƒã‚§ãƒƒã‚¯
        async function checkXRSupport() {
            if ('xr' in navigator) {
                try {
                    const supported = await navigator.xr.isSessionSupported('immersive-ar');
                    xrSupported = supported;
                } catch (error) {
                    try {
                        const supported = await navigator.xr.isSessionSupported('immersive-vr');
                        xrSupported = supported;
                    } catch (error) {
                        xrSupported = false;
                    }
                }
            }

            const button = document.getElementById('xr-button');
            button.disabled = true; // åˆæœŸçŠ¶æ…‹ã§ã¯ç„¡åŠ¹
            
            if (!xrSupported) {
                button.textContent = 'XRéå¯¾å¿œãƒ‡ãƒã‚¤ã‚¹';
                document.getElementById('warning-panel').style.display = 'block';
            } else {
                button.textContent = 'èª­ã¿è¾¼ã¿ä¸­...';
            }
        }

        // åˆæœŸåŒ–
        function init() {
            const container = document.getElementById('container');

            // BGMåˆæœŸåŒ–
            bgMusic = document.getElementById('bgm');
            bgMusic.volume = 0.3; // éŸ³é‡ã‚’30%ã«è¨­å®š
            
            // ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ã‚¿ãƒ¼åˆæœŸåŒ–
            raycaster = new THREE.Raycaster();

            // ã‚·ãƒ¼ãƒ³ä½œæˆ
            scene = new THREE.Scene();

            // ã‚«ãƒ¡ãƒ©ä½œæˆ
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.001, 1000);
            camera.position.set(0, 1.6, 5);

            // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ä½œæˆ
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            // å¤ªé™½ç³»ã‚°ãƒ«ãƒ¼ãƒ—
            solarSystemGroup = new THREE.Group();
            solarSystemGroup.position.set(0, 1, -2);
            scene.add(solarSystemGroup);
            
            // åˆæœŸãƒ¦ãƒ¼ã‚¶ãƒ¼ä½ç½®ã‚’è¨­å®š
            updateUserPosition();

            // æ˜Ÿç©º
            const stars = createStarField();
            scene.add(stars);
            originalStars = stars; // å…ƒã®æ˜Ÿç©ºã‚’ä¿å­˜

            // å®‡å®™ç©ºé–“ã®æ˜Ÿç©ºã‚’æº–å‚™ï¼ˆæœ€åˆã¯éè¡¨ç¤ºï¼‰
            spaceStars = createSpaceStarField();
            spaceStars.visible = false;
            scene.add(spaceStars);

            // èƒŒæ™¯ãƒ•ã‚§ãƒ¼ãƒ‰ç”¨çƒä½“ã‚’ä½œæˆ
            backgroundSphere = createBackgroundSphere();
            scene.add(backgroundSphere);

            // ãƒ¡ã‚¤ãƒ³å¤ªé™½å…‰æºï¼ˆç™½é£›ã³é˜²æ­¢ã®ãŸã‚ã•ã‚‰ã«èª¿æ•´ï¼‰
            const sunLight = new THREE.PointLight(0xFFFFDD, 2.5, 100);
            sunLight.position.set(0, 0, 0);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 4096;
            sunLight.shadow.mapSize.height = 4096;
            sunLight.shadow.camera.near = 0.1;
            sunLight.shadow.camera.far = 100;
            solarSystemGroup.add(sunLight);
            
            // è¿½åŠ ã®å¤ªé™½å…‰æºï¼ˆæ§ãˆã‚ã«ï¼‰
            const sunLight2 = new THREE.PointLight(0xFFDD88, 1.2, 80);
            sunLight2.position.set(0, 0, 0);
            solarSystemGroup.add(sunLight2);
            
            // å¤ªé™½ã‚³ãƒ­ãƒŠå…‰æºï¼ˆã•ã‚‰ã«æ§ãˆã‚ã«ï¼‰
            const coronaLight = new THREE.PointLight(0xFFFFFF, 0.6, 60);
            coronaLight.position.set(0, 0, 0);
            solarSystemGroup.add(coronaLight);

            // ç’°å¢ƒå…‰ï¼ˆãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ãƒ‡ã‚£ãƒ†ãƒ¼ãƒ«ã‚’ä¿è­·ï¼‰
            const ambientLight = new THREE.AmbientLight(0x404080, 0.3);
            scene.add(ambientLight);

            // å°æƒ‘æ˜Ÿå¸¯ã‚’ä½œæˆï¼ˆç«æ˜Ÿã¨æœ¨æ˜Ÿã®é–“ï¼‰
            createAsteroidBelt();
            
            // ã‚«ã‚¤ãƒ‘ãƒ¼ãƒ™ãƒ«ãƒˆã‚’ä½œæˆï¼ˆæµ·ç‹æ˜Ÿã®å¤–å´ï¼‰
            createKuiperBelt();
            
            // å¤ªé™½ç³»å¤–ã®æ’æ˜Ÿã‚’ä½œæˆ
            createDistantStars();
            
            // é æ–¹ã®éŠ€æ²³ã‚’ä½œæˆ
            createDistantGalaxies();
            
            // æœ‰åãªæ˜Ÿåº§ã‚’ä½œæˆ
            createConstellations();
            
            // æƒ‘æ˜Ÿä½œæˆ
            planetData.forEach((data, index) => {
                const geometry = new THREE.SphereGeometry(data.size, 32, 16);
                const texture = createPlanetTexture(data.type, 1024);
                
                let material;
                if (data.name === 'å¤ªé™½') {
                    material = new THREE.MeshBasicMaterial({ 
                        map: texture,
                        emissive: new THREE.Color(data.emissive),
                        emissiveIntensity: 2.5,
                        transparent: false,
                        side: THREE.DoubleSide
                    });
                    
                    // å¤ªé™½ã«ã‚°ãƒ­ãƒ¼åŠ¹æœã‚’è¿½åŠ ï¼ˆã‚ˆã‚Šè‡ªç„¶ã«èª¿æ•´ï¼‰
                    const glowGeometry = new THREE.SphereGeometry(data.size * 1.15, 24, 12); // ã‚µã‚¤ã‚ºã‚’å°ã•ãã€ãƒãƒªã‚´ãƒ³æ•°å‰Šæ¸›
                    const glowMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            time: { value: 0 },
                            glowColor: { value: new THREE.Color(0xFFCC66) } // ã‚ˆã‚Šè‡ªç„¶ãªè‰²ã«
                        },
                        vertexShader: `
                            varying vec3 vNormal;
                            void main() {
                                vNormal = normalize(normalMatrix * normal);
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform float time;
                            uniform vec3 glowColor;
                            varying vec3 vNormal;
                            void main() {
                                float intensity = pow(0.6 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 1.5);
                                intensity *= (0.5 + 0.15 * sin(time * 2.0)); // ã‚ˆã‚Šæ§ãˆã‚ãªã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                                intensity *= 0.4; // å…¨ä½“çš„ã«é€æ˜åº¦ã‚’ä¸‹ã’ã‚‹
                                gl_FragColor = vec4(glowColor, intensity);
                            }
                        `,
                        side: THREE.BackSide,
                        blending: THREE.AdditiveBlending,
                        transparent: true,
                        depthWrite: false // æ·±åº¦æ›¸ãè¾¼ã¿ã‚’ç„¡åŠ¹ã«ã—ã¦ã‚ˆã‚Šè‡ªç„¶ã«
                    });
                    const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                    data.glowMaterial = glowMaterial; // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã«ä¿å­˜
                } else {
                    material = new THREE.MeshLambertMaterial({ 
                        map: texture,
                        bumpMap: texture,
                        bumpScale: 0.001
                    });
                }
                
                const planet = new THREE.Mesh(geometry, material);
                planet.position.x = data.distance;
                planet.castShadow = data.name !== 'å¤ªé™½';
                planet.receiveShadow = data.name !== 'å¤ªé™½';
                
                // å¤ªé™½ã®å ´åˆã¯ã‚°ãƒ­ãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’è¿½åŠ 
                if (data.name === 'å¤ªé™½' && data.glowMaterial) {
                    const glowGeometry = new THREE.SphereGeometry(data.size * 1.15, 24, 12); // è»½é‡åŒ–
                    const glowMesh = new THREE.Mesh(glowGeometry, data.glowMaterial);
                    planet.add(glowMesh);
                    data.glowMesh = glowMesh; // å‚ç…§ã‚’ä¿å­˜
                }
                
                // è»Œé“è¡¨ç¤º
                if (data.distance > 0) {
                    const orbitPoints = [];
                    for (let i = 0; i <= 64; i++) {
                        const angle = (i / 64) * Math.PI * 2;
                        orbitPoints.push(new THREE.Vector3(
                            Math.cos(angle) * data.distance,
                            0,
                            Math.sin(angle) * data.distance
                        ));
                    }
                    const orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
                    const orbitMaterial = new THREE.LineBasicMaterial({ 
                        color: 0x444444, 
                        transparent: true, 
                        opacity: 0.2
                    });
                    const orbit = new THREE.Line(orbitGeometry, orbitMaterial);
                    orbit.userData = { type: 'orbit' }; // è»Œé“ç·šã‚’è­˜åˆ¥ã™ã‚‹ã‚¿ã‚°
                    solarSystemGroup.add(orbit);
                }

                // åœŸæ˜Ÿã®ãƒªãƒ³ã‚°
                if (data.name === 'åœŸæ˜Ÿ') {
                    const ringGeometry = new THREE.RingGeometry(data.size + 0.03, data.size + 0.08, 32);
                    const ringMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xD2691E,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.8
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.PI / 2;
                    planet.add(ring);
                }

                // åœ°çƒã®æœˆ
                if (data.name === 'åœ°çƒ') {
                    const moonGeometry = new THREE.SphereGeometry(0.0035, 16, 8);
                    const moonMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                    const moon = new THREE.Mesh(moonGeometry, moonMaterial);
                    moon.position.x = 0.045;
                    moon.castShadow = true;
                    moon.userData = { speed: 0.08, distance: 0.045 };
                    planet.add(moon);
                }

                planets.push({ 
                    mesh: planet, 
                    data: data, 
                    angle: Math.random() * Math.PI * 2,
                    rotationSpeed: data.rotationSpeed
                });
                solarSystemGroup.add(planet);
            });

            setupXRControllers();
            animate();
            
            // ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å®Œäº†
            dataLoaded = true;
            
            // ãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹åŒ–
            const xrButton = document.getElementById('xr-button');
            if (xrSupported) {
                xrButton.disabled = false;
                xrButton.textContent = 'ğŸ¥½ MRå¤ªé™½ç³»ã‚’é–‹å§‹';
            }
            
            document.getElementById('loading').style.display = 'none';
        }

        // XRã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        function setupXRControllers() {
            // å·¦ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼
            const leftController = renderer.xr.getController(0);
            leftController.addEventListener('selectstart', (event) => onSelectStart(event, 'left'));
            leftController.addEventListener('selectend', (event) => onSelectEnd(event, 'left'));
            leftController.addEventListener('squeezestart', () => onGripStart('left'));
            leftController.addEventListener('squeezeend', () => onGripEnd('left'));
            scene.add(leftController);
            controllers.left = leftController;

            // å³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼
            const rightController = renderer.xr.getController(1);
            rightController.addEventListener('selectstart', (event) => onSelectStart(event, 'right'));
            rightController.addEventListener('selectend', (event) => onSelectEnd(event, 'right'));
            rightController.addEventListener('squeezestart', () => onGripStart('right'));
            rightController.addEventListener('squeezeend', () => onGripEnd('right'));
            scene.add(rightController);
            controllers.right = rightController;

            // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚°ãƒªãƒƒãƒ—
            const leftControllerGrip = renderer.xr.getControllerGrip(0);
            scene.add(leftControllerGrip);

            const rightControllerGrip = renderer.xr.getControllerGrip(1);
            scene.add(rightControllerGrip);

            // ãƒ¬ãƒ¼ã‚¶ãƒ¼ãƒã‚¤ãƒ³ã‚¿ãƒ¼ï¼ˆå³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ã¿ï¼‰
            const raycasterGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, -2)
            ]);
            const raycasterMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00ff88, 
                transparent: true, 
                opacity: 0.8 
            });

            const rightRay = new THREE.Line(raycasterGeometry, raycasterMaterial);
            rightController.add(rightRay);
        }

        // XRã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
        function onSelectStart(event, hand) {
            // æƒ…å ±ãƒ‘ãƒãƒ«ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹å ´åˆã¯é–‰ã˜ã‚‹
            if (planetInfoVisible) {
                hide3DPlanetInfo();
                return;
            }
            
            if (spaceMode) {
                // å®‡å®™ç©ºé–“ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆ
                if (highlightedPlanet) {
                    // æƒ‘æ˜ŸãŒãƒã‚¤ãƒ©ã‚¤ãƒˆã•ã‚Œã¦ã„ã‚‹å ´åˆã¯æƒ…å ±è¡¨ç¤º
                    show3DPlanetInfo(highlightedPlanet.data);
                } else {
                    // ä½•ã‚‚ãƒã‚¤ãƒ©ã‚¤ãƒˆã•ã‚Œã¦ã„ãªã„å ´åˆã¯MRãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã‚‹
                    toggleSpaceMode();
                }
                return;
            }
            
            // MRãƒ¢ãƒ¼ãƒ‰ã§ã®æ“ä½œ
            if (highlightedPlanet) {
                // æƒ‘æ˜ŸãŒãƒã‚¤ãƒ©ã‚¤ãƒˆã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ãã®æƒ‘æ˜Ÿæƒ…å ±ã‚’è¨˜éŒ²ã—ã¦VRãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆ
                pendingPlanetInfo = highlightedPlanet.data;
                toggleSpaceMode();
            }
        }

        function onSelectEnd(event, hand) {
            // ãƒˆãƒªã‚¬ãƒ¼çµ‚äº†
        }

        function onGripStart(hand) {
            gripStates[hand] = true;
            
            // ç‰‡æ‰‹ã‚°ãƒªãƒƒãƒ—ã®å ´åˆã¯ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹
            if ((gripStates.left && !gripStates.right) || (!gripStates.left && gripStates.right)) {
                isDragging = true;
                const controller = gripStates.left ? controllers.left : controllers.right;
                if (controller) {
                    const tempMatrix = new THREE.Matrix4();
                    tempMatrix.identity().extractRotation(controller.matrixWorld);
                    dragStartPosition.setFromMatrixPosition(controller.matrixWorld);
                    userStartPosition.copy(userPosition);
                }
            }
            
            // ä¸¡æ‰‹ã§ã‚°ãƒªãƒƒãƒ—ã—ãŸå ´åˆã®åˆæœŸè·é›¢ã‚’è¨˜éŒ²
            if (gripStates.left && gripStates.right && controllers.left && controllers.right) {
                isDragging = false;
                const leftPos = new THREE.Vector3();
                const rightPos = new THREE.Vector3();
                leftPos.setFromMatrixPosition(controllers.left.matrixWorld);
                rightPos.setFromMatrixPosition(controllers.right.matrixWorld);
                lastDistance = leftPos.distanceTo(rightPos);
            }
            
            updateGripStatus();
        }

        function onGripEnd(hand) {
            gripStates[hand] = false;
            isDragging = false;
            updateGripStatus();
        }

        function updateGripStatus() {
            const gripStatus = document.getElementById('grip-status');
            const isGripping = gripStates.left && gripStates.right;
            gripStatus.textContent = isGripping ? 'ON' : 'OFF';
            gripStatus.style.color = isGripping ? '#00ff88' : '#ffffff';
        }

        // 3Dæƒ‘æ˜Ÿæƒ…å ±ãƒ‘ãƒãƒ«ä½œæˆ
        function create3DInfoPanel(planetData) {
            const canvas = document.createElement('canvas');
            canvas.width = 600; // ã‚µã‚¤ã‚ºã‚’å¤§ãã
            canvas.height = 700;
            const ctx = canvas.getContext('2d');
            
            // èƒŒæ™¯
            ctx.fillStyle = 'rgba(0, 20, 40, 0.95)';
            ctx.fillRect(0, 0, 600, 700);
            
            // æ ç·š
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 4;
            ctx.strokeRect(0, 0, 600, 700);
            
            // å†…å´ã®è£…é£¾æ 
            ctx.strokeStyle = 'rgba(0, 255, 136, 0.3)';
            ctx.lineWidth = 2;
            ctx.strokeRect(10, 10, 580, 680);
            
            // æƒ‘æ˜Ÿå
            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 42px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(planetData.name, 300, 60);
            
            // ã‚¢ãƒ³ãƒ€ãƒ¼ãƒ©ã‚¤ãƒ³
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(100, 75);
            ctx.lineTo(500, 75);
            ctx.stroke();
            
            // åŸºæœ¬æƒ…å ±é …ç›®ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼ˆç°¡ç•¥åŒ–ï¼‰
            ctx.textAlign = 'left';
            let yPos = 120;
            const lineHeight = 40;
            
            const infoItems = [
                { label: 'è·é›¢', value: planetData.realDistance, icon: 'ğŸŒ' },
                { label: 'ã‚µã‚¤ã‚º', value: planetData.realSize, icon: 'ğŸ“' },
                { label: 'å…¬è»¢å‘¨æœŸ', value: planetData.period, icon: 'ğŸ”„' },
                { label: 'ç™ºè¦‹', value: planetData.discovery, icon: 'ğŸ”­' }
            ];
            
            infoItems.forEach(item => {
                // ã‚¢ã‚¤ã‚³ãƒ³
                ctx.font = '22px Arial';
                ctx.fillStyle = '#ffffff';
                ctx.fillText(item.icon, 30, yPos);
                
                // ãƒ©ãƒ™ãƒ«
                ctx.fillStyle = '#ffaa00';
                ctx.font = 'bold 22px Arial';
                ctx.fillText(item.label + ':', 70, yPos);
                
                // å€¤
                ctx.fillStyle = '#ffffff';
                ctx.font = '20px Arial';
                const labelWidth = ctx.measureText(item.label + ': ').width;
                ctx.fillText(item.value, 70 + labelWidth, yPos);
                
                yPos += lineHeight;
            });
            
            // ç‰¹å¾´ã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆã‚ˆã‚Šå¤§ããï¼‰
            yPos += 30;
            ctx.fillStyle = '#ffaa00';
            ctx.font = 'bold 28px Arial';
            ctx.fillText('âœ¨ ç‰¹å¾´:', 30, yPos);
            
            yPos += 40;
            ctx.fillStyle = '#ffffff';
            ctx.font = '18px Arial';
            
            // ç‰¹å¾´ãƒ†ã‚­ã‚¹ãƒˆã‚’è¤‡æ•°è¡Œã«åˆ†å‰²ï¼ˆã‚ˆã‚Šè©³ç´°ã«ï¼‰
            const features = planetData.feature;
            const maxWidth = 520;
            const words = features.split('');
            let line = '';
            
            for (let i = 0; i < words.length; i++) {
                const testLine = line + words[i];
                const metrics = ctx.measureText(testLine);
                
                if (metrics.width > maxWidth && i > 0) {
                    ctx.fillText(line, 50, yPos);
                    line = words[i];
                    yPos += 24;
                } else {
                    line = testLine;
                }
            }
            ctx.fillText(line, 50, yPos);
            
            // è±†çŸ¥è­˜ã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆã‚ˆã‚Šå¤§ããï¼‰
            yPos += 50;
            ctx.fillStyle = '#00ddff';
            ctx.font = 'bold 28px Arial';
            ctx.fillText('ğŸ’¡ è±†çŸ¥è­˜:', 30, yPos);
            
            yPos += 40;
            ctx.fillStyle = '#ddffdd';
            ctx.font = '18px Arial';
            
            // è±†çŸ¥è­˜ãƒ†ã‚­ã‚¹ãƒˆã‚’è¤‡æ•°è¡Œã«åˆ†å‰²ï¼ˆã‚ˆã‚Šè©³ç´°ã«ï¼‰
            const facts = planetData.fact;
            const factWords = facts.split('');
            let factLine = '';
            
            for (let i = 0; i < factWords.length; i++) {
                const testLine = factLine + factWords[i];
                const metrics = ctx.measureText(testLine);
                
                if (metrics.width > maxWidth && i > 0) {
                    ctx.fillText(factLine, 50, yPos);
                    factLine = factWords[i];
                    yPos += 24;
                } else {
                    factLine = testLine;
                }
            }
            ctx.fillText(factLine, 50, yPos);
            
            // æ“ä½œèª¬æ˜
            ctx.fillStyle = '#888888';
            ctx.font = '18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ãƒˆãƒªã‚¬ãƒ¼ã§é–‰ã˜ã‚‹', 300, 660);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            return texture;
        }

        function show3DPlanetInfo(planetData) {
            // æ—¢å­˜ã®ãƒ‘ãƒãƒ«ã‚’å³åº§ã«å®Œå…¨å‰Šé™¤
            if (planetInfoPanel) {
                removePlanetInfoPanel();
            }
            
            // åŠ¹æœéŸ³ã‚’å†ç”Ÿ
            playInfoPanelSound();
            
            const texture = create3DInfoPanel(planetData);
            const geometry = new THREE.PlaneGeometry(0.35, 0.4); // ã‚µã‚¤ã‚ºã‚’èª¿æ•´
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                side: THREE.DoubleSide,
                opacity: 0 // åˆæœŸå€¤ã‚’0ã«è¨­å®š
            });
            
            planetInfoPanel = new THREE.Mesh(geometry, material);
            planetInfoPanel.name = 'planet-info-panel';
            
            // å·¦æ‰‹ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ä½ç½®ã«é…ç½®
            if (controllers.left) {
                controllers.left.add(planetInfoPanel);
                // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‹ã‚‰å°‘ã—å‰æ–¹ã«é…ç½®
                planetInfoPanel.position.set(0, 0.1, -0.2);
                planetInfoPanel.rotation.x = -Math.PI / 6; // å°‘ã—ä¸‹å‘ãã«
            } else {
                // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãŒãªã„å ´åˆã¯ã‚·ãƒ¼ãƒ³ã«ç›´æ¥è¿½åŠ 
                scene.add(planetInfoPanel);
                planetInfoPanel.position.set(-0.5, 1.8, -1);
            }
            
            planetInfoVisible = true;
            
            // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
            panelFadeAnimation.target = 1;
            panelFadeAnimation.opacity = 0;
        }

        function hide3DPlanetInfo() {
            if (planetInfoPanel) {
                removePlanetInfoPanel();
            }
            
            planetInfoVisible = false;
        }

        // ãƒ‘ãƒãƒ«ã‚’å®Œå…¨ã«å‰Šé™¤ã™ã‚‹é–¢æ•°
        function removePlanetInfoPanel() {
            if (planetInfoPanel) {
                if (planetInfoPanel.parent) {
                    planetInfoPanel.parent.remove(planetInfoPanel);
                }
                
                scene.remove(planetInfoPanel);
                
                if (planetInfoPanel.material) {
                    if (planetInfoPanel.material.map) {
                        planetInfoPanel.material.map.dispose();
                    }
                    planetInfoPanel.material.dispose();
                }
                
                if (planetInfoPanel.geometry) {
                    planetInfoPanel.geometry.dispose();
                }
                
                planetInfoPanel = null;
                planetInfoVisible = false;
                
                panelFadeAnimation.opacity = 0;
                panelFadeAnimation.target = 0;
            }
        }

        // ãƒã‚¤ãƒ©ã‚¤ãƒˆåŠ¹æœ
        function highlightPlanet(planet) {
            if (highlightedPlanet && highlightedPlanet !== planet) {
                // å‰ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’å‰Šé™¤
                removeHighlight(highlightedPlanet);
            }
            
            highlightedPlanet = planet;
            
            try {
                const material = planet.mesh.material;
                
                // å¤ªé™½ã®å ´åˆã¯ç‰¹åˆ¥å‡¦ç†ï¼ˆã‚¹ãƒ ãƒ¼ã‚ºãªã‚¹ã‚±ãƒ¼ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
                if (planet.data.name === 'å¤ªé™½') {
                    // å¤ªé™½ã®å ´åˆã¯ã‚¹ã‚±ãƒ¼ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é–‹å§‹
                    if (!planet.originalScale) {
                        planet.originalScale = planet.mesh.scale.clone();
                        sunScaleAnimation.current = 1;
                    }
                    sunScaleAnimation.target = 1.1;
                } else {
                    // ä»–ã®æƒ‘æ˜Ÿã¯ç™ºå…‰åŠ¹æœ
                    if (!planet.originalEmissive) {
                        if (material.emissive) {
                            planet.originalEmissive = material.emissive.clone();
                        } else {
                            planet.originalEmissive = new THREE.Color(0x000000);
                        }
                        
                        if (material.emissiveIntensity !== undefined) {
                            planet.originalEmissiveIntensity = material.emissiveIntensity;
                        } else {
                            planet.originalEmissiveIntensity = 0;
                        }
                    }
                    
                    // ç™ºå…‰åŠ¹æœã‚’è¨­å®š
                    if (!material.emissive) {
                        material.emissive = new THREE.Color();
                    }
                    material.emissive.setHex(0x00ff88);
                    
                    if (material.emissiveIntensity !== undefined) {
                        material.emissiveIntensity = 0.3;
                    }
                }
            } catch (error) {
                console.error(`Error highlighting planet ${planet.data.name}:`, error);
            }
        }

        function removeHighlight(planet) {
            try {
                if (planet && planet.mesh) {
                    if (planet.data.name === 'å¤ªé™½') {
                        // å¤ªé™½ã®å ´åˆã¯ã‚¹ã‚±ãƒ¼ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å…ƒã«æˆ»ã™
                        sunScaleAnimation.target = 1;
                    } else {
                        // ä»–ã®æƒ‘æ˜Ÿã¯ç™ºå…‰ã‚’å…ƒã«æˆ»ã™
                        if (planet.mesh.material && planet.originalEmissive) {
                            const material = planet.mesh.material;
                            
                            if (material.emissive && planet.originalEmissive) {
                                material.emissive.copy(planet.originalEmissive);
                            }
                            
                            if (material.emissiveIntensity !== undefined && planet.originalEmissiveIntensity !== undefined) {
                                material.emissiveIntensity = planet.originalEmissiveIntensity;
                            }
                            
                            planet.originalEmissive = null;
                            planet.originalEmissiveIntensity = null;
                        }
                    }
                }
            } catch (error) {
                console.error(`Error removing highlight from planet:`, error);
            }
        }

        function clearHighlight() {
            if (highlightedPlanet) {
                removeHighlight(highlightedPlanet);
                highlightedPlanet = null;
            }
        }

        // XRã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹
        async function startXRSession() {
            if (!xrSupported || !dataLoaded) return;

            try {
                // BGMå†ç”Ÿé–‹å§‹
                if (bgMusic) {
                    try {
                        await bgMusic.play();
                    } catch (error) {
                        console.log('BGM autoplay prevented:', error);
                        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ“ä½œå¾Œã«å†ç”Ÿã‚’è©¦ã¿ã‚‹
                    }
                }

                let sessionInit = { 
                    requiredFeatures: ['local-floor'],
                    optionalFeatures: ['hand-tracking', 'anchors', 'plane-detection']
                };
                
                let session;
                try {
                    session = await navigator.xr.requestSession('immersive-ar', sessionInit);
                } catch (arError) {
                    session = await navigator.xr.requestSession('immersive-vr', sessionInit);
                }

                await renderer.xr.setSession(session);
                xrActive = true;
                
                // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’å†åˆæœŸåŒ–
                setupXRControllers();
                
                // å°‘ã—å¾…ã£ã¦ã‹ã‚‰ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å†è¨­å®š
                setTimeout(() => {
                    setupXRControllers();
                }, 500);

                // UIæ›´æ–°
                document.getElementById('xr-button').style.display = 'none';
                document.getElementById('instructions').style.display = 'none';
                document.getElementById('info-panel').style.display = 'block';

                session.addEventListener('end', () => {
                    xrActive = false;
                    
                    // BGMåœæ­¢
                    if (bgMusic) {
                        bgMusic.pause();
                        bgMusic.currentTime = 0;
                    }
                    
                    // 3Dæƒ…å ±ãƒ‘ãƒãƒ«ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                    hide3DPlanetInfo();
                    
                    // ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’ã‚¯ãƒªã‚¢
                    clearHighlight();
                    
                    // ä¿ç•™ä¸­ã®æƒ‘æ˜Ÿæƒ…å ±ã‚‚ã‚¯ãƒªã‚¢
                    pendingPlanetInfo = null;
                    
                    document.getElementById('xr-button').style.display = 'block';
                    document.getElementById('instructions').style.display = 'block';
                    document.getElementById('info-panel').style.display = 'none';
                });

            } catch (error) {
                alert('XRã‚»ãƒƒã‚·ãƒ§ãƒ³ã®é–‹å§‹ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
            }
        }

        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
        let time = 0;
        function animate() {
            renderer.setAnimationLoop(animate);
            time += 0.01;

            // å¤ªé™½ã®ã‚¹ã‚±ãƒ¼ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            if (Math.abs(sunScaleAnimation.current - sunScaleAnimation.target) > 0.001) {
                sunScaleAnimation.current += (sunScaleAnimation.target - sunScaleAnimation.current) * sunScaleAnimation.speed;
                
                // å¤ªé™½ã‚’è¦‹ã¤ã‘ã¦ã‚¹ã‚±ãƒ¼ãƒ«ã‚’é©ç”¨
                const sunPlanet = planets.find(p => p.data.name === 'å¤ªé™½');
                if (sunPlanet && sunPlanet.originalScale) {
                    sunPlanet.mesh.scale.copy(sunPlanet.originalScale);
                    sunPlanet.mesh.scale.multiplyScalar(sunScaleAnimation.current);
                }
            }

            // æƒ…å ±ãƒ‘ãƒãƒ«ã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            if (planetInfoPanel && Math.abs(panelFadeAnimation.opacity - panelFadeAnimation.target) > 0.001) {
                panelFadeAnimation.opacity += (panelFadeAnimation.target - panelFadeAnimation.opacity) * panelFadeAnimation.speed;
                
                // é€æ˜åº¦ã‚’é©ç”¨ï¼ˆ0ä»¥ä¸‹ã«ãªã‚‰ãªã„ã‚ˆã†ã«ï¼‰
                const actualOpacity = Math.max(0, Math.min(1, panelFadeAnimation.opacity));
                planetInfoPanel.material.opacity = actualOpacity;
                
                // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆå®Œäº†æ™‚ã«ãƒ‘ãƒãƒ«ã‚’å‰Šé™¤ï¼ˆã‚ˆã‚Šç¢ºå®Ÿãªåˆ¤å®šï¼‰
                if (panelFadeAnimation.target === 0 && (panelFadeAnimation.opacity <= 0.05 || actualOpacity <= 0.01)) {
                    removePlanetInfoPanel();
                }
            }

            // ã‚¹ãƒšãƒ¼ã‚¹ãƒ¢ãƒ¼ãƒ‰ã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            if (spaceFadeAnimation.transitioning) {
                const oldProgress = spaceFadeAnimation.progress;
                spaceFadeAnimation.progress += (spaceFadeAnimation.target - spaceFadeAnimation.progress) * spaceFadeAnimation.speed;
                
                applySpaceModeChange(spaceFadeAnimation.progress);
            }

            // å®‡å®™ç©ºé–“ãƒ¢ãƒ¼ãƒ‰ã§ã®æ˜Ÿã®å‹•ã
            if (spaceMode && spaceStars) {
                spaceRotation += 0.0001; // ã•ã‚‰ã«ã‚†ã£ãã‚Šã¨ã—ãŸå›è»¢
                spaceStars.rotation.y = spaceRotation;
                spaceStars.rotation.x = spaceRotation * 0.3;
                spaceStars.rotation.z = spaceRotation * 0.1;
            }

            // æƒ‘æ˜Ÿã®è»Œé“é‹å‹•ã¨è‡ªè»¢ï¼ˆå¸¸ã«å‹•ä½œï¼‰
            planets.forEach((planet) => {
                if (planet.data.distance > 0) {
                    planet.angle += planet.data.speed;
                    planet.mesh.position.x = Math.cos(planet.angle) * planet.data.distance;
                    planet.mesh.position.z = Math.sin(planet.angle) * planet.data.distance;
                }
                
                planet.mesh.rotation.y += planet.rotationSpeed;
                
                // å¤ªé™½ã®ã‚°ãƒ­ãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆæ›´æ–°
                if (planet.data.name === 'å¤ªé™½' && planet.data.glowMaterial) {
                    planet.data.glowMaterial.uniforms.time.value = time;
                }
                
                // è¡›æ˜Ÿã®å…¬è»¢
                planet.mesh.children.forEach(moon => {
                    if (moon.userData && moon.userData.speed) {
                        const moonAngle = time * moon.userData.speed;
                        moon.position.x = Math.cos(moonAngle) * moon.userData.distance;
                        moon.position.z = Math.sin(moonAngle) * moon.userData.distance;
                    }
                });
            });

            // å°æƒ‘æ˜Ÿã¨ã‚«ã‚¤ãƒ‘ãƒ¼ãƒ™ãƒ«ãƒˆå¤©ä½“ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            solarSystemGroup.children.forEach(child => {
                if (child.isGroup) {
                    child.children.forEach(object => {
                        if (object.userData && object.userData.rotationSpeed) {
                            // è‡ªè»¢
                            object.rotation.x += object.userData.rotationSpeed;
                            object.rotation.y += object.userData.rotationSpeed * 0.7;
                            object.rotation.z += object.userData.rotationSpeed * 0.3;
                            
                            // å…¬è»¢ï¼ˆå°æƒ‘æ˜Ÿã¨ã‚«ã‚¤ãƒ‘ãƒ¼ãƒ™ãƒ«ãƒˆå¤©ä½“ï¼‰
                            if (object.userData.orbitSpeed) {
                                object.userData.angle += object.userData.orbitSpeed;
                                object.position.x = Math.cos(object.userData.angle) * object.userData.distance;
                                object.position.z = Math.sin(object.userData.angle) * object.userData.distance;
                            }
                        }
                    });
                }
            });

            // é æ–¹ã®éŠ€æ²³ã®å›è»¢
            scene.children.forEach(child => {
                if (child.isGroup && child.children.length > 0) {
                    child.children.forEach(galaxy => {
                        if (galaxy.userData && galaxy.userData.rotationSpeed) {
                            galaxy.rotation.z += galaxy.userData.rotationSpeed;
                        }
                    });
                }
            });

            // ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆï¼ˆå³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‹ã‚‰æƒ‘æ˜Ÿã¸ã®å½“ãŸã‚Šåˆ¤å®š - å¸¸ã«å‹•ä½œï¼‰
            if (xrActive && controllers.right && !planetInfoVisible) {
                try {
                    // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ä½ç½®ã¨æ–¹å‘ã‚’å–å¾—
                    const tempMatrix = new THREE.Matrix4();
                    tempMatrix.identity().extractRotation(controllers.right.matrixWorld);
                    
                    const controllerPosition = new THREE.Vector3();
                    controllerPosition.setFromMatrixPosition(controllers.right.matrixWorld);
                    
                    const controllerDirection = new THREE.Vector3(0, 0, -1);
                    controllerDirection.applyMatrix4(tempMatrix);
                    controllerDirection.normalize();
                    
                    raycaster.set(controllerPosition, controllerDirection);
                    
                    // æƒ‘æ˜Ÿã®ãƒ¡ãƒƒã‚·ãƒ¥ã®ã¿ã‚’ãƒã‚§ãƒƒã‚¯
                    const planetMeshes = planets.map(p => p.mesh).filter(mesh => mesh && mesh.visible);
                    const intersects = raycaster.intersectObjects(planetMeshes);
                    
                    if (intersects.length > 0) {
                        const intersectedPlanet = planets.find(p => p.mesh === intersects[0].object);
                        if (intersectedPlanet && intersectedPlanet !== highlightedPlanet) {
                            highlightPlanet(intersectedPlanet);
                        }
                    } else {
                        clearHighlight();
                    }
                } catch (error) {
                    // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã¯ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’ã‚¯ãƒªã‚¢
                    clearHighlight();
                }
            }

            // ç‰‡æ‰‹ã‚°ãƒªãƒƒãƒ—ã§ã®ãƒ‰ãƒ©ãƒƒã‚°ç§»å‹•ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ä½ç½®ã‚’ç§»å‹•ï¼‰
            if (isDragging) {
                const activeController = gripStates.left ? controllers.left : controllers.right;
                if (activeController) {
                    const currentPosition = new THREE.Vector3();
                    currentPosition.setFromMatrixPosition(activeController.matrixWorld);
                    
                    const deltaPosition = new THREE.Vector3().subVectors(currentPosition, dragStartPosition);
                    // ç§»å‹•æ–¹å‘ã‚’åè»¢ã•ã›ã¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒç§»å‹•ã—ã¦ã„ã‚‹æ„Ÿè¦šã«ã™ã‚‹
                    deltaPosition.multiplyScalar(-5);
                    userPosition.copy(userStartPosition).add(deltaPosition);
                    
                    // ã‚«ãƒ¡ãƒ©ã¨ã‚·ãƒ¼ãƒ³å…¨ä½“ã®ä½ç½®ã‚’æ›´æ–°
                    updateUserPosition();
                }
            }

            // ä¸¡æ‰‹ã‚°ãƒªãƒƒãƒ—ã§ã®ã‚¹ã‚±ãƒ¼ãƒ«èª¿æ•´ï¼ˆå¸¸ã«å‹•ä½œï¼‰
            if (gripStates.left && gripStates.right && controllers.left && controllers.right && !isDragging) {
                const leftPos = new THREE.Vector3();
                const rightPos = new THREE.Vector3();
                leftPos.setFromMatrixPosition(controllers.left.matrixWorld);
                rightPos.setFromMatrixPosition(controllers.right.matrixWorld);
                const currentDistance = leftPos.distanceTo(rightPos);
                
                if (lastDistance > 0 && currentDistance > 0) {
                    const scaleChange = currentDistance / lastDistance;
                    scaleFactor *= scaleChange;
                    
                    // ã‚¹ã‚±ãƒ¼ãƒ«åˆ¶é™
                    scaleFactor = Math.max(0.1, Math.min(10, scaleFactor));
                    
                    solarSystemGroup.scale.setScalar(scaleFactor);
                    
                    // UIæ›´æ–°
                    document.getElementById('scale-value').textContent = scaleFactor.toFixed(2);
                }
                
                lastDistance = currentDistance;
            }

            renderer.render(scene, camera);
        }

        // ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ©ãƒ¼
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        window.addEventListener('resize', onWindowResize);
        document.getElementById('xr-button').addEventListener('click', startXRSession);

        // åˆæœŸåŒ–é–‹å§‹
        checkXRSupport().then(() => {
            init();
        });

        // å®‡å®™ç©ºé–“ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
        function toggleSpaceMode() {
            if (spaceFadeAnimation.transitioning) {
                return; // æ—¢ã«ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ä¸­ã®å ´åˆã¯ç„¡è¦–
            }
            
            spaceFadeAnimation.transitioning = true;
            spaceFadeAnimation.targetMode = !spaceMode;
            
            if (spaceFadeAnimation.targetMode) {
                // å®‡å®™ç©ºé–“ãƒ¢ãƒ¼ãƒ‰ã¸
                spaceFadeAnimation.target = 1;
                spaceFadeAnimation.progress = 0;
            } else {
                // MRãƒ¢ãƒ¼ãƒ‰ã¸
                spaceFadeAnimation.target = 1;
                spaceFadeAnimation.progress = 0;
            }
        }

        // ãƒ•ã‚§ãƒ¼ãƒ‰åŠ¹æœä»˜ãã®å®Ÿéš›ã®ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
        function applySpaceModeChange(progress) {
            const targetMode = spaceFadeAnimation.targetMode;
            
            if (targetMode) {
                // å®‡å®™ç©ºé–“ãƒ¢ãƒ¼ãƒ‰ã¸ã®åˆ‡ã‚Šæ›¿ãˆ
                if (originalStars && originalStars.material) {
                    originalStars.material.opacity = Math.max(0, 1 - progress);
                }
                if (spaceStars && spaceStars.material) {
                    spaceStars.material.opacity = Math.min(1, progress);
                }
                
                // èƒŒæ™¯çƒä½“ã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ï¼ˆå®Œå…¨ã«ä¸é€æ˜ã«ï¼‰
                if (backgroundSphere && backgroundSphere.material) {
                    backgroundSphere.material.opacity = Math.min(1.0, progress);
                }
                
                // æ˜Ÿã®è¡¨ç¤ºçŠ¶æ…‹ã‚’ç®¡ç†
                if (progress > 0.1) {
                    spaceStars.visible = true;
                    backgroundSphere.visible = true;
                }
                if (progress > 0.9) {
                    originalStars.visible = false;
                }
                
                // ã‚«ãƒ¡ãƒ©ä½ç½®ã®è£œé–“
                const startPos = new THREE.Vector3(0, 1.6, 5);
                const endPos = new THREE.Vector3(0, 0, 0);
                camera.position.lerpVectors(startPos, endPos, progress);
                
            } else {
                // MRãƒ¢ãƒ¼ãƒ‰ã¸ã®å¾©å¸°
                if (spaceStars && spaceStars.material) {
                    spaceStars.material.opacity = Math.max(0, 1 - progress);
                }
                if (originalStars && originalStars.material) {
                    originalStars.material.opacity = Math.min(1, progress);
                }
                
                // èƒŒæ™¯çƒä½“ã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
                if (backgroundSphere && backgroundSphere.material) {
                    backgroundSphere.material.opacity = Math.max(0, 1.0 * (1 - progress));
                }
                
                // æ˜Ÿã®è¡¨ç¤ºçŠ¶æ…‹ã‚’ç®¡ç†
                if (progress > 0.1) {
                    originalStars.visible = true;
                }
                if (progress > 0.9) {
                    spaceStars.visible = false;
                    backgroundSphere.visible = false;
                }
                
                // ã‚«ãƒ¡ãƒ©ä½ç½®ã®è£œé–“
                const startPos = new THREE.Vector3(0, 0, 0);
                const endPos = new THREE.Vector3(0, 1.6, 5);
                camera.position.lerpVectors(startPos, endPos, progress);
            }
            
            // å®Œäº†å‡¦ç†
            if (Math.abs(progress - spaceFadeAnimation.target) < 0.05) {
                spaceMode = targetMode;
                spaceFadeAnimation.transitioning = false;
                
                if (spaceMode) {
                    // å®‡å®™ç©ºé–“ãƒ¢ãƒ¼ãƒ‰å®Œäº†
                    originalStars.visible = false;
                    spaceStars.visible = true;
                    backgroundSphere.visible = true;
                    originalStars.material.opacity = 0;
                    spaceStars.material.opacity = 1;
                    backgroundSphere.material.opacity = 1.0;
                    camera.position.set(0, 0, 0);
                    
                    // VRãƒ¢ãƒ¼ãƒ‰ã§ã¯è»Œé“ç·šã‚’éè¡¨ç¤º
                    toggleOrbitVisibility(false);
                    
                    // è¨˜éŒ²ã•ã‚ŒãŸæƒ‘æ˜Ÿæƒ…å ±ãŒã‚ã‚Œã°è‡ªå‹•è¡¨ç¤º
                    if (pendingPlanetInfo) {
                        setTimeout(() => {
                            show3DPlanetInfo(pendingPlanetInfo);
                            pendingPlanetInfo = null;
                        }, 500);
                    }
                } else {
                    // MRãƒ¢ãƒ¼ãƒ‰å®Œäº†
                    spaceStars.visible = false;
                    originalStars.visible = true;
                    backgroundSphere.visible = false;
                    spaceStars.material.opacity = 0;
                    originalStars.material.opacity = 1;
                    backgroundSphere.material.opacity = 0;
                    camera.position.set(0, 1.6, 5);
                    
                    // MRãƒ¢ãƒ¼ãƒ‰ã§ã¯è»Œé“ç·šã‚’è¡¨ç¤º
                    toggleOrbitVisibility(true);
                    
                    // MRãƒ¢ãƒ¼ãƒ‰å¾©å¸°æ™‚ã¯ä¿ç•™ä¸­ã®æƒ‘æ˜Ÿæƒ…å ±ã‚’ã‚¯ãƒªã‚¢
                    pendingPlanetInfo = null;
                }
            }
        }

        // æ§ãˆã‚ãªåŠ¹æœéŸ³ã‚’ç”Ÿæˆãƒ»å†ç”Ÿã™ã‚‹é–¢æ•°
        function playInfoPanelSound() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (error) {
                    return;
                }
            }

            try {
                // è¤‡æ•°ã®éŸ³ã‚’é‡ã­ã¦ç¾ã—ã„åŠ¹æœéŸ³ã‚’ä½œæˆ
                const now = audioContext.currentTime;
                
                // ãƒ¡ã‚¤ãƒ³ãƒ™ãƒ«éŸ³ï¼ˆåŸºéŸ³ï¼‰
                const oscillator1 = audioContext.createOscillator();
                const gainNode1 = audioContext.createGain();
                oscillator1.connect(gainNode1);
                gainNode1.connect(audioContext.destination);
                
                oscillator1.frequency.setValueAtTime(880, now); // A5éŸ³
                oscillator1.frequency.exponentialRampToValueAtTime(660, now + 0.5); // E5éŸ³ã¸ä¸‹é™
                oscillator1.type = 'sine';
                
                gainNode1.gain.setValueAtTime(0, now);
                gainNode1.gain.linearRampToValueAtTime(0.15, now + 0.02);
                gainNode1.gain.exponentialRampToValueAtTime(0.001, now + 1.2);
                
                // ãƒãƒ¼ãƒ¢ãƒ‹ãƒ¼éŸ³ï¼ˆç¬¬5åº¦ï¼‰
                const oscillator2 = audioContext.createOscillator();
                const gainNode2 = audioContext.createGain();
                oscillator2.connect(gainNode2);
                gainNode2.connect(audioContext.destination);
                
                oscillator2.frequency.setValueAtTime(1320, now); // E6éŸ³
                oscillator2.frequency.exponentialRampToValueAtTime(990, now + 0.5); // B5éŸ³ã¸ä¸‹é™
                oscillator2.type = 'sine';
                
                gainNode2.gain.setValueAtTime(0, now);
                gainNode2.gain.linearRampToValueAtTime(0.08, now + 0.02);
                gainNode2.gain.exponentialRampToValueAtTime(0.001, now + 1.0);
                
                // å¾®ç´°ãªéŸ¿ãï¼ˆã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ä¸Šï¼‰
                const oscillator3 = audioContext.createOscillator();
                const gainNode3 = audioContext.createGain();
                oscillator3.connect(gainNode3);
                gainNode3.connect(audioContext.destination);
                
                oscillator3.frequency.setValueAtTime(1760, now); // A6éŸ³
                oscillator3.type = 'triangle';
                
                gainNode3.gain.setValueAtTime(0, now);
                gainNode3.gain.linearRampToValueAtTime(0.04, now + 0.01);
                gainNode3.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
                
                // å†ç”Ÿé–‹å§‹
                oscillator1.start(now);
                oscillator1.stop(now + 1.2);
                
                oscillator2.start(now);
                oscillator2.stop(now + 1.0);
                
                oscillator3.start(now);
                oscillator3.stop(now + 0.8);
                
            } catch (error) {
                // ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
            }
        }

        // è»Œé“ç·šã®è¡¨ç¤ºåˆ¶å¾¡
        function toggleOrbitVisibility(visible) {
            solarSystemGroup.children.forEach(child => {
                if (child.userData && child.userData.type === 'orbit') {
                    child.visible = visible;
                }
            });
        }

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½ç½®ã®æ›´æ–°
        function updateUserPosition() {
            if (!xrActive) {
                // éXRãƒ¢ãƒ¼ãƒ‰ã§ã®ã‚«ãƒ¡ãƒ©ä½ç½®æ›´æ–°
                camera.position.copy(userPosition);
            } else {
                // XRãƒ¢ãƒ¼ãƒ‰ã§ã¯å¤ªé™½ç³»ã‚°ãƒ«ãƒ¼ãƒ—ã®ä½ç½®ã‚’ç›¸å¯¾çš„ã«èª¿æ•´
                const offset = new THREE.Vector3().subVectors(new THREE.Vector3(0, 1.6, 5), userPosition);
                solarSystemGroup.position.copy(offset);
                
                // ä»–ã®å®‡å®™è¦ç´ ã‚‚åŒã˜ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’é©ç”¨
                scene.children.forEach(child => {
                    if (child !== solarSystemGroup && child.isGroup && child.children.length > 0) {
                        // æ˜Ÿåº§ã‚„é æ–¹å¤©ä½“ã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ç§»å‹•
                        if (child.children[0] && child.children[0].name && 
                            (child.children[0].name.includes('ãƒ™ãƒ†ãƒ«ã‚®ã‚¦ã‚¹') || 
                             child.children[0].name.includes('åŒ—æ–—ä¸ƒæ˜Ÿ') ||
                             child.children[0].userData)) {
                            child.position.copy(offset);
                        }
                    }
                });
            }
        }
    </script>
</body>
</html>